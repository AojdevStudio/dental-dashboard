# CRITICAL: RLS Authorization Bypass Vulnerability

**Issue ID:** RLS-001  
**Linear Issue:** KAM-3  
**Severity:** CRITICAL  
**Category:** Security  
**Component:** PostgreSQL RLS Context Functions  
**Date Identified:** 2025-06-19  
**Status:** TRACKED FOR PHASE 3 - Foreign key relationships required  
**Timeline:** Planned for Phase 3 implementation

## Summary

The `public.set_clinic_context()` function contains a critical security vulnerability that completely undermines the multi-tenant isolation system. Any authenticated user can set the clinic context to any clinic ID, gaining unauthorized access to all data belonging to other clinics.

## Technical Details

### Vulnerable Code Location
File: `migrations/001_rls_context_functions.sql`  
Function: `public.set_clinic_context(clinic_id UUID)`  
Lines: 9-24

### Current Implementation
```sql
CREATE OR REPLACE FUNCTION public.set_clinic_context(clinic_id UUID)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
BEGIN
  -- Validate that clinic_id is not null
  IF clinic_id IS NULL THEN
    RAISE EXCEPTION 'Clinic ID cannot be null';
  END IF;
  
  -- Set the clinic context in session-scoped variable
  PERFORM set_config('app.current_clinic_id', clinic_id::text, false);
END;
$$;
```

### Security Flaw
The function only validates that `clinic_id` is not null but **does not verify** that the calling user has authorization to access the specified clinic. This allows:

1. **Cross-tenant data access**: A user from Clinic A can call `SELECT public.set_clinic_context('<clinic_b_id>')` and gain full access to Clinic B's data
2. **Complete bypass of RLS policies**: All RLS policies depend on `public.get_current_clinic_id()`, which returns the value set by this function
3. **Privilege escalation**: Any authenticated user can access any clinic's sensitive data

### Impact Assessment
- **Data Confidentiality**: COMPROMISED - All patient data, financial records, and business metrics exposed
- **Regulatory Compliance**: VIOLATED - HIPAA violations for cross-clinic PHI access
- **Business Impact**: SEVERE - Complete breakdown of multi-tenant isolation
- **Trust**: CRITICAL - Clients' data security fundamentally compromised

## Exploitation Scenario

1. User Alice is authorized for Clinic A (ID: `clinic-a-123`)
2. Alice discovers Clinic B's ID (ID: `clinic-b-456`) through various means
3. Alice executes: `SELECT public.set_clinic_context('clinic-b-456')`
4. Alice can now query any table and access all of Clinic B's data:
   ```sql
   SELECT * FROM users; -- Returns Clinic B users
   SELECT * FROM dentist_production; -- Returns Clinic B production data
   SELECT * FROM location_financial; -- Returns Clinic B financial data
   ```

## Root Cause Analysis

### Missing Authorization Logic
The function lacks integration with the user-clinic relationship validation. It should verify that:
1. The current user (via `auth.uid()` in Supabase) exists in the system
2. The user has a valid role/association with the requested clinic
3. The user's permissions allow them to access the clinic's data

### Design Assumptions
The original design assumed that application-level access controls would prevent unauthorized context switching, but RLS should provide defense-in-depth security at the database level.

## Proposed Fix

### Solution Overview
Implement user authorization validation within the `set_clinic_context` function by checking the `user_clinic_roles` table to ensure the calling user has legitimate access to the requested clinic.

### Updated Function Implementation

```sql
-- SECURE VERSION: Add authorization validation
CREATE OR REPLACE FUNCTION public.set_clinic_context(clinic_id TEXT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  current_user_id TEXT;
  is_authorized BOOLEAN := FALSE;
BEGIN
  -- Validate that clinic_id is not null
  IF clinic_id IS NULL OR clinic_id = '' THEN
    RAISE EXCEPTION 'Clinic ID cannot be null or empty';
  END IF;
  
  -- Get the current authenticated user ID from Supabase
  current_user_id := auth.uid()::text;
  
  -- Validate that user is authenticated
  IF current_user_id IS NULL THEN
    RAISE EXCEPTION 'User must be authenticated to set clinic context';
  END IF;
  
  -- CRITICAL FIX: Verify the calling user is authorized for the requested clinic
  SELECT EXISTS (
    SELECT 1
    FROM public.user_clinic_roles ucr
    WHERE ucr.clinic_id = set_clinic_context.clinic_id
      AND ucr.user_id = current_user_id
      AND ucr.status = 'active' -- Assuming there's a status field
  ) INTO is_authorized;

  -- Deny access if user is not authorized for this clinic
  IF NOT is_authorized THEN
    RAISE EXCEPTION 'Access denied: User % is not authorized for clinic %', 
                    current_user_id, clinic_id;
  END IF;
  
  -- Only set context if authorization succeeds
  PERFORM set_config('app.current_clinic_id', clinic_id, false);
  
  -- Log the context switch for audit purposes
  RAISE NOTICE 'Clinic context set to % for user %', clinic_id, current_user_id;
END;
$$;
```

### Required Database Schema Updates

Ensure the `user_clinic_roles` table has proper structure:

```sql
-- Verify/Create user_clinic_roles table structure
CREATE TABLE IF NOT EXISTS public.user_clinic_roles (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  user_id TEXT NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  clinic_id TEXT NOT NULL REFERENCES public.clinics(id) ON DELETE CASCADE,
  role TEXT NOT NULL DEFAULT 'user', -- 'admin', 'user', 'viewer', etc.
  status TEXT NOT NULL DEFAULT 'active', -- 'active', 'inactive', 'suspended'
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  UNIQUE(user_id, clinic_id)
);

-- Create index for performance
CREATE INDEX IF NOT EXISTS idx_user_clinic_roles_lookup 
ON public.user_clinic_roles(user_id, clinic_id, status);
```

### Phase 3 Implementation Plan

This fix is **planned for Phase 3** as it requires the foreign key relationships to be established first. The migration will be `migrations/005_fix_rls_authorization.sql` (after Phase 3 schema updates).

```sql
-- Migration: 004_fix_rls_authorization.sql
-- Description: Fix critical authorization bypass in set_clinic_context function
-- Created: 2025-06-19
-- Priority: CRITICAL - SECURITY FIX

BEGIN;

-- Drop the vulnerable function
DROP FUNCTION IF EXISTS public.set_clinic_context(UUID);
DROP FUNCTION IF EXISTS public.set_clinic_context(TEXT);

-- Create the secure version with authorization validation
CREATE OR REPLACE FUNCTION public.set_clinic_context(clinic_id TEXT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
  current_user_id TEXT;
  is_authorized BOOLEAN := FALSE;
BEGIN
  -- Validate that clinic_id is not null
  IF clinic_id IS NULL OR clinic_id = '' THEN
    RAISE EXCEPTION 'Clinic ID cannot be null or empty';
  END IF;
  
  -- Get the current authenticated user ID from Supabase
  current_user_id := auth.uid()::text;
  
  -- Validate that user is authenticated
  IF current_user_id IS NULL THEN
    RAISE EXCEPTION 'User must be authenticated to set clinic context';
  END IF;
  
  -- CRITICAL FIX: Verify the calling user is authorized for the requested clinic
  SELECT EXISTS (
    SELECT 1
    FROM public.user_clinic_roles ucr
    WHERE ucr.clinic_id = set_clinic_context.clinic_id
      AND ucr.user_id = current_user_id
      AND ucr.status = 'active'
  ) INTO is_authorized;

  -- Deny access if user is not authorized for this clinic
  IF NOT is_authorized THEN
    RAISE EXCEPTION 'Access denied: User % is not authorized for clinic %', 
                    current_user_id, clinic_id;
  END IF;
  
  -- Only set context if authorization succeeds
  PERFORM set_config('app.current_clinic_id', clinic_id, false);
  
  -- Log the context switch for audit purposes
  RAISE NOTICE 'Clinic context set to % for user %', clinic_id, current_user_id;
END;
$$;

-- Re-grant permissions
GRANT EXECUTE ON FUNCTION public.set_clinic_context(TEXT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.set_clinic_context(TEXT) TO service_role;

-- Update function comment
COMMENT ON FUNCTION public.set_clinic_context(TEXT) IS 'Securely set clinic context for the current session with user authorization validation';

-- Log migration completion
INSERT INTO migrations (name, executed_at) VALUES ('004_fix_rls_authorization', NOW())
ON CONFLICT (name) DO UPDATE SET executed_at = NOW();

COMMIT;
```

## Additional Security Enhancements

### 1. Audit Logging
Implement audit logging for all context switches:

```sql
-- Create audit log table
CREATE TABLE IF NOT EXISTS public.clinic_context_audit (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  user_id TEXT NOT NULL,
  clinic_id TEXT NOT NULL,
  action TEXT NOT NULL, -- 'context_set', 'context_failed'
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### 2. Rate Limiting
Consider implementing rate limiting for context switching to prevent brute-force attacks.

### 3. Admin Override Function
Create a separate function for administrative access with additional logging:

```sql
CREATE OR REPLACE FUNCTION public.admin_set_clinic_context(clinic_id TEXT, reason TEXT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Additional admin validation logic
  -- Enhanced audit logging with reason
  -- Administrative context setting
END;
$$;
```

## Testing Plan

### 1. Security Testing
```sql
-- Test 1: Unauthorized access attempt
-- User A tries to access Clinic B's data
SELECT public.set_clinic_context('unauthorized-clinic-id');
-- Expected: Exception raised

-- Test 2: Authorized access
-- User A accesses their authorized clinic
SELECT public.set_clinic_context('authorized-clinic-id');
-- Expected: Success

-- Test 3: Unauthenticated access
-- No user session, attempt to set context
SELECT public.set_clinic_context('any-clinic-id');
-- Expected: Exception raised
```

### 2. Integration Testing
- Verify application-level integration continues to work
- Test error handling in client applications
- Validate audit logging functionality

## Timeline and Priority

**PLANNED FOR PHASE 3**

This critical security fix aligns with the planned Phase 3 implementation as documented in `prisma/schema-multi-tenant-additions.prisma:16`. The vulnerability exists because foreign key relationships are not yet established.

**Phase 3 Timeline:**
1. **Schema Update**: Establish User-Clinic foreign key relationships  
2. **Security Fix**: Apply authorization validation migration
3. **Testing**: Comprehensive security and integration testing
4. **Deployment**: Production deployment with monitoring
5. **Validation**: Security audit and penetration testing

**Linear Issue:** [KAM-3](https://linear.app/aojdevstudio/issue/KAM-3) tracks this implementation

## References

- [PostgreSQL Row Level Security Documentation](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)
- [Supabase RLS Best Practices](https://supabase.com/docs/guides/database/postgres/row-level-security)
- [OWASP Database Security Guidelines](https://owasp.org/www-project-database-security/)

---

**This is a CRITICAL security vulnerability that must be addressed immediately before any production deployment.**