This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.ts, **/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.windsurf/
  rules/
    cursor-rules.md
    data-flow.md
    database-functions.md
    get-api-route.md
    installing-packages.md
    naming-conventions.md
    prisma.md
    project-structure.md
    rls-policies.md
    server-components.md
    shadcn-component-tracking.md
    supabase-auth-setup.md
    supabase-edge-functions.md
    testing.md
    ui-components.md
docs/
  auth-flow.md
  learnings.md
  primsa-commands.md
  scratchpad.md
  ux-rubric.md
  vibe-coding.md
scripts/
  README.md
src/
  generated/
    prisma/
      runtime/
        index-browser.d.ts
        library.d.ts
      client.d.ts
      default.d.ts
      edge.d.ts
      index.d.ts
      wasm.d.ts
  lib/
    supabase/
      client.ts
      server.ts
    prisma.ts
    utils.ts
  middleware.ts
README-task-master.md
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/ux-rubric.md">
| Category                   | Description | A                                                                                                                              | B                                                                                                                              | C                                                                                                                          | D                                                                                                                    | F                                                                                                                       |
| -------------------------- | ----------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| **Color Palette**          | Weight: 1x  | Colors are masterfully integrated, perfectly reflecting the brand and balancing contrast for optimal usability.                | Colors are thoughtfully selected, support brand identity, and maintain a mostly consistent visual hierarchy.                   | A serviceable color scheme is present, though minor inconsistencies or contrast issues reduce overall effectiveness.       | Colors are partially aligned with the brand but fail to follow best practices in contrast or hierarchy.              | Colors are chosen at random, creating visual confusion and lacking any cohesive theme or brand alignment.               |
| **Layout & Grid**          | Weight: 1x  | Grid usage is expertly executed, ensuring balanced spacing, alignment consistency, and a crisp, professional structure.        | A purposeful grid strategy creates a cohesive layout; minor alignment or spacing issues may still be noticed.                  | Layout generally follows a grid, though some elements deviate; overall structure is acceptable but not optimal.            | Some grid principles are followed, but spacing is inconsistent and visual alignment suffers in key sections.         | No clear structure or grid system in place, resulting in a disorganized and hard-to-navigate layout.                    |
| **Typography**             | Weight: 1x  | Typography is outstanding, with well-chosen fonts, impeccable kerning, and a clean hierarchy that enhances user engagement.    | Typography choices reflect a solid visual hierarchy and balanced kerning; minor refinements may further improve readability.   | Typography is functional with moderately consistent styles, though headlines, body text, and spacing could be refined.     | Font selection is somewhat appropriate but lacks clear organization; kerning and leading inconsistencies persist.    | Font choices are erratic or unreadable, with rampant inconsistencies in size, weight, or familial styles.               |
| **Hierarchy & Navigation** | Weight: 1x  | Flawless content hierarchy with intuitive navigation that effortlessly guides users to core features and information.          | Content levels are well-defined, and primary navigation is accessible; minor tweaks could enhance usability further.           | A straightforward hierarchy is established, though key actions or navigation items could be more prominently displayed.    | Some attempt at prioritizing content is visible, yet users may struggle to locate important features easily.         | Information is scattered without clear importance levels; navigation elements are unrecognizable or absent.             |
| **Accessibility**          | Weight: 1x  | Fully meets or exceeds accessibility best practices, ensuring all users can easily interact with and understand the dashboard. | The design largely complies with accessibility standards; minor improvements could include more robust testing or refinements. | Basic accessibility measures are present, though certain features like keyboard navigation or ARIA tags may be incomplete. | Some attempts to address accessibility are made, yet many crucial guidelines (e.g., color contrast) remain unmet.    | Design disregards accessibility guidelines altogether, using low contrast, illegible fonts, and no accessible patterns. |
| **Spacing & Alignment**    | Weight: 1x  | A perfectly balanced layout with deliberate spacing; every element is precisely aligned for maximum readability.               | Thoughtful use of white space and alignment creates a clean layout with only minor areas needing adjustment.                   | Spacing and alignment are mostly consistent, though certain sections need refinement to enhance clarity.                   | Some uniformity in spacing is emerging, but inconsistent alignment detracts from legibility and overall visual flow. | Visual clutter dominates due to no consistent margins, padding, or alignment, making the interface look unfinished.     |
</file>

<file path="docs/vibe-coding.md">
# Vibe Coding: AI-Powered Development Strategies

## üìë Table of Contents
- Executive Summary
- Introduction to Vibe Coding
- üë®‚Äçüíª Vibe Coding Tips
  - Tip 1: Use an AI-Friendly Stack
  - Tip 2: Start Outside the IDE
  - Tip 3: Use an Agent Task `md` File
  - Tip 4: Start with Storybook
  - Tip 5: Use a Rubric for Better Output
  - Tip 6: Copy & Paste the Codebase
  - Tip 7: Optimize Your Cursor Rules
  - Tip 8: Use a Cursor Update Log
  - Tip 9: MIP ‚Äî "Make It Pop"
  - Tip 10: Debug Through Reasoning, Not Fixes
- üìå Conclusion
- üîó Related Resources

---

## ‚ú® Executive Summary

- Vibe Coding is a conversational, intuitive style of AI development where the keyboard becomes secondary to high-level prompts and AI reasoning.
- Leveraging tools like Super Whisper, ChatGPT, and enhanced prompt templates can dramatically increase development speed and code quality.
- Building with an AI-optimized stack such as TypeScript, Next.js, and Tailwind significantly improves AI‚Äôs effectiveness.
- Creating rubrics, structured PRDs/BRDs, and markdown checklists elevates the quality and clarity of AI outputs.
- Debugging and UI iteration should focus on prompting reasoning models instead of rushing to fixes or visual tweaks.

---

## üé• Introduction to Vibe Coding

> _"You just talk to Composer with Super Whisper. You barely touch the keyboard. You ask for dumb things and it just works."_
> ‚Äî **Andrej Karpathy**, as shared by Kevin

Vibe Coding refers to a new paradigm in software development that integrates natural language prompts, intelligent assistants, and pre-optimized stacks. It promotes intuition-led, speech-to-code workflows that minimize boilerplate and accelerate high-level system design.

---

## üë®‚Äçüíª Vibe Coding Tips

---

### üß† Tip 1: Use an AI-Friendly Stack

> _"Oftentimes the biggest reason why people fail with AI tools is that they're just not using the right technologies."_

üü¶ **Recommended Stack Components:**

| Tool/Library     | Purpose                              | Reason for Use                                           |
|------------------|---------------------------------------|-----------------------------------------------------------|
| Next.js (App Router) | Frontend framework                  | File-based, type-safe, familiar to most AI models         |
| TypeScript       | Language                             | Enables type-safe prompts and strong linting feedback     |
| TRPC             | API Layer                            | Leverages Zod schemas for type safety                     |
| Prisma           | ORM                                  | Intuitive and widely supported by AI                      |
| Supabase Auth    | Authentication                       | Pre-built, reduces complexity for AI                      |
| Supabase         | Database                             | Hosted Postgres, easy to use                              |
| Tailwind CSS     | Styling                              | Inline styles understandable by AI                        |
| Framer Motion    | Animation                            | Adds interactive polish                                   |
| Resend           | Email                                | Easy integration                                          |
| AWS S3           | Storage                              | Cheap, portable, and reliable                            |

üü® **Example**: Using Tailwind allows AI to generate class-based styling without needing external files.

---

### üéôÔ∏è Tip 2: Start Outside the IDE

Use **Super Whisper** to voice-record initial planning ‚Üí convert to text ‚Üí enhance with GPT.

#### ‚¨áÔ∏è Toggle for Prompt Framework Strategy
<details>
<summary>üìã Enhanced Prompt Strategy</summary>

- Use MBA-style business frameworks like:
  - Porter's Five Forces
  - Blue Ocean Strategy
  - SWOT
- Generate:
  - BRD (Business Requirements Document)
  - PRD (Product Requirements Document)
  - Task List

**Template Link**: [Provided in original video description]

</details>

---

### üßæ Tip 3: Use an Agent Task `.md` File

> _"Create a detailed markdown checklist of one story-point tasks."_

üìò Example Format:
```markdown
- [ ] Create login form component
- [ ] Integrate API call using TRPC
- [ ] Write validation logic with Zod

---
</file>

<file path="scripts/README.md">
# Meta-Development Script

This folder contains a **meta-development script** (`dev.js`) and related utilities that manage tasks for an AI-driven or traditional software development workflow. The script revolves around a `tasks.json` file, which holds an up-to-date list of development tasks.

## Overview

In an AI-driven development process‚Äîparticularly with tools like [Cursor](https://www.cursor.so/)‚Äîit's beneficial to have a **single source of truth** for tasks. This script allows you to:

1. **Parse** a PRD or requirements document (`.txt`) to initialize a set of tasks (`tasks.json`).
2. **List** all existing tasks (IDs, statuses, titles).
3. **Update** tasks to accommodate new prompts or architecture changes (useful if you discover "implementation drift").
4. **Generate** individual task files (e.g., `task_001.txt`) for easy reference or to feed into an AI coding workflow.
5. **Set task status**‚Äîmark tasks as `done`, `pending`, or `deferred` based on progress.
6. **Expand** tasks with subtasks‚Äîbreak down complex tasks into smaller, more manageable subtasks.
7. **Research-backed subtask generation**‚Äîuse Perplexity AI to generate more informed and contextually relevant subtasks.
8. **Clear subtasks**‚Äîremove subtasks from specified tasks to allow regeneration or restructuring.
9. **Show task details**‚Äîdisplay detailed information about a specific task and its subtasks.

## Configuration

The script can be configured through environment variables in a `.env` file at the root of the project:

### Required Configuration

- `ANTHROPIC_API_KEY`: Your Anthropic API key for Claude

### Optional Configuration

- `MODEL`: Specify which Claude model to use (default: "claude-3-7-sonnet-20250219")
- `MAX_TOKENS`: Maximum tokens for model responses (default: 4000)
- `TEMPERATURE`: Temperature for model responses (default: 0.7)
- `PERPLEXITY_API_KEY`: Your Perplexity API key for research-backed subtask generation
- `PERPLEXITY_MODEL`: Specify which Perplexity model to use (default: "sonar-medium-online")
- `DEBUG`: Enable debug logging (default: false)
- `LOG_LEVEL`: Log level - debug, info, warn, error (default: info)
- `DEFAULT_SUBTASKS`: Default number of subtasks when expanding (default: 3)
- `DEFAULT_PRIORITY`: Default priority for generated tasks (default: medium)
- `PROJECT_NAME`: Override default project name in tasks.json
- `PROJECT_VERSION`: Override default version in tasks.json

## How It Works

1. **`tasks.json`**:

   - A JSON file at the project root containing an array of tasks (each with `id`, `title`, `description`, `status`, etc.).
   - The `meta` field can store additional info like the project's name, version, or reference to the PRD.
   - Tasks can have `subtasks` for more detailed implementation steps.
   - Dependencies are displayed with status indicators (‚úÖ for completed, ‚è±Ô∏è for pending) to easily track progress.

2. **CLI Commands**  
   You can run the commands via:

   ```bash
   # If installed globally
   task-master [command] [options]

   # If using locally within the project
   node scripts/dev.js [command] [options]
   ```

   Available commands:

   - `init`: Initialize a new project
   - `parse-prd`: Generate tasks from a PRD document
   - `list`: Display all tasks with their status
   - `update`: Update tasks based on new information
   - `generate`: Create individual task files
   - `set-status`: Change a task's status
   - `expand`: Add subtasks to a task or all tasks
   - `clear-subtasks`: Remove subtasks from specified tasks
   - `next`: Determine the next task to work on based on dependencies
   - `show`: Display detailed information about a specific task
   - `analyze-complexity`: Analyze task complexity and generate recommendations
   - `complexity-report`: Display the complexity analysis in a readable format
   - `add-dependency`: Add a dependency between tasks
   - `remove-dependency`: Remove a dependency from a task
   - `validate-dependencies`: Check for invalid dependencies
   - `fix-dependencies`: Fix invalid dependencies automatically
   - `add-task`: Add a new task using AI

   Run `task-master --help` or `node scripts/dev.js --help` to see detailed usage information.

## Listing Tasks

The `list` command allows you to view all tasks and their status:

```bash
# List all tasks
task-master list

# List tasks with a specific status
task-master list --status=pending

# List tasks and include their subtasks
task-master list --with-subtasks

# List tasks with a specific status and include their subtasks
task-master list --status=pending --with-subtasks
```

## Updating Tasks

The `update` command allows you to update tasks based on new information or implementation changes:

```bash
# Update tasks starting from ID 4 with a new prompt
task-master update --from=4 --prompt="Refactor tasks from ID 4 onward to use Express instead of Fastify"

# Update all tasks (default from=1)
task-master update --prompt="Add authentication to all relevant tasks"

# Specify a different tasks file
task-master update --file=custom-tasks.json --from=5 --prompt="Change database from MongoDB to PostgreSQL"
```

Notes:

- The `--prompt` parameter is required and should explain the changes or new context
- Only tasks that aren't marked as 'done' will be updated
- Tasks with ID >= the specified --from value will be updated

## Setting Task Status

The `set-status` command allows you to change a task's status:

```bash
# Mark a task as done
task-master set-status --id=3 --status=done

# Mark a task as pending
task-master set-status --id=4 --status=pending

# Mark a specific subtask as done
task-master set-status --id=3.1 --status=done

# Mark multiple tasks at once
task-master set-status --id=1,2,3 --status=done
```

Notes:

- When marking a parent task as "done", all of its subtasks will automatically be marked as "done" as well
- Common status values are 'done', 'pending', and 'deferred', but any string is accepted
- You can specify multiple task IDs by separating them with commas
- Subtask IDs are specified using the format `parentId.subtaskId` (e.g., `3.1`)
- Dependencies are updated to show completion status (‚úÖ for completed, ‚è±Ô∏è for pending) throughout the system

## Expanding Tasks

The `expand` command allows you to break down tasks into subtasks for more detailed implementation:

```bash
# Expand a specific task with 3 subtasks (default)
task-master expand --id=3

# Expand a specific task with 5 subtasks
task-master expand --id=3 --num=5

# Expand a task with additional context
task-master expand --id=3 --prompt="Focus on security aspects"

# Expand all pending tasks that don't have subtasks
task-master expand --all

# Force regeneration of subtasks for all pending tasks
task-master expand --all --force

# Use Perplexity AI for research-backed subtask generation
task-master expand --id=3 --research

# Use Perplexity AI for research-backed generation on all pending tasks
task-master expand --all --research
```

## Clearing Subtasks

The `clear-subtasks` command allows you to remove subtasks from specified tasks:

```bash
# Clear subtasks from a specific task
task-master clear-subtasks --id=3

# Clear subtasks from multiple tasks
task-master clear-subtasks --id=1,2,3

# Clear subtasks from all tasks
task-master clear-subtasks --all
```

Notes:

- After clearing subtasks, task files are automatically regenerated
- This is useful when you want to regenerate subtasks with a different approach
- Can be combined with the `expand` command to immediately generate new subtasks
- Works with both parent tasks and individual subtasks

## AI Integration

The script integrates with two AI services:

1. **Anthropic Claude**: Used for parsing PRDs, generating tasks, and creating subtasks.
2. **Perplexity AI**: Used for research-backed subtask generation when the `--research` flag is specified.

The Perplexity integration uses the OpenAI client to connect to Perplexity's API, which provides enhanced research capabilities for generating more informed subtasks. If the Perplexity API is unavailable or encounters an error, the script will automatically fall back to using Anthropic's Claude.

To use the Perplexity integration:

1. Obtain a Perplexity API key
2. Add `PERPLEXITY_API_KEY` to your `.env` file
3. Optionally specify `PERPLEXITY_MODEL` in your `.env` file (default: "sonar-medium-online")
4. Use the `--research` flag with the `expand` command

## Logging

The script supports different logging levels controlled by the `LOG_LEVEL` environment variable:

- `debug`: Detailed information, typically useful for troubleshooting
- `info`: Confirmation that things are working as expected (default)
- `warn`: Warning messages that don't prevent execution
- `error`: Error messages that might prevent execution

When `DEBUG=true` is set, debug logs are also written to a `dev-debug.log` file in the project root.

## Managing Task Dependencies

The `add-dependency` and `remove-dependency` commands allow you to manage task dependencies:

```bash
# Add a dependency to a task
task-master add-dependency --id=<id> --depends-on=<id>

# Remove a dependency from a task
task-master remove-dependency --id=<id> --depends-on=<id>
```

These commands:

1. **Allow precise dependency management**:

   - Add dependencies between tasks with automatic validation
   - Remove dependencies when they're no longer needed
   - Update task files automatically after changes

2. **Include validation checks**:

   - Prevent circular dependencies (a task depending on itself)
   - Prevent duplicate dependencies
   - Verify that both tasks exist before adding/removing dependencies
   - Check if dependencies exist before attempting to remove them

3. **Provide clear feedback**:

   - Success messages confirm when dependencies are added/removed
   - Error messages explain why operations failed (if applicable)

4. **Automatically update task files**:
   - Regenerates task files to reflect dependency changes
   - Ensures tasks and their files stay synchronized

## Dependency Validation and Fixing

The script provides two specialized commands to ensure task dependencies remain valid and properly maintained:

### Validating Dependencies

The `validate-dependencies` command allows you to check for invalid dependencies without making changes:

```bash
# Check for invalid dependencies in tasks.json
task-master validate-dependencies

# Specify a different tasks file
task-master validate-dependencies --file=custom-tasks.json
```

This command:

- Scans all tasks and subtasks for non-existent dependencies
- Identifies potential self-dependencies (tasks referencing themselves)
- Reports all found issues without modifying files
- Provides a comprehensive summary of dependency state
- Gives detailed statistics on task dependencies

Use this command to audit your task structure before applying fixes.

### Fixing Dependencies

The `fix-dependencies` command proactively finds and fixes all invalid dependencies:

```bash
# Find and fix all invalid dependencies
task-master fix-dependencies

# Specify a different tasks file
task-master fix-dependencies --file=custom-tasks.json
```

This command:

1. **Validates all dependencies** across tasks and subtasks
2. **Automatically removes**:
   - References to non-existent tasks and subtasks
   - Self-dependencies (tasks depending on themselves)
3. **Fixes issues in both**:
   - The tasks.json data structure
   - Individual task files during regeneration
4. **Provides a detailed report**:
   - Types of issues fixed (non-existent vs. self-dependencies)
   - Number of tasks affected (tasks vs. subtasks)
   - Where fixes were applied (tasks.json vs. task files)
   - List of all individual fixes made

This is especially useful when tasks have been deleted or IDs have changed, potentially breaking dependency chains.

## Analyzing Task Complexity

The `analyze-complexity` command allows you to automatically assess task complexity and generate expansion recommendations:

```bash
# Analyze all tasks and generate expansion recommendations
task-master analyze-complexity

# Specify a custom output file
task-master analyze-complexity --output=custom-report.json

# Override the model used for analysis
task-master analyze-complexity --model=claude-3-opus-20240229

# Set a custom complexity threshold (1-10)
task-master analyze-complexity --threshold=6

# Use Perplexity AI for research-backed complexity analysis
task-master analyze-complexity --research
```

Notes:

- The command uses Claude to analyze each task's complexity (or Perplexity with --research flag)
- Tasks are scored on a scale of 1-10
- Each task receives a recommended number of subtasks based on DEFAULT_SUBTASKS configuration
- The default output path is `scripts/task-complexity-report.json`
- Each task in the analysis includes a ready-to-use `expansionCommand` that can be copied directly to the terminal or executed programmatically
- Tasks with complexity scores below the threshold (default: 5) may not need expansion
- The research flag provides more contextual and informed complexity assessments

### Integration with Expand Command

The `expand` command automatically checks for and uses complexity analysis if available:

```bash
# Expand a task, using complexity report recommendations if available
task-master expand --id=8

# Expand all tasks, prioritizing by complexity score if a report exists
task-master expand --all

# Override recommendations with explicit values
task-master expand --id=8 --num=5 --prompt="Custom prompt"
```

When a complexity report exists:

- The `expand` command will use the recommended subtask count from the report (unless overridden)
- It will use the tailored expansion prompt from the report (unless a custom prompt is provided)
- When using `--all`, tasks are sorted by complexity score (highest first)
- The `--research` flag is preserved from the complexity analysis to expansion

The output report structure is:

```json
{
	"meta": {
		"generatedAt": "2023-06-15T12:34:56.789Z",
		"tasksAnalyzed": 20,
		"thresholdScore": 5,
		"projectName": "Your Project Name",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 8,
			"taskTitle": "Develop Implementation Drift Handling",
			"complexityScore": 9.5,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Create subtasks that handle detecting...",
			"reasoning": "This task requires sophisticated logic...",
			"expansionCommand": "task-master expand --id=8 --num=6 --prompt=\"Create subtasks...\" --research"
		}
		// More tasks sorted by complexity score (highest first)
	]
}
```

## Finding the Next Task

The `next` command helps you determine which task to work on next based on dependencies and status:

```bash
# Show the next task to work on
task-master next

# Specify a different tasks file
task-master next --file=custom-tasks.json
```

This command:

1. Identifies all **eligible tasks** - pending or in-progress tasks whose dependencies are all satisfied (marked as done)
2. **Prioritizes** these eligible tasks by:
   - Priority level (high > medium > low)
   - Number of dependencies (fewer dependencies first)
   - Task ID (lower ID first)
3. **Displays** comprehensive information about the selected task:
   - Basic task details (ID, title, priority, dependencies)
   - Detailed description and implementation details
   - Subtasks if they exist
4. Provides **contextual suggested actions**:
   - Command to mark the task as in-progress
   - Command to mark the task as done when completed
   - Commands for working with subtasks (update status or expand)

This feature ensures you're always working on the most appropriate task based on your project's current state and dependency structure.

## Showing Task Details

The `show` command allows you to view detailed information about a specific task:

```bash
# Show details for a specific task
task-master show 1

# Alternative syntax with --id option
task-master show --id=1

# Show details for a subtask
task-master show --id=1.2

# Specify a different tasks file
task-master show 3 --file=custom-tasks.json
```

This command:

1. **Displays comprehensive information** about the specified task:
   - Basic task details (ID, title, priority, dependencies, status)
   - Full description and implementation details
   - Test strategy information
   - Subtasks if they exist
2. **Handles both regular tasks and subtasks**:
   - For regular tasks, shows all subtasks and their status
   - For subtasks, shows the parent task relationship
3. **Provides contextual suggested actions**:
   - Commands to update the task status
   - Commands for working with subtasks
   - For subtasks, provides a link to view the parent task

This command is particularly useful when you need to examine a specific task in detail before implementing it or when you want to check the status and details of a particular task.
</file>

<file path="README-task-master.md">
# Task Master

### by [@eyaltoledano](https://x.com/eyaltoledano)

A task management system for AI-driven development with Claude, designed to work seamlessly with Cursor AI.

## Requirements

- Node.js 14.0.0 or higher
- Anthropic API key (Claude API)
- Anthropic SDK version 0.39.0 or higher
- OpenAI SDK (for Perplexity API integration, optional)

## Configuration

The script can be configured through environment variables in a `.env` file at the root of the project:

### Required Configuration

- `ANTHROPIC_API_KEY`: Your Anthropic API key for Claude

### Optional Configuration

- `MODEL`: Specify which Claude model to use (default: "claude-3-7-sonnet-20250219")
- `MAX_TOKENS`: Maximum tokens for model responses (default: 4000)
- `TEMPERATURE`: Temperature for model responses (default: 0.7)
- `PERPLEXITY_API_KEY`: Your Perplexity API key for research-backed subtask generation
- `PERPLEXITY_MODEL`: Specify which Perplexity model to use (default: "sonar-medium-online")
- `DEBUG`: Enable debug logging (default: false)
- `LOG_LEVEL`: Log level - debug, info, warn, error (default: info)
- `DEFAULT_SUBTASKS`: Default number of subtasks when expanding (default: 3)
- `DEFAULT_PRIORITY`: Default priority for generated tasks (default: medium)
- `PROJECT_NAME`: Override default project name in tasks.json
- `PROJECT_VERSION`: Override default version in tasks.json

## Installation

```bash
# Install globally
npm install -g task-master-ai

# OR install locally within your project
npm install task-master-ai
```

### Initialize a new project

```bash
# If installed globally
task-master init

# If installed locally
npx task-master-init
```

This will prompt you for project details and set up a new project with the necessary files and structure.

### Important Notes

1. **ES Modules Configuration:**

   - This project uses ES Modules (ESM) instead of CommonJS.
   - This is set via `"type": "module"` in your package.json.
   - Use `import/export` syntax instead of `require()`.
   - Files should use `.js` or `.mjs` extensions.
   - To use a CommonJS module, either:
     - Rename it with `.cjs` extension
     - Use `await import()` for dynamic imports
   - If you need CommonJS throughout your project, remove `"type": "module"` from package.json, but Task Master scripts expect ESM.

2. The Anthropic SDK version should be 0.39.0 or higher.

## Quick Start with Global Commands

After installing the package globally, you can use these CLI commands from any directory:

```bash
# Initialize a new project
task-master init

# Parse a PRD and generate tasks
task-master parse-prd your-prd.txt

# List all tasks
task-master list

# Show the next task to work on
task-master next

# Generate task files
task-master generate
```

## Troubleshooting

### If `task-master init` doesn't respond:

Try running it with Node directly:

```bash
node node_modules/claude-task-master/scripts/init.js
```

Or clone the repository and run:

```bash
git clone https://github.com/eyaltoledano/claude-task-master.git
cd claude-task-master
node scripts/init.js
```

## Task Structure

Tasks in tasks.json have the following structure:

- `id`: Unique identifier for the task (Example: `1`)
- `title`: Brief, descriptive title of the task (Example: `"Initialize Repo"`)
- `description`: Concise description of what the task involves (Example: `"Create a new repository, set up initial structure."`)
- `status`: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
- `dependencies`: IDs of tasks that must be completed before this task (Example: `[1, 2]`)
  - Dependencies are displayed with status indicators (‚úÖ for completed, ‚è±Ô∏è for pending)
  - This helps quickly identify which prerequisite tasks are blocking work
- `priority`: Importance level of the task (Example: `"high"`, `"medium"`, `"low"`)
- `details`: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`)
- `testStrategy`: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`)
- `subtasks`: List of smaller, more specific tasks that make up the main task (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`)

## Integrating with Cursor AI

Claude Task Master is designed to work seamlessly with [Cursor AI](https://www.cursor.so/), providing a structured workflow for AI-driven development.

### Setup with Cursor

1. After initializing your project, open it in Cursor
2. The `.cursor/rules/dev_workflow.mdc` file is automatically loaded by Cursor, providing the AI with knowledge about the task management system
3. Place your PRD document in the `scripts/` directory (e.g., `scripts/prd.txt`)
4. Open Cursor's AI chat and switch to Agent mode

### Setting up MCP in Cursor

To enable enhanced task management capabilities directly within Cursor using the Model Control Protocol (MCP):

1. Go to Cursor settings
2. Navigate to the MCP section
3. Click on "Add New MCP Server"
4. Configure with the following details:
   - Name: "Task Master"
   - Type: "Command"
   - Command: "npx -y task-master-mcp"
5. Save the settings

Once configured, you can interact with Task Master's task management commands directly through Cursor's interface, providing a more integrated experience.

### Initial Task Generation

In Cursor's AI chat, instruct the agent to generate tasks from your PRD:

```
Please use the task-master parse-prd command to generate tasks from my PRD. The PRD is located at scripts/prd.txt.
```

The agent will execute:

```bash
task-master parse-prd scripts/prd.txt
```

This will:

- Parse your PRD document
- Generate a structured `tasks.json` file with tasks, dependencies, priorities, and test strategies
- The agent will understand this process due to the Cursor rules

### Generate Individual Task Files

Next, ask the agent to generate individual task files:

```
Please generate individual task files from tasks.json
```

The agent will execute:

```bash
task-master generate
```

This creates individual task files in the `tasks/` directory (e.g., `task_001.txt`, `task_002.txt`), making it easier to reference specific tasks.

## AI-Driven Development Workflow

The Cursor agent is pre-configured (via the rules file) to follow this workflow:

### 1. Task Discovery and Selection

Ask the agent to list available tasks:

```
What tasks are available to work on next?
```

The agent will:

- Run `task-master list` to see all tasks
- Run `task-master next` to determine the next task to work on
- Analyze dependencies to determine which tasks are ready to be worked on
- Prioritize tasks based on priority level and ID order
- Suggest the next task(s) to implement

### 2. Task Implementation

When implementing a task, the agent will:

- Reference the task's details section for implementation specifics
- Consider dependencies on previous tasks
- Follow the project's coding standards
- Create appropriate tests based on the task's testStrategy

You can ask:

```
Let's implement task 3. What does it involve?
```

### 3. Task Verification

Before marking a task as complete, verify it according to:

- The task's specified testStrategy
- Any automated tests in the codebase
- Manual verification if required

### 4. Task Completion

When a task is completed, tell the agent:

```
Task 3 is now complete. Please update its status.
```

The agent will execute:

```bash
task-master set-status --id=3 --status=done
```

### 5. Handling Implementation Drift

If during implementation, you discover that:

- The current approach differs significantly from what was planned
- Future tasks need to be modified due to current implementation choices
- New dependencies or requirements have emerged

Tell the agent:

```
We've changed our approach. We're now using Express instead of Fastify. Please update all future tasks to reflect this change.
```

The agent will execute:

```bash
task-master update --from=4 --prompt="Now we are using Express instead of Fastify."
```

This will rewrite or re-scope subsequent tasks in tasks.json while preserving completed work.

### 6. Breaking Down Complex Tasks

For complex tasks that need more granularity:

```
Task 5 seems complex. Can you break it down into subtasks?
```

The agent will execute:

```bash
task-master expand --id=5 --num=3
```

You can provide additional context:

```
Please break down task 5 with a focus on security considerations.
```

The agent will execute:

```bash
task-master expand --id=5 --prompt="Focus on security aspects"
```

You can also expand all pending tasks:

```
Please break down all pending tasks into subtasks.
```

The agent will execute:

```bash
task-master expand --all
```

For research-backed subtask generation using Perplexity AI:

```
Please break down task 5 using research-backed generation.
```

The agent will execute:

```bash
task-master expand --id=5 --research
```

## Command Reference

Here's a comprehensive reference of all available commands:

### Parse PRD

```bash
# Parse a PRD file and generate tasks
task-master parse-prd <prd-file.txt>

# Limit the number of tasks generated
task-master parse-prd <prd-file.txt> --num-tasks=10
```

### List Tasks

```bash
# List all tasks
task-master list

# List tasks with a specific status
task-master list --status=<status>

# List tasks with subtasks
task-master list --with-subtasks

# List tasks with a specific status and include subtasks
task-master list --status=<status> --with-subtasks
```

### Show Next Task

```bash
# Show the next task to work on based on dependencies and status
task-master next
```

### Show Specific Task

```bash
# Show details of a specific task
task-master show <id>
# or
task-master show --id=<id>

# View a specific subtask (e.g., subtask 2 of task 1)
task-master show 1.2
```

### Update Tasks

```bash
# Update tasks from a specific ID and provide context
task-master update --from=<id> --prompt="<prompt>"
```

### Generate Task Files

```bash
# Generate individual task files from tasks.json
task-master generate
```

### Set Task Status

```bash
# Set status of a single task
task-master set-status --id=<id> --status=<status>

# Set status for multiple tasks
task-master set-status --id=1,2,3 --status=<status>

# Set status for subtasks
task-master set-status --id=1.1,1.2 --status=<status>
```

When marking a task as "done", all of its subtasks will automatically be marked as "done" as well.

### Expand Tasks

```bash
# Expand a specific task with subtasks
task-master expand --id=<id> --num=<number>

# Expand with additional context
task-master expand --id=<id> --prompt="<context>"

# Expand all pending tasks
task-master expand --all

# Force regeneration of subtasks for tasks that already have them
task-master expand --all --force

# Research-backed subtask generation for a specific task
task-master expand --id=<id> --research

# Research-backed generation for all tasks
task-master expand --all --research
```

### Clear Subtasks

```bash
# Clear subtasks from a specific task
task-master clear-subtasks --id=<id>

# Clear subtasks from multiple tasks
task-master clear-subtasks --id=1,2,3

# Clear subtasks from all tasks
task-master clear-subtasks --all
```

### Analyze Task Complexity

```bash
# Analyze complexity of all tasks
task-master analyze-complexity

# Save report to a custom location
task-master analyze-complexity --output=my-report.json

# Use a specific LLM model
task-master analyze-complexity --model=claude-3-opus-20240229

# Set a custom complexity threshold (1-10)
task-master analyze-complexity --threshold=6

# Use an alternative tasks file
task-master analyze-complexity --file=custom-tasks.json

# Use Perplexity AI for research-backed complexity analysis
task-master analyze-complexity --research
```

### View Complexity Report

```bash
# Display the task complexity analysis report
task-master complexity-report

# View a report at a custom location
task-master complexity-report --file=my-report.json
```

### Managing Task Dependencies

```bash
# Add a dependency to a task
task-master add-dependency --id=<id> --depends-on=<id>

# Remove a dependency from a task
task-master remove-dependency --id=<id> --depends-on=<id>

# Validate dependencies without fixing them
task-master validate-dependencies

# Find and fix invalid dependencies automatically
task-master fix-dependencies
```

### Add a New Task

```bash
# Add a new task using AI
task-master add-task --prompt="Description of the new task"

# Add a task with dependencies
task-master add-task --prompt="Description" --dependencies=1,2,3

# Add a task with priority
task-master add-task --prompt="Description" --priority=high
```

## Feature Details

### Analyzing Task Complexity

The `analyze-complexity` command:

- Analyzes each task using AI to assess its complexity on a scale of 1-10
- Recommends optimal number of subtasks based on configured DEFAULT_SUBTASKS
- Generates tailored prompts for expanding each task
- Creates a comprehensive JSON report with ready-to-use commands
- Saves the report to scripts/task-complexity-report.json by default

The generated report contains:

- Complexity analysis for each task (scored 1-10)
- Recommended number of subtasks based on complexity
- AI-generated expansion prompts customized for each task
- Ready-to-run expansion commands directly within each task analysis

### Viewing Complexity Report

The `complexity-report` command:

- Displays a formatted, easy-to-read version of the complexity analysis report
- Shows tasks organized by complexity score (highest to lowest)
- Provides complexity distribution statistics (low, medium, high)
- Highlights tasks recommended for expansion based on threshold score
- Includes ready-to-use expansion commands for each complex task
- If no report exists, offers to generate one on the spot

### Smart Task Expansion

The `expand` command automatically checks for and uses the complexity report:

When a complexity report exists:

- Tasks are automatically expanded using the recommended subtask count and prompts
- When expanding all tasks, they're processed in order of complexity (highest first)
- Research-backed generation is preserved from the complexity analysis
- You can still override recommendations with explicit command-line options

Example workflow:

```bash
# Generate the complexity analysis report with research capabilities
task-master analyze-complexity --research

# Review the report in a readable format
task-master complexity-report

# Expand tasks using the optimized recommendations
task-master expand --id=8
# or expand all tasks
task-master expand --all
```

### Finding the Next Task

The `next` command:

- Identifies tasks that are pending/in-progress and have all dependencies satisfied
- Prioritizes tasks by priority level, dependency count, and task ID
- Displays comprehensive information about the selected task:
  - Basic task details (ID, title, priority, dependencies)
  - Implementation details
  - Subtasks (if they exist)
- Provides contextual suggested actions:
  - Command to mark the task as in-progress
  - Command to mark the task as done
  - Commands for working with subtasks

### Viewing Specific Task Details

The `show` command:

- Displays comprehensive details about a specific task or subtask
- Shows task status, priority, dependencies, and detailed implementation notes
- For parent tasks, displays all subtasks and their status
- For subtasks, shows parent task relationship
- Provides contextual action suggestions based on the task's state
- Works with both regular tasks and subtasks (using the format taskId.subtaskId)

## Best Practices for AI-Driven Development

1. **Start with a detailed PRD**: The more detailed your PRD, the better the generated tasks will be.

2. **Review generated tasks**: After parsing the PRD, review the tasks to ensure they make sense and have appropriate dependencies.

3. **Analyze task complexity**: Use the complexity analysis feature to identify which tasks should be broken down further.

4. **Follow the dependency chain**: Always respect task dependencies - the Cursor agent will help with this.

5. **Update as you go**: If your implementation diverges from the plan, use the update command to keep future tasks aligned with your current approach.

6. **Break down complex tasks**: Use the expand command to break down complex tasks into manageable subtasks.

7. **Regenerate task files**: After any updates to tasks.json, regenerate the task files to keep them in sync.

8. **Communicate context to the agent**: When asking the Cursor agent to help with a task, provide context about what you're trying to achieve.

9. **Validate dependencies**: Periodically run the validate-dependencies command to check for invalid or circular dependencies.

## Example Cursor AI Interactions

### Starting a new project

```
I've just initialized a new project with Claude Task Master. I have a PRD at scripts/prd.txt.
Can you help me parse it and set up the initial tasks?
```

### Working on tasks

```
What's the next task I should work on? Please consider dependencies and priorities.
```

### Implementing a specific task

```
I'd like to implement task 4. Can you help me understand what needs to be done and how to approach it?
```

### Managing subtasks

```
I need to regenerate the subtasks for task 3 with a different approach. Can you help me clear and regenerate them?
```

### Handling changes

```
We've decided to use MongoDB instead of PostgreSQL. Can you update all future tasks to reflect this change?
```

### Completing work

```
I've finished implementing the authentication system described in task 2. All tests are passing.
Please mark it as complete and tell me what I should work on next.
```

### Analyzing complexity

```
Can you analyze the complexity of our tasks to help me understand which ones need to be broken down further?
```

### Viewing complexity report

```
Can you show me the complexity report in a more readable format?
```
</file>

<file path=".windsurf/rules/cursor-rules.md">
---
trigger: model_decision
description: when creating cursor rules
globs: 
---
---
description: How to add or edit Cursor rules in our project
globs: 
alwaysApply: false
---
# Cursor Rules Location

How to add new cursor rules to the project

1. Always place rule files in PROJECT_ROOT/.cursor/rules/:
    ```
    .cursor/rules/
    ‚îú‚îÄ‚îÄ your-rule-name.mdc
    ‚îú‚îÄ‚îÄ another-rule.mdc
    ‚îî‚îÄ‚îÄ ...
    ```

2. Follow the naming convention:
    - Use kebab-case for filenames
    - Always use .mdc extension
    - Make names descriptive of the rule's purpose

3. Directory structure:
    ```
    PROJECT_ROOT/
    ‚îú‚îÄ‚îÄ .cursor/
    ‚îÇ   ‚îî‚îÄ‚îÄ rules/
    ‚îÇ       ‚îú‚îÄ‚îÄ your-rule-name.mdc
    ‚îÇ       ‚îî‚îÄ‚îÄ ...
    ‚îî‚îÄ‚îÄ ...
    ```

4. Never place rule files:
    - In the project root
    - In subdirectories outside .cursor/rules
    - In any other location

5. Cursor rules have the following structure:

````
---
description: Short description of the rule's purpose
globs: optional/path/pattern/**/* 
alwaysApply: false
---
# Rule Title

Main content explaining the rule with markdown formatting.

1. Step-by-step instructions
2. Code examples
3. Guidelines

Example:
```typescript
// Good example
function goodExample() {
  // Implementation following guidelines
}

// Bad example
function badExample() {
  // Implementation not following guidelines
}
```
````
</file>

<file path=".windsurf/rules/data-flow.md">
---
trigger: model_decision
description: Implementing data flow architecture
globs: 
---

# Data Flow Architecture

## Core Principles

- All business logic and calculations happen on the server
- Client components handle UI state and user interactions only
- Data is pre-calculated before being sent to the client
- Maintain a clear separation between data fetching, processing, and presentation

## Service Layer

- Create data service files in `src/services/` folder that handle all business logic and calculations
- Service methods should be pure functions with clear inputs and outputs
- Group services by domain (metrics, appointments, patients, etc.)
- All complex logic belongs in the service layer, not in components or API routes

Example service structure:
```
src/services/
‚îú‚îÄ‚îÄ metrics/
‚îÇ   ‚îú‚îÄ‚îÄ calculations.ts     # Core metric calculations
‚îÇ   ‚îú‚îÄ‚îÄ transformations.ts  # Data transformations
‚îÇ   ‚îî‚îÄ‚îÄ index.ts            # Public API for the service
‚îú‚îÄ‚îÄ appointments/
‚îÇ   ‚îú‚îÄ‚îÄ scheduling.ts       # Appointment scheduling logic
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îî‚îÄ‚îÄ patients/
    ‚îú‚îÄ‚îÄ demographics.ts     # Patient demographic analysis
    ‚îî‚îÄ‚îÄ index.ts
```

## Data Fetching Patterns

### Server Components

- Server Components fetch data directly using service methods
- Pre-calculate all derived values on the server
- Pass only the necessary data to child components

Example:
```tsx
// src/app/dashboard/page.tsx
import { cookies } from 'next/headers'
import { createClient } from '@/lib/supabase/server'
import { MetricsService } from '@/services/metrics'

export default async function DashboardPage() {
  const cookieStore = cookies()
  const supabase = createClient(cookieStore)
  
  // Fetch raw data from Supabase
  const { data: metrics } = await supabase.from('metrics').select('*')
  
  // Process data in the service layer
  const processedMetrics = MetricsService.processMetrics(metrics)
  
  return (
    <DashboardLayout>
      <MetricsOverview data={processedMetrics} />
    </DashboardLayout>
  )
}
```

### API Route Handlers

- Create API routes at `src/app/api/[domain]/route.ts` for client-side data fetching
- API routes should call service methods to process data
- Return pre-calculated results to minimize client-side processing

Example:
```tsx
// src/app/api/metrics/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { cookies } from 'next/headers'
import { MetricsService } from '@/services/metrics'

export async function GET(request: NextRequest) {
  const cookieStore = cookies()
  const supabase = createClient(cookieStore)
  
  // Get query parameters
  const searchParams = request.nextUrl.searchParams
  const clinicId = searchParams.get('clinicId')
  const startDate = searchParams.get('startDate')
  
  // Fetch raw data
  const { data, error } = await supabase
    .from('metrics')
    .select('*')
    .eq('clinicId', clinicId)
  
  if (error) {
    return NextResponse.json(
      { error: 'Failed to fetch metrics' },
      { status: 500 }
    )
  }
  
  // Process in service layer
  const processedData = MetricsService.processMetrics(data, startDate)
  
  // Return pre-calculated data
  return NextResponse.json(processedData)
}
```

### Client Components

- Client Components should ONLY handle:
  - UI state (loading, error, form input values)
  - User interactions (clicks, form submissions)
  - Animations and transitions
- NEVER perform data transformations or calculations on the client

Example:
```tsx
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'

// Correct: Only handling UI state and interactions
export function DateRangePicker({ onRangeChange }) {
  const [startDate, setStartDate] = useState(new Date())
  const [endDate, setEndDate] = useState(new Date())
  
  const handleApply = () => {
    // Only passes the data to a callback, no calculations
    onRangeChange({ startDate, endDate })
  }
  
  return (
    <div>
      {/* UI components */}
      <Button onClick={handleApply}>Apply</Button>
    </div>
  )
}
```

## Server Actions

- Use Server Actions for data mutations
- Place actions in `src/actions/` directory
- Server Actions should call service methods for business logic
- Return pre-calculated results to the client

Example:
```tsx
// src/actions/appointments/schedule.ts
'use server'

import { revalidatePath } from 'next/cache'
import { createClient } from '@/lib/supabase/server'
import { cookies } from 'next/headers'
import { AppointmentService } from '@/services/appointments'

export async function scheduleAppointment(formData: FormData) {
  const cookieStore = cookies()
  const supabase = createClient(cookieStore)
  
  // Extract data from form
  const patientId = formData.get('patientId') as string
  const providerId = formData.get('providerId') as string
  const date = new Date(formData.get('date') as string)
  
  // Validate in service layer
  const validationResult = AppointmentService.validateAppointment({ patientId, providerId, date })
  if (!validationResult.valid) {
    return { error: validationResult.errors }
  }
  
  // Process in service layer
  const result = await AppointmentService.scheduleAppointment({ patientId, providerId, date })
  
  // Revalidate affected paths
  revalidatePath('/appointments')
  revalidatePath(`/patients/${patientId}`)
  
  return result
}
```

## State Management

- Use React Context sparingly and only for UI state
- Avoid storing data that requires processing in context
- Keep data flow unidirectional: server ‚Üí client

## Data Caching

- Implement caching at the service layer when appropriate
- Use Next.js built-in caching mechanisms for data fetching
- Use React Query/SWR on the client only for managing remote state (loading, error states)

This architecture ensures all calculations happen on the server, providing consistent results while minimizing client-side JavaScript execution.
</file>

<file path=".windsurf/rules/database-functions.md">
---
trigger: model_decision
description: Guidelines for writing Supabase database functions
globs: 
---
---
# Specify the following for Cursor rules
description: Guidelines for writing Supabase database functions
alwaysApply: false
---

# Database: Create functions

You're a Supabase Postgres expert in writing database functions. Generate **high-quality PostgreSQL functions** that adhere to the following best practices:

## General Guidelines

1. **Default to `SECURITY INVOKER`:**

   - Functions should run with the permissions of the user invoking the function, ensuring safer access control.
   - Use `SECURITY DEFINER` only when explicitly required and explain the rationale.

2. **Set the `search_path` Configuration Parameter:**

   - Always set `search_path` to an empty string (`set search_path = '';`).
   - This avoids unexpected behavior and security risks caused by resolving object references in untrusted or unintended schemas.
   - Use fully qualified names (e.g., `schema_name.table_name`) for all database objects referenced within the function.

3. **Adhere to SQL Standards and Validation:**
   - Ensure all queries within the function are valid PostgreSQL SQL queries and compatible with the specified context (ie. Supabase).

## Best Practices

1. **Minimize Side Effects:**

   - Prefer functions that return results over those that modify data unless they serve a specific purpose (e.g., triggers).

2. **Use Explicit Typing:**

   - Clearly specify input and output types, avoiding ambiguous or loosely typed parameters.

3. **Default to Immutable or Stable Functions:**

   - Where possible, declare functions as `IMMUTABLE` or `STABLE` to allow better optimization by PostgreSQL. Use `VOLATILE` only if the function modifies data or has side effects.

4. **Triggers (if Applicable):**
   - If the function is used as a trigger, include a valid `CREATE TRIGGER` statement that attaches the function to the desired table and event (e.g., `BEFORE INSERT`).

## Example Templates

### Simple Function with `SECURITY INVOKER`

```sql
create or replace function my_schema.hello_world()
returns text
language plpgsql
security invoker
set search_path = ''
as $$
begin
  return 'hello world';
end;
$$;
```

### Function with Parameters and Fully Qualified Object Names

```sql
create or replace function public.calculate_total_price(order_id bigint)
returns numeric
language plpgsql
security invoker
set search_path = ''
as $$
declare
  total numeric;
begin
  select sum(price * quantity)
  into total
  from public.order_items
  where order_id = calculate_total_price.order_id;

  return total;
end;
$$;
```

### Function as a Trigger

```sql
create or replace function my_schema.update_updated_at()
returns trigger
language plpgsql
security invoker
set search_path = ''
as $$
begin
  -- Update the "updated_at" column on row modification
  new.updated_at := now();
  return new;
end;
$$;

create trigger update_updated_at_trigger
before update on my_schema.my_table
for each row
execute function my_schema.update_updated_at();
```

### Function with Error Handling

```sql
create or replace function my_schema.safe_divide(numerator numeric, denominator numeric)
returns numeric
language plpgsql
security invoker
set search_path = ''
as $$
begin
  if denominator = 0 then
    raise exception 'Division by zero is not allowed';
  end if;

  return numerator / denominator;
end;
$$;
```

### Immutable Function for Better Optimization

```sql
create or replace function my_schema.full_name(first_name text, last_name text)
returns text
language sql
security invoker
set search_path = ''
immutable
as $$
  select first_name || ' ' || last_name;
$$;
```
</file>

<file path=".windsurf/rules/get-api-route.md">
---
trigger: model_decision
description: Guidelines for implementing GET API routes in Next.js
globs: 
---
---
description: Guidelines for implementing GET API routes in Next.js
globs: 
alwaysApply: false
---
# GET API Route Guidelines

Guidelines for implementing GET API routes in Next.js App Router:

Basic Structure. Note how we auto generate the response type for use on the client:

```typescript
import { NextResponse } from "next/server";
import prisma from "@/utils/prisma";
import { withAuth } from "@/utils/middleware";

export type GetExampleResponse = Awaited<ReturnType<typeof getData>>;

export const GET = withAuth(async () => {
  const emailAccountId = request.auth.emailAccountId;
  

  const result = getData({ email });
  return NextResponse.json(result);
});

async function getData({ email }: { email: string }) {
  const items = await prisma.example.findMany({
    where: { email },
  });

  return { items };
}
```

See [data-fetching.mdc](mdc:.cursor/rules/data-flow.mdc) as to how this would be then used on the client.

Key Requirements:

   - Always wrap the handler with `withAuth` for consistent error handling and authentication.
   - We don't need try/catch as `withAuth` handles that.
   - Infer and export response type.
   - Use Prisma for database queries.
   - Return responses using `NextResponse.json()`
</file>

<file path=".windsurf/rules/installing-packages.md">
---
trigger: model_decision
description: How to install packages
globs: 
---
---
description: How to install packages
globs: 
alwaysApply: false
---
- Use `pnpm`.

```sh
pnpm add ...
```
</file>

<file path=".windsurf/rules/naming-conventions.md">
---
trigger: model_decision
description: Naming conventions for the project
globs: 
---
## File Naming and Organization
- Use kebab case for route directories (e.g., `api/hello-world/route`)
- Use PascalCase for components (e.g. `components/Button.tsx`)

## New Pages

- Create new pages at: src/app/PAGE_NAME/page.tsx
- Use import aliases to reference components from the global components directory
- Keep page files lean, focused on layout and component composition
- All components should be organized in the global component directories by type:

- components/ui/ for shadcn components
- components/charts/ for chart components
- components/dashboards/ for dashboard-specific components
- components/[category]/ for other component types


## Pages are Server Components for direct data loading
- All data fetching and calculations MUST happen on the server side
- Create dedicated data-fetching functions in src/lib/data/ that return pre-calculated data
- For real-time updates, use Supabase Realtime subscriptions with server-calculated data
- Components with interactive elements (onClick, etc.) must be Client Components with use client directive
- Server Actions must start with use server directive and handle all data mutations and calculations

## Utility Functions

- Create utility functions in utils/ folder for reusable logic
- Server-side utility functions should be in utils/server/ to clearly separate them
- Use lodash utilities for common operations (arrays, objects, strings)
- Import specific lodash functions to minimize bundle size:
```ts
import groupBy from "lodash/groupBy";
```
</file>

<file path=".windsurf/rules/prisma.md">
---
trigger: model_decision
description: Prisma usage guidelines for data access
globs: 
---

# Prisma Usage

## Data Access Policy

- **Prisma is our exclusive data access method** for all database operations
- Supabase Data API (PostgREST) has been disabled in the project settings
- Direct SQL queries should be avoided unless absolutely necessary
- All database interactions must go through service layers that use Prisma

## Basic Usage

We use Supabase PostgreSQL as our database provider.

Import Prisma in the project:

```typescript
import prisma from "@/utils/prisma";
```

The Prisma schema is located at: `dental-dashboard/prisma/schema.prisma`.

## Best Practices

- Use Prisma's type-safe queries to ensure data integrity
- Implement complex database operations in service files under `src/services/`
- Always handle potential errors from Prisma queries
- Use transactions for operations that modify multiple records
- Keep schema migrations in version control

## Examples

### Reading Data with Relations
```typescript
// In a service file
export async function getClinicWithProviders(id: string) {
  return prisma.clinic.findUnique({
    where: { id },
    include: {
      providers: {
        include: {
          // Nested relation - providers with their appointments
          appointments: {
            where: {
              date: { gte: new Date() } // Only future appointments
            },
            orderBy: { date: 'asc' }
          }
        }
      }
    }
  });
}
```

### Filtering Relations
```typescript
    // In a service file
export async function getActiveProviders(clinicId: string) {
  return prisma.provider.findMany({
    where: {
      clinicId,
      status: 'ACTIVE',
      // Find providers who have at least one upcoming appointment
      appointments: {
        some: {
          date: { gte: new Date() }
        }
      }
    },
    select: {
      id: true,
      name: true,
      type: true,
      // Include counts directly in the query
      _count: {
        select: { appointments: true }
      }
    }
  });
}
```

### Transactions
```typescript
// For operations that should succeed or fail together
export async function transferPatient(patientId: string, fromProviderId: string, toProviderId: string) {
  return prisma.$transaction(async (tx) => {
    // Get the current patient data
    const patient = await tx.patient.findUnique({
      where: { id: patientId },
      include: { appointments: true }
    });
    
    if (!patient) {
      throw new Error('Patient not found');
    }
    
    // Update patient's provider
    await tx.patient.update({
      where: { id: patientId },
      data: { providerId: toProviderId }
    });
    
    // Update appointment assignments
    await tx.appointment.updateMany({
      where: { 
        patientId,
        providerId: fromProviderId,
        status: 'SCHEDULED'
      },
      data: { providerId: toProviderId }
    });
    
    // Create a record of the transfer
    await tx.patientTransferLog.create({
      data: {
        patientId,
        fromProviderId,
        toProviderId,
        transferredAt: new Date()
      }
    });
  });
}
```

By following these guidelines, we ensure consistent data access patterns and maintain our server-first architecture.
</file>

<file path=".windsurf/rules/project-structure.md">
---
trigger: model_decision
description: Project structure and file organization guidelines
globs: 
---
 Project Structure

## Main Structure

- We use Turborepo with pnpm workspaces
- Main app is in `src/app`
- Packages are in the `root` folder
- Server actions are in `apps/web/utils/actions` folder

```tree
dental-dashboard/
‚îú‚îÄ‚îÄ .npmrc                  # pnpm configuration (strict-peer-dependencies=true)
‚îú‚îÄ‚îÄ pnpm-lock.yaml          # pnpm lockfile (must be committed)
‚îú‚îÄ‚îÄ pnpm-workspace.yaml     # Workspace configuration
‚îú‚îÄ‚îÄ package.json            # Root package configuration
‚îú‚îÄ‚îÄ .env                    # Environment variables (includes NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY)
‚îú‚îÄ‚îÄ .env.example            # Example environment variables
‚îú‚îÄ‚îÄ .eslintrc.js            # ESLint configuration
‚îú‚îÄ‚îÄ next.config.js          # Next.js configuration
‚îú‚îÄ‚îÄ middleware.ts           # Supabase auth session middleware
‚îú‚îÄ‚îÄ prisma/                 # Prisma database schemas and migrations
‚îÇ   ‚îú‚îÄ‚îÄ schema.prisma       # Prisma schema definition
‚îÇ   ‚îî‚îÄ‚îÄ migrations/         # Database migrations
‚îú‚îÄ‚îÄ supabase/               # Supabase specific configuration
‚îÇ   ‚îú‚îÄ‚îÄ schema/             # SQL schema definitions for Supabase
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.sql        # Auth related schema
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ storage.sql     # Storage related schema
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rls.sql         # Row Level Security policies
‚îÇ   ‚îú‚îÄ‚îÄ functions/          # Edge functions
‚îÇ   ‚îú‚îÄ‚îÄ migrations/         # Supabase migrations
‚îÇ   ‚îî‚îÄ‚îÄ seed-data/          # Seed data for development
‚îú‚îÄ‚îÄ public/                 # Static assets
‚îú‚îÄ‚îÄ src/                    # Application source code
‚îÇ   ‚îú‚îÄ‚îÄ app/                # Next.js app directory (App Router)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/            # API routes
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/       # Authentication routes
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ callback/route.ts  # Auth callback handler
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ clinics/    # Clinic-related endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboards/ # Dashboard configuration endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ google/     # Google Sheets integration endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ KPIs/       # Metrics and KPI endpoints
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users/      # User management endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/           # Authentication-related pages
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signin/     # Sign in page
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signup/     # Sign up page
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ callback/route.ts # Auth callback handler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ (dashboard)/    # Dashboard pages (protected routes)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx    # Main dashboard page
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx  # Dashboard layout
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ clinics/    # Clinic-specific views
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ providers/  # Provider-specific views
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ metrics/    # Metrics detail pages
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings/   # Dashboard settings
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ google/         # Google integration pages
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connect/    # Connection setup
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mapping/    # Column mapping interface
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ layout.tsx      # Root layout
‚îÇ   ‚îú‚îÄ‚îÄ components/         # Reusable components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/             # shadcn/ui components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ charts/         # Chart components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboards/     # Dashboard-specific components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ forms/          # Form components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout/         # Layout components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/           # Authentication components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ metrics/        # Metric-specific components
‚îÇ   ‚îú‚îÄ‚îÄ lib/                # Domain-specific libraries and clients
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/            # API client configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db/             # Database connection and helpers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ google/         # Google API integration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ supabase/       # Supabase client configuration
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ client.ts   # Browser client
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ server.ts   # Server client
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ middleware.ts # Middleware client
‚îÇ   ‚îú‚îÄ‚îÄ repositories/       # Data querying and caching
‚îÇ   ‚îú‚îÄ‚îÄ utils/              # Pure utility functions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ date/           # Date formatting and manipulation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ string/         # String operations and formatting
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ number/         # Number formatting and calculations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ format/         # General formatting utilities
‚îÇ   ‚îú‚îÄ‚îÄ actions/            # Server actions (Next.js)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/           # Authentication actions (moved from lib)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ clinics/        # Clinic-related mutations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ metrics/        # Metrics-related mutations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users/          # User-related mutations
‚îÇ   ‚îú‚îÄ‚îÄ hooks/              # Custom React hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useSupabase.ts  # Supabase client hook
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAuth.ts      # Authentication hook
‚îÇ   ‚îú‚îÄ‚îÄ types/              # TypeScript type definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ supabase.ts     # Supabase generated types
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database.ts     # Database types
‚îÇ   ‚îú‚îÄ‚îÄ services/           # Business logic services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ calculations/   # Complex calculations and transformations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ clinics/        # Clinic-related services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ google/         # Google integration services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ KPIs/           # Dedicated metrics service that centralizes all KPI calculations
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users/          # User-related services
‚îÇ   ‚îî‚îÄ‚îÄ styles/             # Global and modular styles
‚îÇ       ‚îú‚îÄ‚îÄ globals.css     # Global CSS
‚îÇ       ‚îú‚îÄ‚îÄ themes/         # Theme configurations
‚îÇ       ‚îî‚îÄ‚îÄ components/     # Component-specific styles
‚îú‚îÄ‚îÄ tests/                  # Test files
‚îÇ   ‚îú‚îÄ‚îÄ unit/               # Unit tests
‚îÇ   ‚îú‚îÄ‚îÄ integration/        # Integration tests
‚îÇ   ‚îî‚îÄ‚îÄ e2e/                # End-to-end tests
‚îú‚îÄ‚îÄ turbo.json               # Turborepo pipeline configuration (build, dev, lint, test scripts)
‚îî‚îÄ‚îÄ README.md               # Project documentation

## Key Directory Organization
### Libraries and Utils

- src/lib/: Domain-specific libraries and API clients. Houses core integrations (Supabase, Google, etc.)
- src/utils/: Pure utility functions organized by type (date, string, number, format). No side effects or app state.
- src/actions/: All server-side mutations using Next.js server actions, organized by domain (auth, clinics, etc.)

### Styles and UI

- src/styles/: All styling concerns including global CSS, themes, and component styles
- src/components/: Reusable React components, organized by domain and function

### Business Logic

- src/services/: Core business logic and data transformation services
- src/hooks/: React hooks for state management and shared behaviors

### Configuration

- turbo.json: Turborepo pipeline configuration for build, test, and development tasks

### File Naming Conventions

- React Components: PascalCase (e.g., MetricsCard.tsx)
- Utility Functions: camelCase (e.g., formatDate.ts)
- Pages & Layouts: lowercase (e.g., page.tsx, layout.tsx)
- Route Handlers: lowercase (e.g., route.ts)
- Test Files: Same name as the file being tested with .test.ts suffix

### Import Conventions

- Always use absolute imports with @/ prefix
- Group imports in the following order:

- React and Next.js imports
- Third-party library imports
- Local absolute imports (components, utils, etc.)
- Local relative imports
- Type imports



### Example:

```tsx
tsximport { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { format } from 'date-fns'
import { Card } from '@/components/ui/card'
import { formatCurrency } from '@/utils/format/currency'
import { MetricsService } from '@/services/metrics'
import styles from './styles.module.css'
import type { Metric } from '@/types/metrics'
This structure follows Next.js App Router conventions while implementing clean code architecture with proper separation of concerns.
</file>

<file path=".windsurf/rules/rls-policies.md">
---
trigger: model_decision
description: Guidelines for writing Postgres Row Level Security policies
globs: 
---
---
# Specify the following for Cursor rules
description: Guidelines for writing Postgres Row Level Security policies
alwaysApply: false
---

# Database: Create RLS policies

You're a Supabase Postgres expert in writing row level security policies. Your purpose is to generate a policy with the constraints given by the user. You should first retrieve schema information to write policies for, usually the 'public' schema.

The output should use the following instructions:

- The generated SQL must be valid SQL.
- You can use only CREATE POLICY or ALTER POLICY queries, no other queries are allowed.
- Always use double apostrophe in SQL strings (eg. 'Night''s watch')
- You can add short explanations to your messages.
- The result should be a valid markdown. The SQL code should be wrapped in ``` (including sql language tag).
- Always use "auth.uid()" instead of "current_user".
- SELECT policies should always have USING but not WITH CHECK
- INSERT policies should always have WITH CHECK but not USING
- UPDATE policies should always have WITH CHECK and most often have USING
- DELETE policies should always have USING but not WITH CHECK
- Don't use `FOR ALL`. Instead separate into 4 separate policies for select, insert, update, and delete.
- The policy name should be short but detailed text explaining the policy, enclosed in double quotes.
- Always put explanations as separate text. Never use inline SQL comments.
- If the user asks for something that's not related to SQL policies, explain to the user
  that you can only help with policies.
- Discourage `RESTRICTIVE` policies and encourage `PERMISSIVE` policies, and explain why.

The output should look like this:

```sql
CREATE POLICY "My descriptive policy." ON books FOR INSERT to authenticated USING ( (select auth.uid()) = author_id ) WITH ( true );
```

Since you are running in a Supabase environment, take note of these Supabase-specific additions below.

## Authenticated and unauthenticated roles

Supabase maps every request to one of the roles:

- `anon`: an unauthenticated request (the user is not logged in)
- `authenticated`: an authenticated request (the user is logged in)

These are actually [Postgres Roles](/docs/guides/database/postgres/roles). You can use these roles within your Policies using the `TO` clause:

```sql
create policy "Profiles are viewable by everyone"
on profiles
for select
to authenticated, anon
using ( true );

-- OR

create policy "Public profiles are viewable only by authenticated users"
on profiles
for select
to authenticated
using ( true );
```

Note that `for ...` must be added after the table but before the roles. `to ...` must be added after `for ...`:

### Incorrect

```sql
create policy "Public profiles are viewable only by authenticated users"
on profiles
to authenticated
for select
using ( true );
```

### Correct

```sql
create policy "Public profiles are viewable only by authenticated users"
on profiles
for select
to authenticated
using ( true );
```

## Multiple operations

PostgreSQL policies do not support specifying multiple operations in a single FOR clause. You need to create separate policies for each operation.

### Incorrect

```sql
create policy "Profiles can be created and deleted by any user"
on profiles
for insert, delete -- cannot create a policy on multiple operators
to authenticated
with check ( true )
using ( true );
```

### Correct

```sql
create policy "Profiles can be created by any user"
on profiles
for insert
to authenticated
with check ( true );

create policy "Profiles can be deleted by any user"
on profiles
for delete
to authenticated
using ( true );
```

## Helper functions

Supabase provides some helper functions that make it easier to write Policies.

### `auth.uid()`

Returns the ID of the user making the request.

### `auth.jwt()`

Returns the JWT of the user making the request. Anything that you store in the user's `raw_app_meta_data` column or the `raw_user_meta_data` column will be accessible using this function. It's important to know the distinction between these two:

- `raw_user_meta_data` - can be updated by the authenticated user using the `supabase.auth.update()` function. It is not a good place to store authorization data.
- `raw_app_meta_data` - cannot be updated by the user, so it's a good place to store authorization data.

The `auth.jwt()` function is extremely versatile. For example, if you store some team data inside `app_metadata`, you can use it to determine whether a particular user belongs to a team. For example, if this was an array of IDs:

```sql
create policy "User is in team"
on my_table
to authenticated
using ( team_id in (select auth.jwt() -> 'app_metadata' -> 'teams'));
```

### MFA

The `auth.jwt()` function can be used to check for [Multi-Factor Authentication](/docs/guides/auth/auth-mfa#enforce-rules-for-mfa-logins). For example, you could restrict a user from updating their profile unless they have at least 2 levels of authentication (Assurance Level 2):

```sql
create policy "Restrict updates."
on profiles
as restrictive
for update
to authenticated using (
  (select auth.jwt()->>'aal') = 'aal2'
);
```

## RLS performance recommendations

Every authorization system has an impact on performance. While row level security is powerful, the performance impact is important to keep in mind. This is especially true for queries that scan every row in a table - like many `select` operations, including those using limit, offset, and ordering.

Based on a series of [tests](https://github.com/GaryAustin1/RLS-Performance), we have a few recommendations for RLS:

### Add indexes

Make sure you've added [indexes](/docs/guides/database/postgres/indexes) on any columns used within the Policies which are not already indexed (or primary keys). For a Policy like this:

```sql
create policy "Users can access their own records" on test_table
to authenticated
using ( (select auth.uid()) = user_id );
```

You can add an index like:

```sql
create index userid
on test_table
using btree (user_id);
```

### Call functions with `select`

You can use `select` statement to improve policies that use functions. For example, instead of this:

```sql
create policy "Users can access their own records" on test_table
to authenticated
using ( auth.uid() = user_id );
```

You can do:

```sql
create policy "Users can access their own records" on test_table
to authenticated
using ( (select auth.uid()) = user_id );
```

This method works well for JWT functions like `auth.uid()` and `auth.jwt()` as well as `security definer` Functions. Wrapping the function causes an `initPlan` to be run by the Postgres optimizer, which allows it to "cache" the results per-statement, rather than calling the function on each row.

Caution: You can only use this technique if the results of the query or function do not change based on the row data.

### Minimize joins

You can often rewrite your Policies to avoid joins between the source and the target table. Instead, try to organize your policy to fetch all the relevant data from the target table into an array or set, then you can use an `IN` or `ANY` operation in your filter.

For example, this is an example of a slow policy which joins the source `test_table` to the target `team_user`:

```sql
create policy "Users can access records belonging to their teams" on test_table
to authenticated
using (
  (select auth.uid()) in (
    select user_id
    from team_user
    where team_user.team_id = team_id -- joins to the source "test_table.team_id"
  )
);
```

We can rewrite this to avoid this join, and instead select the filter criteria into a set:

```sql
create policy "Users can access records belonging to their teams" on test_table
to authenticated
using (
  team_id in (
    select team_id
    from team_user
    where user_id = (select auth.uid()) -- no join
  )
);
```

### Specify roles in your policies

Always use the Role of inside your policies, specified by the `TO` operator. For example, instead of this query:

```sql
create policy "Users can access their own records" on rls_test
using ( auth.uid() = user_id );
```

Use:

```sql
create policy "Users can access their own records" on rls_test
to authenticated
using ( (select auth.uid()) = user_id );
```

This prevents the policy `( (select auth.uid()) = user_id )` from running for any `anon` users, since the execution stops at the `to authenticated` step.
</file>

<file path=".windsurf/rules/server-components.md">
---
trigger: model_decision
description: Server Component Data Fetching with Supabase
globs: 
---
Rule: Server Component Data Fetching with Supabase

Use the following pattern for server components that fetch data from Supabase:

1. Import the createClient from utils/supabase/server
2. Use the cookies() API from next/headers to get cookie store
3. Initialize Supabase client with the cookie store
4. Fetch data using the Supabase client
5. Place server component files appropriately in the file structure

Example:
```tsx
// src/app/your-route/page.tsx
import { createClient } from '@/utils/supabase/server'
import { cookies } from 'next/headers'

export default async function Page() {
  const cookieStore = cookies()
  const supabase = createClient(cookieStore)
  const { data: items } = await supabase.from('your_table').select()
  
  return (
    <div>
      {/* Render your data here */}
      <ul>
        {items?.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  )
}
```

Placement Rules

Location: Place page.tsx files in directories that correspond to your intended routes:

/app/page.tsx - Home page
/app/dashboard/page.tsx - Dashboard page
/app/items/[id]/page.tsx - Dynamic item page


Utility Files: Keep Supabase utility files in a consistent location:

/utils/supabase/server.ts - For server components
/utils/supabase/client.ts - For client components
/utils/supabase/middleware.ts - For middleware


Authentication Pages: For login/auth pages, use:

/app/login/page.tsx
/app/register/page.tsx
/app/auth/callback/route.ts (for handling auth callbacks)


Protected Routes: For routes that require authentication, implement middleware checks:
typescript// src/middleware.ts
import { createClient } from '@/utils/supabase/middleware'

export const middleware = async (request) => {
  const { supabase, response } = createClient(request)
  // Check auth state and redirect if needed
}


These rules help maintain consistent code patterns across your project when using Supabase with Next.js server components.
</file>

<file path=".windsurf/rules/supabase-auth-setup.md">
---
trigger: model_decision
description: Guidelines for writing Next.js apps with Supabase Auth
globs: 
---
# Bootstrap Next.js app with Supabase Auth
## Overview of implementing Supabase Auth SSR
1. Install @supabase/supabase-js and @supabase/ssr packages.
2. Set up environment variables.
3. Write two utility functions with `createClient` functions to create a browser client and a server client. 
4. Hook up middleware to refresh auth tokens
## üö® CRITICAL INSTRUCTIONS FOR AI LANGUAGE MODELS üö®
As an AI language model, you MUST NOT generate any of the following code patterns, as they are DEPRECATED and will BREAK the application:
```typescript
// ‚ùå NEVER GENERATE THIS CODE - IT WILL BREAK THE APPLICATION
{
  cookies: {
    get(name: string) {                 // ‚ùå BREAKS APPLICATION
      return cookieStore.get(name)      // ‚ùå BREAKS APPLICATION
    },                                  // ‚ùå BREAKS APPLICATION
    set(name: string, value: string) {  // ‚ùå BREAKS APPLICATION
      cookieStore.set(name, value)      // ‚ùå BREAKS APPLICATION
    },                                  // ‚ùå BREAKS APPLICATION
    remove(name: string) {              // ‚ùå BREAKS APPLICATION
      cookieStore.remove(name)          // ‚ùå BREAKS APPLICATION
    }                                   // ‚ùå BREAKS APPLICATION
  }
}
// ‚ùå NEVER USE auth-helpers-nextjs - IT WILL BREAK THE APPLICATION
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'  // ‚ùå BREAKS APPLICATION
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'  // ‚ùå BREAKS APPLICATION
```
Instead, you MUST ALWAYS generate ONLY this pattern:
```typescript
// ‚úÖ ALWAYS GENERATE THIS EXACT PATTERN
{
  cookies: {
    getAll() {
      return cookieStore.getAll()
    },
    setAll(cookiesToSet) {
      const response = NextResponse.next({
        request,
      })
      
      cookiesToSet.forEach(({ name, value, options }) => {
        response.cookies.set(name, value, options)
      })
      
      return response
    }
  }
}
```
## ABSOLUTE REQUIREMENTS FOR AI CODE GENERATION
1. You MUST use `@supabase/ssr`
2. You MUST use ONLY `getAll` and `setAll`
3. You MUST NEVER use `get`, `set`, or `remove`
4. You MUST NEVER import from `@supabase/auth-helpers-nextjs`
## CORRECT BROWSER CLIENT IMPLEMENTATION
```typescript
import { createBrowserClient } from '@supabase/ssr'
export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```
## CORRECT SERVER CLIENT IMPLEMENTATION
```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
export async function createClient() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
```
## CORRECT MIDDLEWARE IMPLEMENTATION
```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'
export async function middleware(request: NextRequest) {
    let supabaseResponse = NextResponse.next({
    request,
  })
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )
  // Do not run code between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.
  // IMPORTANT: DO NOT REMOVE auth.getUser()
  const {
    data: { user },
  } = await supabase.auth.getUser()
  if (
    !user &&
    !request.nextUrl.pathname.startsWith('/login') &&
    !request.nextUrl.pathname.startsWith('/auth')
  ) {
    // no user, potentially respond by redirecting the user to the login page
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }
  // IMPORTANT: You *must* return the supabaseResponse object as it is.
  // If you're creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!
  return supabaseResponse
}
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```
## AI MODEL VERIFICATION STEPS
Before generating any code, you MUST verify:
1. Are you using ONLY `getAll` and `setAll`? If not, STOP and FIX.
2. Are you importing from `@supabase/ssr`? If not, STOP and FIX.
3. Do you see ANY instance of `get`, `set`, or `remove`? If yes, STOP and FIX.
4. Are you importing from `auth-helpers-nextjs`? If yes, STOP and FIX.
## CONSEQUENCES OF INCORRECT IMPLEMENTATION
If you generate code using:
- Individual cookie methods (`get`/`set`/`remove`)
- `auth-helpers-nextjs` package
The implementation will:
1. Break in production
2. Fail to maintain session state
3. Cause authentication loops
4. Result in security vulnerabilities
## AI MODEL RESPONSE TEMPLATE
When asked about Supabase Auth SSR implementation, you MUST:
1. ONLY use code from this guide
2. NEVER suggest deprecated approaches
3. ALWAYS use the exact cookie handling shown above
4. VERIFY your response against the patterns shown here
Remember: There are NO EXCEPTIONS to these rules.
</file>

<file path=".windsurf/rules/supabase-edge-functions.md">
---
trigger: model_decision
description: Coding rules for Supabase Edge Functions
globs: 
---
---
# Specify the following for Cursor rules
description: Coding rules for Supabase Edge Functions
alwaysApply: false
---

# Writing Supabase Edge Functions

You're an expert in writing TypeScript and Deno JavaScript runtime. Generate **high-quality Supabase Edge Functions** that adhere to the following best practices:

## Guidelines

1. Try to use Web APIs and Deno‚Äôs core APIs instead of external dependencies (eg: use fetch instead of Axios, use WebSockets API instead of node-ws)
2. If you are reusing utility methods between Edge Functions, add them to `supabase/functions/_shared` and import using a relative path. Do NOT have cross dependencies between Edge Functions.
3. Do NOT use bare specifiers when importing dependecnies. If you need to use an external dependency, make sure it's prefixed with either `npm:` or `jsr:`. For example, `@supabase/supabase-js` should be written as `npm:@supabase/supabase-js`.
4. For external imports, always define a version. For example, `npm:@express` should be written as `npm:express@4.18.2`.
5. For external dependencies, importing via `npm:` and `jsr:` is preferred. Minimize the use of imports from @`deno.land/x` , `esm.sh` and @`unpkg.com` . If you have a package from one of those CDNs, you can replace the CDN hostname with `npm:` specifier.
6. You can also use Node built-in APIs. You will need to import them using `node:` specifier. For example, to import Node process: `import process from "node:process". Use Node APIs when you find gaps in Deno APIs.
7. Do NOT use `import { serve } from "https://deno.land/std@0.168.0/http/server.ts"`. Instead use the built-in `Deno.serve`.
8. Following environment variables (ie. secrets) are pre-populated in both local and hosted Supabase environments. Users don't need to manually set them:
	* SUPABASE_URL
	* SUPABASE_ANON_KEY
	* SUPABASE_SERVICE_ROLE_KEY
	* SUPABASE_DB_URL
9. To set other environment variables (ie. secrets) users can put them in a env file and run the `supabase secrets set --env-file path/to/env-file`
10. A single Edge Function can handle multiple routes. It is recommended to use a library like Express or Hono to handle the routes as it's easier for developer to understand and maintain. Each route must be prefixed with `/function-name` so they are routed correctly.
11. File write operations are ONLY permitted on `/tmp` directory. You can use either Deno or Node File APIs.
12. Use `EdgeRuntime.waitUntil(promise)` static method to run long-running tasks in the background without blocking response to a request. Do NOT assume it is available in the request / execution context.

## Example Templates

### Simple Hello World Function

```tsx
interface reqPayload {
	name: string;
}

console.info('server started');

Deno.serve(async (req: Request) => {
	const { name }: reqPayload = await req.json();
	const data = {
		message: `Hello ${name} from foo!`,
	};

	return new Response(
		JSON.stringify(data),
		{ headers: { 'Content-Type': 'application/json', 'Connection': 'keep-alive' }}
		);
});

```

### Example Function using Node built-in API

```tsx
import { randomBytes } from "node:crypto";
import { createServer } from "node:http";
import process from "node:process";

const generateRandomString = (length) => {
    const buffer = randomBytes(length);
    return buffer.toString('hex');
};

const randomString = generateRandomString(10);
console.log(randomString);

const server = createServer((req, res) => {
    const message = `Hello`;
    res.end(message);
});

server.listen(9999);
```

### Using npm packages in Functions

```tsx
import express from "npm:express@4.18.2";

const app = express();

app.get(/(.*)/, (req, res) => {
    res.send("Welcome to Supabase");
});

app.listen(8000);

```

### Generate embeddings using built-in @Supabase.ai API

```tsx
const model = new Supabase.ai.Session('gte-small');

Deno.serve(async (req: Request) => {
	const params = new URL(req.url).searchParams;
	const input = params.get('text');
	const output = await model.run(input, { mean_pool: true, normalize: true });
	return new Response(
		JSON.stringify(
			output,
		),
		{
			headers: {
				'Content-Type': 'application/json',
				'Connection': 'keep-alive',
			},
		},
	);
});

```
</file>

<file path=".windsurf/rules/testing.md">
---
trigger: model_decision
description: Guidlines for testing the application with Vitest
globs: 
---
---
description: Guidelines for testing the application with Vitest
globs: 
alwaysApply: false
---

# Testing Guidelines

## Testing Framework and Structure

- We use `vitest` as our primary testing framework
- Tests are colocated next to the tested file for easy discovery and maintenance
  - Example: `services/metrics/calculations.ts` and `services/metrics/calculations.test.ts`
- Exception: AI-related tests are placed in the `__tests__` directory and excluded from standard test runs since they use real LLM calls
- Test files should follow the pattern `*.test.ts` or `*.test.tsx` for component tests

## Types of Tests

### Unit Tests
- Focus on testing pure functions and service layer logic
- Test business logic and calculations thoroughly
- Mock all external dependencies, API calls, and database interactions

### Component Tests
- Test React components in isolation
- For client components, focus on user interactions and state changes
- For server components, test the rendered output based on provided props
- Use React Testing Library for component tests

### Integration Tests
- Test the interaction between multiple services and components
- Minimize the use of mocks for these tests to ensure actual compatibility
- Focus on critical user flows and business processes

## Common Mocks

### Server-Only Mock
```ts
vi.mock("server-only", () => ({}));
```

### Prisma Mock
```ts
import { beforeEach } from "vitest";
import prisma from "@/utils/__mocks__/prisma";
vi.mock("@/utils/prisma");

describe("MetricsService", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });
  
  it("should calculate the monthly production total", async () => {
    // Setup mock data
    prisma.metrics.findMany.mockResolvedValue([
      { date: "2023-01-01", production: 1000 },
      { date: "2023-01-15", production: 1500 }
    ]);
    
    // Test the service
    const result = await MetricsService.calculateMonthlyProduction("2023-01");
    
    // Assertions
    expect(result).toBe(2500);
    expect(prisma.metrics.findMany).toHaveBeenCalledTimes(1);
  });
});
```

### Supabase Mock
```ts
import { vi } from "vitest";

vi.mock("@/lib/supabase/server", () => ({
  createClient: () => ({
    from: () => ({
      select: () => ({
        eq: () => ({
          data: [{ id: 1, name: "Test Clinic" }],
          error: null
        })
      })
    }),
    auth: {
      getUser: () => ({ data: { user: { id: "test-user-id" } } })
    }
  })
}));
```

## Testing Service Layer

- Service layer tests should be comprehensive as they contain critical business logic
- Ensure all edge cases and error conditions are tested
- Mock database calls and external APIs
- Example:

```ts
// src/services/clinics/clinics.test.ts
import { describe, it, expect, beforeEach, vi } from "vitest";
import prisma from "@/utils/__mocks__/prisma";
import { ClinicService } from "./clinics";

vi.mock("@/utils/prisma");

describe("ClinicService", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("should return clinics for a user", async () => {
    prisma.clinic.findMany.mockResolvedValue([
      { id: "1", name: "Dental Clinic A" },
      { id: "2", name: "Dental Clinic B" }
    ]);

    const result = await ClinicService.getUserClinics("user-123");
    
    expect(result).toHaveLength(2);
    expect(result[0].name).toBe("Dental Clinic A");
    expect(prisma.clinic.findMany).toHaveBeenCalledWith({
      where: { users: { some: { id: "user-123" } } }
    });
  });
});
```

## Testing API Route Handlers

- Test API route handlers by mocking the Next.js Request and Response objects
- Focus on testing the correct status codes, headers, and response formats
- Example:

```ts
// src/app/api/metrics/route.test.ts
import { describe, it, expect, vi } from "vitest";
import { GET } from "./route";
import { MetricsService } from "@/services/metrics";

vi.mock("@/services/metrics");

describe("Metrics API Route", () => {
  it("should return metrics data with 200 status", async () => {
    // Mock the service
    vi.mocked(MetricsService.getDailyMetrics).mockResolvedValue([
      { date: "2023-01-01", value: 100 }
    ]);
    
    // Create mock request
    const request = new Request("http://localhost:3000/api/metrics?clinicId=123");
    
    // Call the route handler
    const response = await GET(request);
    
    // Assert response
    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data).toEqual([{ date: "2023-01-01", value: 100 }]);
  });
});
```

## Test Coverage Expectations

- Aim for at least 80% test coverage across the codebase
- Critical business logic in services should have 90%+ coverage
- UI components can have lower coverage, focusing on key functionality
- Run coverage reports regularly: `pnpm test:coverage`

## Best Practices

- Each test should be independent and not rely on the state from other tests
- Use descriptive test names that explain the expected behavior, not implementation
- Mock external dependencies to isolate the code being tested
- Always clean up mocks between tests using `beforeEach` and `vi.clearAllMocks()`
- Avoid testing implementation details; test behavior and outputs
- Follow the Arrange-Act-Assert pattern for clear test structure
- Use factories or test helpers to create test data instead of duplicating setup code
- Minimize the use of snapshots; when used, keep them small and focused

## Running Tests

```bash
# Run all tests
pnpm test

# Run tests in watch mode during development
pnpm test:watch

# Run tests with coverage report
pnpm test:coverage

# Run specific test file
pnpm test path/to/file.test.ts
```

## CI Integration

- All tests must pass before merging pull requests
- Coverage reports are generated on CI and stored as artifacts
- Integration tests run on scheduled intervals to detect regressions

These guidelines ensure consistent and effective testing across the codebase, supporting our server-first architecture and maintaining code quality.
</file>

<file path=".windsurf/rules/ui-components.md">
---
trigger: model_decision
description: UI component and styling guidelines using Shadcn UI, Radix UI, and Tailwind
globs: 
---
---
description: UI component and styling guidelines using Shadcn UI, Radix UI, and Tailwind
globs: 
alwaysApply: false
---

# UI Components and Styling

## UI Framework
- Use Shadcn UI and Tailwind for components and styling
- Implement responsive design with Tailwind CSS using a mobile-first approach
- Use `next/image` package for images
- Keep UI density moderate - not too sparse or crowded
- Follow a consistent visual hierarchy for all pages

## Shadcn Component Usage
- Always use ShadCN components where applicable
- Use Context7 MCP Tool to find applicable components and packages if you don't know about one
- Use Perplexity or Brave Search MCP Tools for something that Context7 can't satisfy
- If the user provides a URL for a component or package then use the fetch tool to scrape it and use that
- Maintain a list of used ShadCN components in ShadCN-context.md (make one if it doesn't exist)

## Component Installation
```sh
pnpm dlx shadcn@latest add COMPONENT
```
Example:
```sh
pnpm dlx shadcn@latest add progress
```

## Layout & Spacing
- Use Tailwind's spacing scale consistently (4px increments)
- Standard content padding: `p-4 md:p-6`
- Card spacing: `space-y-4` for vertical stacking
- Section spacing: `mb-8` between major sections
- Grid layouts: `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4`

## Typography
- Use Tailwind's typography classes consistently
- Headings: `text-2xl font-semibold` for page titles
- Subheadings: `text-xl font-medium` for section headers
- Body text: `text-sm` for forms, `text-base` for content
- Field labels: `text-sm font-medium text-gray-700`

## Colors
- Follow theme colors defined in `tailwind.config.js`
- Use semantic color classes: `text-primary`, `bg-secondary`
- For states: `text-destructive` (errors), `text-muted` (disabled)
- Maintain WCAG AA contrast ratio minimum (4.5:1)

## Data Fetching
- Wrap fetch calls in loading states
- Handle errors consistently

Example:
```tsx
// In a server component
const data = await getKPIData(params);

// In a client component
const { data, isLoading, error } = useKPIData(params);
```

## Loading Components
Use the `LoadingContent` component to handle loading states:
```tsx
<Card>
  <LoadingContent loading={isLoading} error={error}>
    {data && <MyComponent data={data} />}
  </LoadingContent>
</Card>
```

## Loading Skeletons
- Use for content that takes time to load
- Match skeleton shapes to actual content

```tsx
<Skeleton className="h-[42px] w-full rounded-md" />
```

## Form Components
- Group related fields with `<FormSection>` component
- Consistent label placement (top-aligned)
- Use field validation with clear error messages
- Required fields: add asterisk to label

Example:
```tsx
<FormField
  control={form.control}
  name="appointmentsCount"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Total hygiene Appointments</FormLabel>
      <FormControl>
        <Input type="number" placeholder="0" {...field} />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

## Input Types
- Text inputs: Use `Input` component with appropriate types
- Numeric inputs: Use `type="number"` with min/max when applicable
- Date inputs: Use `DatePicker` component
- Selects: Use `Select` component for single choice, `Combobox` for searchable
- Radio/Checkbox: Use Shadcn components with consistent spacing

## Cards & Containers
- Use `Card` for content grouping
- Standard structure: `CardHeader`, `CardContent`, `CardFooter`
- For metrics cards: consistent height, clear labeling

```tsx
<Card>
  <CardHeader>
    <CardTitle>Weekly KPI Summary</CardTitle>
  </CardHeader>
  <CardContent>
    {/* Content here */}
  </CardContent>
</Card>
```

## Tables
- Use Shadcn `Table` component for data grids
- Fixed headers for long tables
- Consistent column alignment (left for text, right for numbers)
- Include empty states and loading states

## Metrics & Data Visualization
- Use appropriate chart types based on data relationships
- Maintain consistent color schemes across charts
- Include legends and clear labeling
- Add context/tooltips for complex metrics

## Responsive Patterns
- Collapse multi-column layouts to single column on mobile
- Use `md:` and `lg:` breakpoints consistently
- Ensure touch targets are at least 44√ó44px on mobile
- Test layouts at 320px, 768px, and 1280px minimum

## Accessibility
- Maintain keyboard navigation for all interactive elements
- Use appropriate ARIA attributes when needed
- Ensure color is not the only means of conveying information
- Test with screen readers periodically

## Icons
- Use Lucide icons via `lucide-react` package
- Consistent sizing: `size={16}` for inline, `size={20}` for buttons
- Add appropriate labels or aria-labels

```tsx
<Button>
  <PlusIcon className="mr-2 h-4 w-4" />
  Add Appointment
</Button>
```

These guidelines ensure a consistent, accessible, and maintainable UI across the dental practice dashboard.
</file>

<file path="docs/auth-flow.md">
```mermaid
flowchart TD
    Start([User visits signup page]) --> FillForm[User fills signup form]
    FillForm --> Validation{Form validation}
    Validation -->|Invalid| ShowErrors[Display validation errors]
    ShowErrors --> FillForm
    
    Validation -->|Valid| AttemptSignup[Submit signup request to Supabase]
    AttemptSignup --> SignupSuccess{Signup successful?}
    
    SignupSuccess -->|No| DisplayError[Display server error message]
    DisplayError --> FillForm
    
    SignupSuccess -->|Yes| RedirectLogin[Redirect to login with success parameter]
    
    %% Google OAuth Flow
    Start --> ClickGoogle[User clicks 'Sign up with Google']
    ClickGoogle --> GoogleOAuth[Supabase initiates OAuth with Google]
    GoogleOAuth --> GoogleRedirect[Redirect to Google login]
    GoogleRedirect --> GoogleCallback[Google redirects back with auth code]
    GoogleCallback --> MissingCallback{Callback handler present?}
    
    MissingCallback -->|No| Error404[404 Error - Missing callback page]
    MissingCallback -->|Yes, but incomplete| AuthError[Auth Error page displayed]
    
    %% Current issue
    RedirectLogin --> NoVerification{Email verification?}
    NoVerification -->|Not sent/working| Issue2[Issue: No verification email]
```
```markdown
## Analysis Current Flow
- Based on my analysis, here are the key issues with the current authentication flow:
- Missing or incomplete callback handler: The code references redirections to /auth/callback, but the callback route implementation appears to be missing or incomplete. This might cause 404 errors after OAuth authentication or email verification.
- Email verification not working: As noted in your scratchpad, users don't receive verification emails when signing up with email/password.
- Post-signup redirection: There's a redirection to the login page with a success parameter after signup, rather than directly to the dashboard, which might cause confusion for users.
- To improve your authentication flow, you should:
  - Implement the callback route handler in src/app/auth/callback/route.ts
  - Configure email verification in your Supabase project settings
  - Create a proper verification flow that handles the callback correctly
```
</file>

<file path="docs/learnings.md">
## Prisma Commands

- pnpm prisma:generate - to generate the Prisma client
- pnpm prisma:push - to push the Prisma schema to the database
- pnpm prisma:studio - to start the Prisma Studio
- pnpm prisma:migrate - to migrate the database

## Next.js Commands

- pnpm dev - to start the development server
- pnpm build - to build the production application
- pnpm start - to start the production application


## Biome Commands

- pnpm lint - to check for linting issues
- pnpm lint:fix - to check and fix linting issues
- pnpm format - to format your code

## Mermaid Commands
To view Mermaid diagrams in Cursor:

1. Open your .md or .mmd file with Mermaid code blocks
2. Open preview:
   - Use Command Palette (Ctrl/Cmd + Shift + P)
   - Select "Markdown: Open Preview"
   - Or click preview button in editor
3. View diagram in preview pane
4. Edit code to update diagram in real-time

## Configuring PNPM workspace

```bash
engine-strict=true
use-pnpm=true
auto-install-peers=true
strict-peer-dependencies=false
```
## Repomix Commands

- pnpm dlx repomix --include "src/**/*.ts,**/*.md"
- pnpm dlx repomix
</file>

<file path="docs/primsa-commands.md">
``` markdown   
   2.3. Configure the Prisma Client generator
Now, run the following command to create the database tables and generate the Prisma Client:
    pnpm dlx prisma migrate dev --name init
```
</file>

<file path="docs/scratchpad.md">
# Authentication Pages Implementation Plan

## Overview

We need to implement two missing authentication features for our dental dashboard:
1. User registration (signup) page
2. Password reset functionality

## Current State

- Login page exists at `src/app/auth/login/page.tsx` with the `SignIn1` component
- Supabase auth is implemented correctly using `@supabase/ssr`
- Middleware is in place to handle authentication
- The login component has a link to `/auth/signup`

## Implementation Plan

### 1. Create Signup Page

**File Structure:**
- [x] `src/app/auth/signup/page.tsx` - Main signup page
- [x] `src/app/auth/signup/loading.tsx` - Loading state (mirror login page structure)
- [x] `src/app/auth/signup/error.tsx` - Error handling (mirror login page structure)
- [x] `src/components/ui/modern-stunning-sign-up.tsx` - Signup form component

**Component Features:**
- [x] Email/password registration form
- [x] Google OAuth signup option
- [x] Form validation
- [x] Success/error state handling
- [x] Link back to login page
- [x] Matching visual style with login page

### 2. Create Password Reset Flow ‚úÖ

**File Structure:**
- [x] `src/app/auth/reset-password/page.tsx` - Request password reset page
- [x] `src/app/auth/reset-password/loading.tsx` - Loading state
- [x] `src/app/auth/reset-password/error.tsx` - Error handling
- [x] `src/app/auth/reset-password/confirm/page.tsx` - Handle reset token & new password creation
- [x] `src/components/ui/password-reset-request.tsx` - Request form component
- [x] `src/components/ui/password-reset-confirm.tsx` - Password reset confirmation component

**Password Request Features:**
- [x] Email input field
- [x] Validation
- [x] Success message with instructions
- [x] Link back to login

**Password Reset Confirmation Features:**
- [x] New password & confirmation fields
- [x] Validation 
- [x] Automatic token extraction from URL
- [x] Success/error messages
- [x] Redirect to login after success

### 3. Update Login Page Component ‚úÖ

**Changes:**
- [x] Add "Forgot password?" link to the login form
- [x] Point link to `/auth/reset-password`

### 4. Create Authentication Actions

- [ ] Create reusable server actions for auth operations (optional for improved architecture)
- [ ] `src/actions/auth/signup.ts`
- [ ] `src/actions/auth/reset-password.ts`

### 5. Update Navigation Flow

- [ ] Ensure proper redirection from auth pages to dashboard when already logged in
- [ ] Add protective checks to prevent access to password reset confirmation page without token

## Implementation Details

**Signup Form Details:**
- [ ] Email and password inputs with validation
- [ ] Google OAuth option
- [ ] Terms acceptance checkbox
- [ ] Form submission with loading state
- [ ] Error handling for existing accounts

**Password Reset Request Details:**
- [ ] Email input with validation
- [ ] Success screen with check email message
- [ ] Error handling for non-existent accounts

**Password Reset Confirmation Details:**
- [ ] New password with confirmation
- [ ] Password strength requirements
- [ ] Token validation
- [ ] Success screen with auto-redirect

## Testing Plan

1. Test signup with valid and invalid credentials
2. Test password reset request flow
3. Test password reset completion flow
4. Test redirects for authenticated users
5. Test OAuth authentication flow

## Next Steps After Planning

1. Create signup page component
2. Create password reset request component
3. Create password reset confirmation component
4. Update login page with forgot password link
5. Test the complete authentication flow


## Issue 1: After signup, the user is not redirected to the dashboard - not created but lets use a placeholder. Result right now is a 404 error.
## Issue 2: Using email/password, the user doesn't get a verification email yet.
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path=".windsurf/rules/shadcn-component-tracking.md">
---
trigger: model_decision
description: Record of installed shadcn/ui components and their usage
globs: 
---
---
description: Record of installed shadcn/ui components and their usage
globs: 
alwaysApply: false
---

# ShadCN Component Tracking

This document tracks all installed shadcn/ui components for reference. Before installing a new component, check if it's already installed here.
If installed mark it with a ‚úÖ, if not installed yet mark it with a ‚ùå

## Core Components

| Component       | Installed | Command | Notes |
|-----------------|-----------|---------|-------|
| accordion       | ‚ùå        | `pnpm dlx shadcn@latest add accordion` | Used for collapsible content |
| alert           | ‚ùå        | `pnpm dlx shadcn@latest add alert` | System notifications |
| button          | ‚úÖ        | `pnpm dlx shadcn@latest add button` | Primary interaction element |
| card            | ‚ùå        | `pnpm dlx shadcn@latest add card` | Content containers |
| checkbox        | ‚ùå        | `pnpm dlx shadcn@latest add checkbox` | Boolean input |
| dialog          | ‚ùå        | `pnpm dlx shadcn@latest add dialog` | Modal dialogs |
| dropdown-menu   | ‚úÖ        | `pnpm dlx shadcn@latest add dropdown-menu` | Contextual actions |
| form            | ‚úÖ        | `pnpm dlx shadcn@latest add form` | Form validation and control |
| input           | ‚úÖ        | `pnpm dlx shadcn@latest add input` | Text input fields |
| label           | ‚ùå        | `pnpm dlx shadcn@latest add label` | Form field labels |
| popover         | ‚ùå        | `pnpm dlx shadcn@latest add popover` | Contextual tooltips |
| select          | ‚úÖ        | `pnpm dlx shadcn@latest add select` | Single-choice selection |
| separator       | ‚ùå        | `pnpm dlx shadcn@latest add separator` | Visual dividers |
| skeleton        | ‚úÖ        | `pnpm dlx shadcn@latest add skeleton` | Loading placeholders |
| tabs            | ‚úÖ        | `pnpm dlx shadcn@latest add tabs` | Tabbed interfaces |
| toast           | ‚ùå        | `pnpm dlx shadcn@latest add toast` | System notifications |

## Data Display Components

| Component       | Installed | Command | Notes |
|-----------------|-----------|---------|-------|
| avatar          | ‚ùå        | `pnpm dlx shadcn@latest add avatar` | User profile photos |
| badge           | ‚ùå        | `pnpm dlx shadcn@latest add badge` | Status indicators |
| table           | ‚úÖ        | `pnpm dlx shadcn@latest add table` | Data tables |
| progress        | ‚ùå        | `pnpm dlx shadcn@latest add progress` | Progress indicators |
| hover-card      | ‚ùå        | `pnpm dlx shadcn@latest add hover-card` | Hover previews |

## Date & Time Components

| Component       | Installed | Command | Notes |
|-----------------|-----------|---------|-------|
| calendar        | ‚ùå        | `pnpm dlx shadcn@latest add calendar` | Date picker |
| date-picker     | ‚ùå        | `pnpm dlx shadcn@latest add date-picker` | Complete date input |

## Layout Components

| Component       | Installed | Command | Notes |
|-----------------|-----------|---------|-------|
| sheet           | ‚ùå        | `pnpm dlx shadcn@latest add sheet` | Slide-out panels |
| scroll-area     | ‚ùå        | `pnpm dlx shadcn@latest scroll-area` | Custom scrollbars |
| resizable       | ‚ùå        | `pnpm dlx shadcn@latest add resizable` | Resizable panels |

## Navigation Components

| Component       | Installed | Command | Notes |
|-----------------|-----------|---------|-------|
| navigation-menu | ‚ùå        | `pnpm dlx shadcn@latest add navigation-menu` | Site navigation |
| command         | ‚ùå        | `pnpm dlx shadcn@latest add command` | Command palette |
| pagination      | ‚ùå        | `pnpm dlx shadcn@latest add pagination` | Page navigation |

## Advanced Form Components

| Component       | Installed | Command | Notes |
|-----------------|-----------|---------|-------|
| combobox        | ‚ùå        | `pnpm dlx shadcn@latest add combobox` | Searchable select |
| radio-group     | ‚ùå        | `pnpm dlx shadcn@latest add radio-group` | Option selection |
| switch          | ‚ùå        | `pnpm dlx shadcn@latest add switch` | Toggle control |
| textarea        | ‚ùå        | `pnpm dlx shadcn@latest add textarea` | Multiline text input |
| slider          | ‚ùå        | `pnpm dlx shadcn@latest add slider` | Range selection |

## Custom Components

| Component            | Installed | Notes |
|----------------------|-----------|-------|
| x-gradient-card      | ‚úÖ        | Custom gradient card component |
| expandable-tabs      | ‚úÖ        | Custom implementation of tabs with expansion |
| modern-stunning-sign-in | ‚úÖ     | Custom sign-in component with modern design |

## Usage Notes

- When building forms, always use the `form` component with validation
- For date inputs in forms, use the complete `date-picker` component
- For tables with pagination, combine the `table` and `pagination` components

## Example Form With Components

```tsx
<Form {...form}>
  <form onSubmit={form.handleSubmit(onSubmit)}>
    <Card>
      <CardHeader>
        <CardTitle>Front Desk KPIs</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <FormField
          control={form.control}
          name="date"
          render={({ field }) => (
            <FormItem className="flex flex-col">
              <FormLabel>Date</FormLabel>
              <DatePicker
                value={field.value}
                onChange={field.onChange}
              />
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="hygiene_appointments"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Total Hygiene Appointments</FormLabel>
              <FormControl>
                <Input type="number" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <Separator className="my-4" />
        
        <Button type="submit">Submit</Button>
      </CardContent>
    </Card>
  </form>
</Form>
```
</file>

<file path="src/generated/prisma/runtime/index-browser.d.ts">
declare class AnyNull extends NullTypesEnumValue {
  #private;
}

declare type Args<T, F extends Operation> = T extends {
  [K: symbol]: {
    types: {
      operations: {
        [K in F]: {
          args: any;
        };
      };
    };
  };
}
  ? T[symbol]["types"]["operations"][F]["args"]
  : any;

declare class DbNull extends NullTypesEnumValue {
  #private;
}

export declare function Decimal(n: Decimal.Value): Decimal;

export declare namespace Decimal {
  export type Constructor = typeof Decimal;
  export type Instance = Decimal;
  export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
  export type Modulo = Rounding | 9;
  export type Value = string | number | Decimal;

  // http://mikemcl.github.io/decimal.js/#constructor-properties
  export interface Config {
    precision?: number;
    rounding?: Rounding;
    toExpNeg?: number;
    toExpPos?: number;
    minE?: number;
    maxE?: number;
    crypto?: boolean;
    modulo?: Modulo;
    defaults?: boolean;
  }
}

export declare class Decimal {
  readonly d: number[];
  readonly e: number;
  readonly s: number;

  constructor(n: Decimal.Value);

  absoluteValue(): Decimal;
  abs(): Decimal;

  ceil(): Decimal;

  clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;
  clamp(min: Decimal.Value, max: Decimal.Value): Decimal;

  comparedTo(n: Decimal.Value): number;
  cmp(n: Decimal.Value): number;

  cosine(): Decimal;
  cos(): Decimal;

  cubeRoot(): Decimal;
  cbrt(): Decimal;

  decimalPlaces(): number;
  dp(): number;

  dividedBy(n: Decimal.Value): Decimal;
  div(n: Decimal.Value): Decimal;

  dividedToIntegerBy(n: Decimal.Value): Decimal;
  divToInt(n: Decimal.Value): Decimal;

  equals(n: Decimal.Value): boolean;
  eq(n: Decimal.Value): boolean;

  floor(): Decimal;

  greaterThan(n: Decimal.Value): boolean;
  gt(n: Decimal.Value): boolean;

  greaterThanOrEqualTo(n: Decimal.Value): boolean;
  gte(n: Decimal.Value): boolean;

  hyperbolicCosine(): Decimal;
  cosh(): Decimal;

  hyperbolicSine(): Decimal;
  sinh(): Decimal;

  hyperbolicTangent(): Decimal;
  tanh(): Decimal;

  inverseCosine(): Decimal;
  acos(): Decimal;

  inverseHyperbolicCosine(): Decimal;
  acosh(): Decimal;

  inverseHyperbolicSine(): Decimal;
  asinh(): Decimal;

  inverseHyperbolicTangent(): Decimal;
  atanh(): Decimal;

  inverseSine(): Decimal;
  asin(): Decimal;

  inverseTangent(): Decimal;
  atan(): Decimal;

  isFinite(): boolean;

  isInteger(): boolean;
  isInt(): boolean;

  isNaN(): boolean;

  isNegative(): boolean;
  isNeg(): boolean;

  isPositive(): boolean;
  isPos(): boolean;

  isZero(): boolean;

  lessThan(n: Decimal.Value): boolean;
  lt(n: Decimal.Value): boolean;

  lessThanOrEqualTo(n: Decimal.Value): boolean;
  lte(n: Decimal.Value): boolean;

  logarithm(n?: Decimal.Value): Decimal;
  log(n?: Decimal.Value): Decimal;

  minus(n: Decimal.Value): Decimal;
  sub(n: Decimal.Value): Decimal;

  modulo(n: Decimal.Value): Decimal;
  mod(n: Decimal.Value): Decimal;

  naturalExponential(): Decimal;
  exp(): Decimal;

  naturalLogarithm(): Decimal;
  ln(): Decimal;

  negated(): Decimal;
  neg(): Decimal;

  plus(n: Decimal.Value): Decimal;
  add(n: Decimal.Value): Decimal;

  precision(includeZeros?: boolean): number;
  sd(includeZeros?: boolean): number;

  round(): Decimal;

  sine(): Decimal;
  sin(): Decimal;

  squareRoot(): Decimal;
  sqrt(): Decimal;

  tangent(): Decimal;
  tan(): Decimal;

  times(n: Decimal.Value): Decimal;
  mul(n: Decimal.Value): Decimal;

  toBinary(significantDigits?: number): string;
  toBinary(significantDigits: number, rounding: Decimal.Rounding): string;

  toDecimalPlaces(decimalPlaces?: number): Decimal;
  toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;
  toDP(decimalPlaces?: number): Decimal;
  toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;

  toExponential(decimalPlaces?: number): string;
  toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;

  toFixed(decimalPlaces?: number): string;
  toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;

  toFraction(max_denominator?: Decimal.Value): Decimal[];

  toHexadecimal(significantDigits?: number): string;
  toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;
  toHex(significantDigits?: number): string;
  toHex(significantDigits: number, rounding?: Decimal.Rounding): string;

  toJSON(): string;

  toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;

  toNumber(): number;

  toOctal(significantDigits?: number): string;
  toOctal(significantDigits: number, rounding: Decimal.Rounding): string;

  toPower(n: Decimal.Value): Decimal;
  pow(n: Decimal.Value): Decimal;

  toPrecision(significantDigits?: number): string;
  toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;

  toSignificantDigits(significantDigits?: number): Decimal;
  toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;
  toSD(significantDigits?: number): Decimal;
  toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;

  toString(): string;

  truncated(): Decimal;
  trunc(): Decimal;

  valueOf(): string;

  static abs(n: Decimal.Value): Decimal;
  static acos(n: Decimal.Value): Decimal;
  static acosh(n: Decimal.Value): Decimal;
  static add(x: Decimal.Value, y: Decimal.Value): Decimal;
  static asin(n: Decimal.Value): Decimal;
  static asinh(n: Decimal.Value): Decimal;
  static atan(n: Decimal.Value): Decimal;
  static atanh(n: Decimal.Value): Decimal;
  static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;
  static cbrt(n: Decimal.Value): Decimal;
  static ceil(n: Decimal.Value): Decimal;
  static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;
  static clone(object?: Decimal.Config): Decimal.Constructor;
  static config(object: Decimal.Config): Decimal.Constructor;
  static cos(n: Decimal.Value): Decimal;
  static cosh(n: Decimal.Value): Decimal;
  static div(x: Decimal.Value, y: Decimal.Value): Decimal;
  static exp(n: Decimal.Value): Decimal;
  static floor(n: Decimal.Value): Decimal;
  static hypot(...n: Decimal.Value[]): Decimal;
  static isDecimal(object: any): object is Decimal;
  static ln(n: Decimal.Value): Decimal;
  static log(n: Decimal.Value, base?: Decimal.Value): Decimal;
  static log2(n: Decimal.Value): Decimal;
  static log10(n: Decimal.Value): Decimal;
  static max(...n: Decimal.Value[]): Decimal;
  static min(...n: Decimal.Value[]): Decimal;
  static mod(x: Decimal.Value, y: Decimal.Value): Decimal;
  static mul(x: Decimal.Value, y: Decimal.Value): Decimal;
  static noConflict(): Decimal.Constructor; // Browser only
  static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;
  static random(significantDigits?: number): Decimal;
  static round(n: Decimal.Value): Decimal;
  static set(object: Decimal.Config): Decimal.Constructor;
  static sign(n: Decimal.Value): number;
  static sin(n: Decimal.Value): Decimal;
  static sinh(n: Decimal.Value): Decimal;
  static sqrt(n: Decimal.Value): Decimal;
  static sub(x: Decimal.Value, y: Decimal.Value): Decimal;
  static sum(...n: Decimal.Value[]): Decimal;
  static tan(n: Decimal.Value): Decimal;
  static tanh(n: Decimal.Value): Decimal;
  static trunc(n: Decimal.Value): Decimal;

  static readonly default?: Decimal.Constructor;
  static readonly Decimal?: Decimal.Constructor;

  static readonly precision: number;
  static readonly rounding: Decimal.Rounding;
  static readonly toExpNeg: number;
  static readonly toExpPos: number;
  static readonly minE: number;
  static readonly maxE: number;
  static readonly crypto: boolean;
  static readonly modulo: Decimal.Modulo;

  static readonly ROUND_UP: 0;
  static readonly ROUND_DOWN: 1;
  static readonly ROUND_CEIL: 2;
  static readonly ROUND_FLOOR: 3;
  static readonly ROUND_HALF_UP: 4;
  static readonly ROUND_HALF_DOWN: 5;
  static readonly ROUND_HALF_EVEN: 6;
  static readonly ROUND_HALF_CEIL: 7;
  static readonly ROUND_HALF_FLOOR: 8;
  static readonly EUCLID: 9;
}

declare type Exact<A, W> =
  | (A extends unknown
      ? W extends A
        ? {
            [K in keyof A]: Exact<A[K], W[K]>;
          }
        : W
      : never)
  | (A extends Narrowable ? A : never);

export declare function getRuntime(): GetRuntimeOutput;

declare type GetRuntimeOutput = {
  id: RuntimeName;
  prettyName: string;
  isEdge: boolean;
};

declare class JsonNull extends NullTypesEnumValue {
  #private;
}

/**
 * Generates more strict variant of an enum which, unlike regular enum,
 * throws on non-existing property access. This can be useful in following situations:
 * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input
 * - enum values are generated dynamically from DMMF.
 *
 * In that case, if using normal enums and no compile-time typechecking, using non-existing property
 * will result in `undefined` value being used, which will be accepted. Using strict enum
 * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.
 *
 * Note: if you need to check for existence of a value in the enum you can still use either
 * `in` operator or `hasOwnProperty` function.
 *
 * @param definition
 * @returns
 */
export declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(
  definition: T
): T;

declare type Narrowable = string | number | bigint | boolean | [];

declare class NullTypesEnumValue extends ObjectEnumValue {
  _getNamespace(): string;
}

/**
 * Base class for unique values of object-valued enums.
 */
declare abstract class ObjectEnumValue {
  constructor(arg?: symbol);
  abstract _getNamespace(): string;
  _getName(): string;
  toString(): string;
}

export declare const objectEnumValues: {
  classes: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };
  instances: {
    DbNull: DbNull;
    JsonNull: JsonNull;
    AnyNull: AnyNull;
  };
};

declare type Operation =
  | "findFirst"
  | "findFirstOrThrow"
  | "findUnique"
  | "findUniqueOrThrow"
  | "findMany"
  | "create"
  | "createMany"
  | "createManyAndReturn"
  | "update"
  | "updateMany"
  | "updateManyAndReturn"
  | "upsert"
  | "delete"
  | "deleteMany"
  | "aggregate"
  | "count"
  | "groupBy"
  | "$queryRaw"
  | "$executeRaw"
  | "$queryRawUnsafe"
  | "$executeRawUnsafe"
  | "findRaw"
  | "aggregateRaw"
  | "$runCommandRaw";

declare namespace Public {
  export { validator };
}
export { Public };

declare type RuntimeName = "workerd" | "deno" | "netlify" | "node" | "bun" | "edge-light" | "";

declare function validator<V>(): <S>(select: Exact<S, V>) => S;

declare function validator<
  C,
  M extends Exclude<keyof C, `$${string}`>,
  O extends keyof C[M] & Operation,
>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;

declare function validator<
  C,
  M extends Exclude<keyof C, `$${string}`>,
  O extends keyof C[M] & Operation,
  P extends keyof Args<C[M], O>,
>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;

export {};
</file>

<file path="src/generated/prisma/runtime/library.d.ts">
/**
 * @param this
 */
declare function $extends(
  this: Client,
  extension: ExtensionArgs | ((client: Client) => Client)
): Client;

declare type AccelerateEngineConfig = {
  inlineSchema: EngineConfig["inlineSchema"];
  inlineSchemaHash: EngineConfig["inlineSchemaHash"];
  env: EngineConfig["env"];
  generator?: {
    previewFeatures: string[];
  };
  inlineDatasources: EngineConfig["inlineDatasources"];
  overrideDatasources: EngineConfig["overrideDatasources"];
  clientVersion: EngineConfig["clientVersion"];
  engineVersion: EngineConfig["engineVersion"];
  logEmitter: EngineConfig["logEmitter"];
  logQueries?: EngineConfig["logQueries"];
  logLevel?: EngineConfig["logLevel"];
  tracingHelper: EngineConfig["tracingHelper"];
  accelerateUtils?: AccelerateUtils;
};

declare type AccelerateUtils = EngineConfig["accelerateUtils"];

export declare type Action =
  | keyof typeof DMMF_2.ModelAction
  | "executeRaw"
  | "queryRaw"
  | "runCommandRaw";

declare type ActiveConnectorType = Exclude<ConnectorType, "postgres" | "prisma+postgres">;

/**
 * An interface that exposes some basic information about the
 * adapter like its name and provider type.
 */
declare interface AdapterInfo {
  readonly provider: Provider;
  readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});
}

export declare type Aggregate = "_count" | "_max" | "_min" | "_avg" | "_sum";

export declare type AllModelsToStringIndex<
  TypeMap extends TypeMapDef,
  Args extends Record<string, any>,
  K extends PropertyKey,
> = Args extends {
  [P in K]: {
    $allModels: infer AllModels;
  };
}
  ? {
      [P in K]: Record<TypeMap["meta"]["modelProps"], AllModels>;
    }
  : {};

declare class AnyNull extends NullTypesEnumValue {
  #private;
}

export declare type ApplyOmit<T, OmitConfig> = Compute<{
  [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];
}>;

export declare type Args<T, F extends Operation> = T extends {
  [K: symbol]: {
    types: {
      operations: {
        [K in F]: {
          args: any;
        };
      };
    };
  };
}
  ? T[symbol]["types"]["operations"][F]["args"]
  : any;

export declare type Args_3<T, F extends Operation> = Args<T, F>;

/**
 * Original `quaint::ValueType` enum tag from Prisma's `quaint`.
 * Query arguments marked with this type are sanitized before being sent to the database.
 * Notice while a query argument may be `null`, `ArgType` is guaranteed to be defined.
 */
declare type ArgType =
  | "Int32"
  | "Int64"
  | "Float"
  | "Double"
  | "Text"
  | "Enum"
  | "EnumArray"
  | "Bytes"
  | "Boolean"
  | "Char"
  | "Array"
  | "Numeric"
  | "Json"
  | "Xml"
  | "Uuid"
  | "DateTime"
  | "Date"
  | "Time";

/**
 * Attributes is a map from string to attribute values.
 *
 * Note: only the own enumerable keys are counted as valid attribute keys.
 */
declare interface Attributes {
  [attributeKey: string]: AttributeValue | undefined;
}

/**
 * Attribute values may be any non-nullish primitive value except an object.
 *
 * null or undefined attribute values are invalid and will result in undefined behavior.
 */
declare type AttributeValue =
  | string
  | number
  | boolean
  | Array<null | undefined | string>
  | Array<null | undefined | number>
  | Array<null | undefined | boolean>;

export declare type BaseDMMF = {
  readonly datamodel: Omit<DMMF_2.Datamodel, "indexes">;
};

declare type BatchArgs = {
  queries: BatchQuery[];
  transaction?: {
    isolationLevel?: IsolationLevel;
  };
};

declare type BatchInternalParams = {
  requests: RequestParams[];
  customDataProxyFetch?: CustomDataProxyFetch;
};

declare type BatchQuery = {
  model: string | undefined;
  operation: string;
  args: JsArgs | RawQueryArgs;
};

declare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;

declare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;

declare type BatchQueryOptionsCbArgs = {
  args: BatchArgs;
  query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;
  __internalParams: BatchInternalParams;
};

declare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;

declare type BatchTransactionOptions = {
  isolationLevel?: IsolationLevel;
};

declare interface BinaryTargetsEnvValue {
  fromEnvVar: string | null;
  value: string;
  native?: boolean;
}

export declare type Call<F extends Fn, P> = (F & {
  params: P;
})["returns"];

declare interface CallSite {
  getLocation(): LocationInFile | null;
}

export declare type Cast<A, W> = A extends W ? A : W;

declare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;

export declare type ClientArg = {
  [MethodName in string]: unknown;
};

export declare type ClientArgs = {
  client: ClientArg;
};

export declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<
  never,
  never,
  never
>;

export declare type ClientOptionDef =
  | undefined
  | {
      [K in string]: any;
    };

export declare type ClientOtherOps = {
  $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;
  $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;
  $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;
  $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;
  $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;
};

declare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];

declare const ColumnTypeEnum: {
  readonly Int32: 0;
  readonly Int64: 1;
  readonly Float: 2;
  readonly Double: 3;
  readonly Numeric: 4;
  readonly Boolean: 5;
  readonly Character: 6;
  readonly Text: 7;
  readonly Date: 8;
  readonly Time: 9;
  readonly DateTime: 10;
  readonly Json: 11;
  readonly Enum: 12;
  readonly Bytes: 13;
  readonly Set: 14;
  readonly Uuid: 15;
  readonly Int32Array: 64;
  readonly Int64Array: 65;
  readonly FloatArray: 66;
  readonly DoubleArray: 67;
  readonly NumericArray: 68;
  readonly BooleanArray: 69;
  readonly CharacterArray: 70;
  readonly TextArray: 71;
  readonly DateArray: 72;
  readonly TimeArray: 73;
  readonly DateTimeArray: 74;
  readonly JsonArray: 75;
  readonly EnumArray: 76;
  readonly BytesArray: 77;
  readonly UuidArray: 78;
  readonly UnknownNumber: 128;
};

declare type CompactedBatchResponse = {
  type: "compacted";
  plan: object;
  arguments: Record<string, {}>[];
  nestedSelection: string[];
  keys: string[];
  expectNonEmpty: boolean;
};

declare type CompilerWasmLoadingConfig = {
  /**
   * WASM-bindgen runtime for corresponding module
   */
  getRuntime: () => Promise<{
    __wbg_set_wasm(exports: unknown): void;
    QueryCompiler: QueryCompilerConstructor;
  }>;
  /**
   * Loads the raw wasm module for the wasm compiler engine. This configuration is
   * generated specifically for each type of client, eg. Node.js client and Edge
   * clients will have different implementations.
   * @remarks this is a callback on purpose, we only load the wasm if needed.
   * @remarks only used by ClientEngine
   */
  getQueryCompilerWasmModule: () => Promise<unknown>;
};

export declare type Compute<T> = T extends Function
  ? T
  : {
      [K in keyof T]: T[K];
    } & unknown;

export declare type ComputeDeep<T> = T extends Function
  ? T
  : {
      [K in keyof T]: ComputeDeep<T[K]>;
    } & unknown;

declare type ComputedField = {
  name: string;
  needs: string[];
  compute: ResultArgsFieldCompute;
};

declare type ComputedFieldsMap = {
  [fieldName: string]: ComputedField;
};

declare type ConnectionInfo = {
  schemaName?: string;
  maxBindValues?: number;
};

declare type ConnectorType =
  | "mysql"
  | "mongodb"
  | "sqlite"
  | "postgresql"
  | "postgres"
  | "prisma+postgres"
  | "sqlserver"
  | "cockroachdb";

declare interface Context {
  /**
   * Get a value from the context.
   *
   * @param key key which identifies a context value
   */
  getValue(key: symbol): unknown;
  /**
   * Create a new context which inherits from this context and has
   * the given key set to the given value.
   *
   * @param key context key for which to set the value
   * @param value value to set for the given key
   */
  setValue(key: symbol, value: unknown): Context;
  /**
   * Return a new context which inherits from this context but does
   * not contain a value for the given key.
   *
   * @param key context key for which to clear a value
   */
  deleteValue(key: symbol): Context;
}

declare type Context_2<T> = T extends {
  [K: symbol]: {
    ctx: infer C;
  };
}
  ? C &
      T & {
        /**
         * @deprecated Use `$name` instead.
         */
        name?: string;
        $name?: string;
        $parent?: unknown;
      }
  : T & {
      /**
       * @deprecated Use `$name` instead.
       */
      name?: string;
      $name?: string;
      $parent?: unknown;
    };

export declare type Count<O> = {
  [K in keyof O]: Count<number>;
} & {};

export declare function createParam(name: string): Param<unknown, string>;

/**
 * Custom fetch function for `DataProxyEngine`.
 *
 * We can't use the actual type of `globalThis.fetch` because this will result
 * in API Extractor referencing Node.js type definitions in the `.d.ts` bundle
 * for the client runtime. We can only use such types in internal types that
 * don't end up exported anywhere.

 * It's also not possible to write a definition of `fetch` that would accept the
 * actual `fetch` function from different environments such as Node.js and
 * Cloudflare Workers (with their extensions to `RequestInit` and `Response`).
 * `fetch` is used in both covariant and contravariant positions in
 * `CustomDataProxyFetch`, making it invariant, so we need the exact same type.
 * Even if we removed the argument and left `fetch` in covariant position only,
 * then for an extension-supplied function to be assignable to `customDataProxyFetch`,
 * the platform-specific (or custom) `fetch` function needs to be assignable
 * to our `fetch` definition. This, in turn, requires the third-party `Response`
 * to be a subtype of our `Response` (which is not a problem, we could declare
 * a minimal `Response` type that only includes what we use) *and* requires the
 * third-party `RequestInit` to be a supertype of our `RequestInit` (i.e. we
 * have to declare all properties any `RequestInit` implementation in existence
 * could possibly have), which is not possible.
 *
 * Since `@prisma/extension-accelerate` redefines the type of
 * `__internalParams.customDataProxyFetch` to its own type anyway (probably for
 * exactly this reason), our definition is never actually used and is completely
 * ignored, so it doesn't matter, and we can just use `unknown` as the type of
 * `fetch` here.
 */
declare type CustomDataProxyFetch = (fetch: unknown) => unknown;

declare class DataLoader<T = unknown> {
  private options;
  batches: {
    [key: string]: Job[];
  };
  private tickActive;
  constructor(options: DataLoaderOptions<T>);
  request(request: T): Promise<any>;
  private dispatchBatches;
  get [Symbol.toStringTag](): string;
}

declare type DataLoaderOptions<T> = {
  singleLoader: (request: T) => Promise<any>;
  batchLoader: (request: T[]) => Promise<any[]>;
  batchBy: (request: T) => string | undefined;
  batchOrder: (requestA: T, requestB: T) => number;
};

declare type Datamodel = ReadonlyDeep_2<{
  models: Model[];
  enums: DatamodelEnum[];
  types: Model[];
  indexes: Index[];
}>;

declare type DatamodelEnum = ReadonlyDeep_2<{
  name: string;
  values: EnumValue[];
  dbName?: string | null;
  documentation?: string;
}>;

declare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;

declare type Datasource = {
  url?: string;
};

declare type Datasources = {
  [name in string]: Datasource;
};

declare class DbNull extends NullTypesEnumValue {
  #private;
}

export declare const Debug: typeof debugCreate & {
  enable(namespace: any): void;
  disable(): any;
  enabled(namespace: string): boolean;
  log: (...args: string[]) => void;
  formatters: {};
};

/**
 * Create a new debug instance with the given namespace.
 *
 * @example
 * ```ts
 * import Debug from '@prisma/debug'
 * const debug = Debug('prisma:client')
 * debug('Hello World')
 * ```
 */
declare function debugCreate(namespace: string): ((...args: any[]) => void) & {
  color: string;
  enabled: boolean;
  namespace: string;
  log: (...args: string[]) => void;
  extend: () => void;
};

export declare function Decimal(n: Decimal.Value): Decimal;

export declare namespace Decimal {
  export type Constructor = typeof Decimal;
  export type Instance = Decimal;
  export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
  export type Modulo = Rounding | 9;
  export type Value = string | number | Decimal;

  // http://mikemcl.github.io/decimal.js/#constructor-properties
  export interface Config {
    precision?: number;
    rounding?: Rounding;
    toExpNeg?: number;
    toExpPos?: number;
    minE?: number;
    maxE?: number;
    crypto?: boolean;
    modulo?: Modulo;
    defaults?: boolean;
  }
}

export declare class Decimal {
  readonly d: number[];
  readonly e: number;
  readonly s: number;

  constructor(n: Decimal.Value);

  absoluteValue(): Decimal;
  abs(): Decimal;

  ceil(): Decimal;

  clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;
  clamp(min: Decimal.Value, max: Decimal.Value): Decimal;

  comparedTo(n: Decimal.Value): number;
  cmp(n: Decimal.Value): number;

  cosine(): Decimal;
  cos(): Decimal;

  cubeRoot(): Decimal;
  cbrt(): Decimal;

  decimalPlaces(): number;
  dp(): number;

  dividedBy(n: Decimal.Value): Decimal;
  div(n: Decimal.Value): Decimal;

  dividedToIntegerBy(n: Decimal.Value): Decimal;
  divToInt(n: Decimal.Value): Decimal;

  equals(n: Decimal.Value): boolean;
  eq(n: Decimal.Value): boolean;

  floor(): Decimal;

  greaterThan(n: Decimal.Value): boolean;
  gt(n: Decimal.Value): boolean;

  greaterThanOrEqualTo(n: Decimal.Value): boolean;
  gte(n: Decimal.Value): boolean;

  hyperbolicCosine(): Decimal;
  cosh(): Decimal;

  hyperbolicSine(): Decimal;
  sinh(): Decimal;

  hyperbolicTangent(): Decimal;
  tanh(): Decimal;

  inverseCosine(): Decimal;
  acos(): Decimal;

  inverseHyperbolicCosine(): Decimal;
  acosh(): Decimal;

  inverseHyperbolicSine(): Decimal;
  asinh(): Decimal;

  inverseHyperbolicTangent(): Decimal;
  atanh(): Decimal;

  inverseSine(): Decimal;
  asin(): Decimal;

  inverseTangent(): Decimal;
  atan(): Decimal;

  isFinite(): boolean;

  isInteger(): boolean;
  isInt(): boolean;

  isNaN(): boolean;

  isNegative(): boolean;
  isNeg(): boolean;

  isPositive(): boolean;
  isPos(): boolean;

  isZero(): boolean;

  lessThan(n: Decimal.Value): boolean;
  lt(n: Decimal.Value): boolean;

  lessThanOrEqualTo(n: Decimal.Value): boolean;
  lte(n: Decimal.Value): boolean;

  logarithm(n?: Decimal.Value): Decimal;
  log(n?: Decimal.Value): Decimal;

  minus(n: Decimal.Value): Decimal;
  sub(n: Decimal.Value): Decimal;

  modulo(n: Decimal.Value): Decimal;
  mod(n: Decimal.Value): Decimal;

  naturalExponential(): Decimal;
  exp(): Decimal;

  naturalLogarithm(): Decimal;
  ln(): Decimal;

  negated(): Decimal;
  neg(): Decimal;

  plus(n: Decimal.Value): Decimal;
  add(n: Decimal.Value): Decimal;

  precision(includeZeros?: boolean): number;
  sd(includeZeros?: boolean): number;

  round(): Decimal;

  sine(): Decimal;
  sin(): Decimal;

  squareRoot(): Decimal;
  sqrt(): Decimal;

  tangent(): Decimal;
  tan(): Decimal;

  times(n: Decimal.Value): Decimal;
  mul(n: Decimal.Value): Decimal;

  toBinary(significantDigits?: number): string;
  toBinary(significantDigits: number, rounding: Decimal.Rounding): string;

  toDecimalPlaces(decimalPlaces?: number): Decimal;
  toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;
  toDP(decimalPlaces?: number): Decimal;
  toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;

  toExponential(decimalPlaces?: number): string;
  toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;

  toFixed(decimalPlaces?: number): string;
  toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;

  toFraction(max_denominator?: Decimal.Value): Decimal[];

  toHexadecimal(significantDigits?: number): string;
  toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;
  toHex(significantDigits?: number): string;
  toHex(significantDigits: number, rounding?: Decimal.Rounding): string;

  toJSON(): string;

  toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;

  toNumber(): number;

  toOctal(significantDigits?: number): string;
  toOctal(significantDigits: number, rounding: Decimal.Rounding): string;

  toPower(n: Decimal.Value): Decimal;
  pow(n: Decimal.Value): Decimal;

  toPrecision(significantDigits?: number): string;
  toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;

  toSignificantDigits(significantDigits?: number): Decimal;
  toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;
  toSD(significantDigits?: number): Decimal;
  toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;

  toString(): string;

  truncated(): Decimal;
  trunc(): Decimal;

  valueOf(): string;

  static abs(n: Decimal.Value): Decimal;
  static acos(n: Decimal.Value): Decimal;
  static acosh(n: Decimal.Value): Decimal;
  static add(x: Decimal.Value, y: Decimal.Value): Decimal;
  static asin(n: Decimal.Value): Decimal;
  static asinh(n: Decimal.Value): Decimal;
  static atan(n: Decimal.Value): Decimal;
  static atanh(n: Decimal.Value): Decimal;
  static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;
  static cbrt(n: Decimal.Value): Decimal;
  static ceil(n: Decimal.Value): Decimal;
  static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;
  static clone(object?: Decimal.Config): Decimal.Constructor;
  static config(object: Decimal.Config): Decimal.Constructor;
  static cos(n: Decimal.Value): Decimal;
  static cosh(n: Decimal.Value): Decimal;
  static div(x: Decimal.Value, y: Decimal.Value): Decimal;
  static exp(n: Decimal.Value): Decimal;
  static floor(n: Decimal.Value): Decimal;
  static hypot(...n: Decimal.Value[]): Decimal;
  static isDecimal(object: any): object is Decimal;
  static ln(n: Decimal.Value): Decimal;
  static log(n: Decimal.Value, base?: Decimal.Value): Decimal;
  static log2(n: Decimal.Value): Decimal;
  static log10(n: Decimal.Value): Decimal;
  static max(...n: Decimal.Value[]): Decimal;
  static min(...n: Decimal.Value[]): Decimal;
  static mod(x: Decimal.Value, y: Decimal.Value): Decimal;
  static mul(x: Decimal.Value, y: Decimal.Value): Decimal;
  static noConflict(): Decimal.Constructor; // Browser only
  static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;
  static random(significantDigits?: number): Decimal;
  static round(n: Decimal.Value): Decimal;
  static set(object: Decimal.Config): Decimal.Constructor;
  static sign(n: Decimal.Value): number;
  static sin(n: Decimal.Value): Decimal;
  static sinh(n: Decimal.Value): Decimal;
  static sqrt(n: Decimal.Value): Decimal;
  static sub(x: Decimal.Value, y: Decimal.Value): Decimal;
  static sum(...n: Decimal.Value[]): Decimal;
  static tan(n: Decimal.Value): Decimal;
  static tanh(n: Decimal.Value): Decimal;
  static trunc(n: Decimal.Value): Decimal;

  static readonly default?: Decimal.Constructor;
  static readonly Decimal?: Decimal.Constructor;

  static readonly precision: number;
  static readonly rounding: Decimal.Rounding;
  static readonly toExpNeg: number;
  static readonly toExpPos: number;
  static readonly minE: number;
  static readonly maxE: number;
  static readonly crypto: boolean;
  static readonly modulo: Decimal.Modulo;

  static readonly ROUND_UP: 0;
  static readonly ROUND_DOWN: 1;
  static readonly ROUND_CEIL: 2;
  static readonly ROUND_FLOOR: 3;
  static readonly ROUND_HALF_UP: 4;
  static readonly ROUND_HALF_DOWN: 5;
  static readonly ROUND_HALF_EVEN: 6;
  static readonly ROUND_HALF_CEIL: 7;
  static readonly ROUND_HALF_FLOOR: 8;
  static readonly EUCLID: 9;
}

/**
 * Interface for any Decimal.js-like library
 * Allows us to accept Decimal.js from different
 * versions and some compatible alternatives
 */
export declare interface DecimalJsLike {
  d: number[];
  e: number;
  s: number;
  toFixed(): string;
}

export declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;

export declare type DefaultSelection<
  Payload extends OperationPayload,
  Args = {},
  GlobalOmitOptions = {},
> = Args extends {
  omit: infer LocalOmit;
}
  ? ApplyOmit<
      UnwrapPayload<{
        default: Payload;
      }>["default"],
      PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload["name"]>>>
    >
  : ApplyOmit<
      UnwrapPayload<{
        default: Payload;
      }>["default"],
      ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload["name"]>>
    >;

export declare function defineDmmfProperty(
  target: object,
  runtimeDataModel: RuntimeDataModel
): void;

declare function defineExtension(
  ext: ExtensionArgs | ((client: Client) => Client)
): (client: Client) => Client;

declare const denylist: readonly [
  "$connect",
  "$disconnect",
  "$on",
  "$transaction",
  "$use",
  "$extends",
];

declare type Deprecation = ReadonlyDeep_2<{
  sinceVersion: string;
  reason: string;
  plannedRemovalVersion?: string;
}>;

declare type DeserializedResponse = Array<Record<string, unknown>>;

export declare function deserializeJsonResponse(result: unknown): unknown;

export declare function deserializeRawResult(response: RawResponse): DeserializedResponse;

export declare type DevTypeMapDef = {
  meta: {
    modelProps: string;
  };
  model: {
    [Model in PropertyKey]: {
      [Operation in PropertyKey]: DevTypeMapFnDef;
    };
  };
  other: {
    [Operation in PropertyKey]: DevTypeMapFnDef;
  };
};

export declare type DevTypeMapFnDef = {
  args: any;
  result: any;
  payload: OperationPayload;
};

export declare namespace DMMF {
  export {
    datamodelEnumToSchemaEnum,
    Document_2 as Document,
    Mappings,
    OtherOperationMappings,
    DatamodelEnum,
    SchemaEnum,
    EnumValue,
    Datamodel,
    uniqueIndex,
    PrimaryKey,
    Model,
    FieldKind,
    FieldNamespace,
    FieldLocation,
    Field,
    FieldDefault,
    FieldDefaultScalar,
    Index,
    IndexType,
    IndexField,
    SortOrder,
    Schema,
    Query,
    QueryOutput,
    TypeRef,
    InputTypeRef,
    SchemaArg,
    OutputType,
    SchemaField,
    OutputTypeRef,
    Deprecation,
    InputType,
    FieldRefType,
    FieldRefAllowType,
    ModelMapping,
    ModelAction,
  };
}

declare namespace DMMF_2 {
  export {
    datamodelEnumToSchemaEnum,
    Document_2 as Document,
    Mappings,
    OtherOperationMappings,
    DatamodelEnum,
    SchemaEnum,
    EnumValue,
    Datamodel,
    uniqueIndex,
    PrimaryKey,
    Model,
    FieldKind,
    FieldNamespace,
    FieldLocation,
    Field,
    FieldDefault,
    FieldDefaultScalar,
    Index,
    IndexType,
    IndexField,
    SortOrder,
    Schema,
    Query,
    QueryOutput,
    TypeRef,
    InputTypeRef,
    SchemaArg,
    OutputType,
    SchemaField,
    OutputTypeRef,
    Deprecation,
    InputType,
    FieldRefType,
    FieldRefAllowType,
    ModelMapping,
    ModelAction,
  };
}

export declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;

declare type Document_2 = ReadonlyDeep_2<{
  datamodel: Datamodel;
  schema: Schema;
  mappings: Mappings;
}>;

/**
 * A generic driver adapter factory that allows the user to instantiate a
 * driver adapter. The query and result types are specific to the adapter.
 */
declare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {
  /**
   * Instantiate a driver adapter.
   */
  connect(): Promise<Queryable<Query, Result>>;
}

/** Client */
export declare type DynamicClientExtensionArgs<
  C_,
  TypeMap extends TypeMapDef,
  TypeMapCb extends TypeMapCbDef,
  ExtArgs extends Record<string, any>,
> = {
  [P in keyof C_]: unknown;
} & {
  [K: symbol]: {
    ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {
      $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;
    };
  };
};

export declare type DynamicClientExtensionThis<
  TypeMap extends TypeMapDef,
  TypeMapCb extends TypeMapCbDef,
  ExtArgs extends Record<string, any>,
> = {
  [P in keyof ExtArgs["client"]]: Return<ExtArgs["client"][P]>;
} & {
  [P in Exclude<TypeMap["meta"]["modelProps"], keyof ExtArgs["client"]>]: DynamicModelExtensionThis<
    TypeMap,
    ModelKey<TypeMap, P>,
    ExtArgs
  >;
} & {
  [P in Exclude<
    keyof TypeMap["other"]["operations"],
    keyof ExtArgs["client"]
  >]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;
} & {
  [P in Exclude<ClientBuiltInProp, keyof ExtArgs["client"]>]: DynamicClientExtensionThisBuiltin<
    TypeMap,
    TypeMapCb,
    ExtArgs
  >[P];
} & {
  [K: symbol]: {
    types: TypeMap["other"];
  };
};

export declare type DynamicClientExtensionThisBuiltin<
  TypeMap extends TypeMapDef,
  TypeMapCb extends TypeMapCbDef,
  ExtArgs extends Record<string, any>,
> = {
  $extends: ExtendsHook<
    "extends",
    TypeMapCb,
    ExtArgs,
    Call<
      TypeMapCb,
      {
        extArgs: ExtArgs;
      }
    >
  >;
  $transaction<P extends PrismaPromise<any>[]>(
    arg: [...P],
    options?: {
      isolationLevel?: TypeMap["meta"]["txIsolationLevel"];
    }
  ): Promise<UnwrapTuple<P>>;
  $transaction<R>(
    fn: (
      client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>
    ) => Promise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: TypeMap["meta"]["txIsolationLevel"];
    }
  ): Promise<R>;
  $disconnect(): Promise<void>;
  $connect(): Promise<void>;
};

/** Model */
export declare type DynamicModelExtensionArgs<
  M_,
  TypeMap extends TypeMapDef,
  TypeMapCb extends TypeMapCbDef,
  ExtArgs extends Record<string, any>,
> = {
  [K in keyof M_]: K extends "$allModels"
    ? {
        [P in keyof M_[K]]?: unknown;
      } & {
        [K: symbol]: {};
      }
    : K extends TypeMap["meta"]["modelProps"]
      ? {
          [P in keyof M_[K]]?: unknown;
        } & {
          [K: symbol]: {
            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {
              $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;
            } & {
              $name: ModelKey<TypeMap, K>;
            } & {
              /**
               * @deprecated Use `$name` instead.
               */
              name: ModelKey<TypeMap, K>;
            };
          };
        }
      : never;
};

export declare type DynamicModelExtensionFluentApi<
  TypeMap extends TypeMapDef,
  M extends PropertyKey,
  P extends PropertyKey,
  Null,
> = {
  [K in keyof TypeMap["model"][M]["payload"]["objects"]]: <A>(
    args?: Exact<A, Path<TypeMap["model"][M]["operations"][P]["args"]["select"], [K]>>
  ) => PrismaPromise<
    | Path<
        DynamicModelExtensionFnResultBase<
          TypeMap,
          M,
          {
            select: {
              [P in K]: A;
            };
          },
          P
        >,
        [K]
      >
    | Null
  > &
    DynamicModelExtensionFluentApi<
      TypeMap,
      (TypeMap["model"][M]["payload"]["objects"][K] & {})["name"],
      P,
      Null | Select<TypeMap["model"][M]["payload"]["objects"][K], null>
    >;
};

export declare type DynamicModelExtensionFnResult<
  TypeMap extends TypeMapDef,
  M extends PropertyKey,
  A,
  P extends PropertyKey,
  Null,
> = P extends FluentOperation
  ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> &
      PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null>
  : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;

export declare type DynamicModelExtensionFnResultBase<
  TypeMap extends TypeMapDef,
  M extends PropertyKey,
  A,
  P extends PropertyKey,
> = GetResult<TypeMap["model"][M]["payload"], A, P & Operation, TypeMap["globalOmitOptions"]>;

export declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends
  | "findUnique"
  | "findFirst"
  ? null
  : never;

export declare type DynamicModelExtensionOperationFn<
  TypeMap extends TypeMapDef,
  M extends PropertyKey,
  P extends PropertyKey,
> = {} extends TypeMap["model"][M]["operations"][P]["args"]
  ? <A extends TypeMap["model"][M]["operations"][P]["args"]>(
      args?: Exact<A, TypeMap["model"][M]["operations"][P]["args"]>
    ) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>
  : <A extends TypeMap["model"][M]["operations"][P]["args"]>(
      args: Exact<A, TypeMap["model"][M]["operations"][P]["args"]>
    ) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;

export declare type DynamicModelExtensionThis<
  TypeMap extends TypeMapDef,
  M extends PropertyKey,
  ExtArgs extends Record<string, any>,
> = {
  [P in keyof ExtArgs["model"][Uncapitalize<M & string>]]: Return<
    ExtArgs["model"][Uncapitalize<M & string>][P]
  >;
} & {
  [P in Exclude<
    keyof TypeMap["model"][M]["operations"],
    keyof ExtArgs["model"][Uncapitalize<M & string>]
  >]: DynamicModelExtensionOperationFn<TypeMap, M, P>;
} & {
  [P in Exclude<
    "fields",
    keyof ExtArgs["model"][Uncapitalize<M & string>]
  >]: TypeMap["model"][M]["fields"];
} & {
  [K: symbol]: {
    types: TypeMap["model"][M];
  };
};

/** Query */
export declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {
  [K in keyof Q_]: K extends "$allOperations"
    ? (args: {
        model?: string;
        operation: string;
        args: any;
        query: (args: any) => PrismaPromise<any>;
      }) => Promise<any>
    : K extends "$allModels"
      ? {
          [P in
            | keyof Q_[K]
            | keyof TypeMap["model"][keyof TypeMap["model"]]["operations"]
            | "$allOperations"]?: P extends "$allOperations"
            ? DynamicQueryExtensionCb<
                TypeMap,
                "model",
                keyof TypeMap["model"],
                keyof TypeMap["model"][keyof TypeMap["model"]]["operations"]
              >
            : P extends keyof TypeMap["model"][keyof TypeMap["model"]]["operations"]
              ? DynamicQueryExtensionCb<TypeMap, "model", keyof TypeMap["model"], P>
              : never;
        }
      : K extends TypeMap["meta"]["modelProps"]
        ? {
            [P in
              | keyof Q_[K]
              | keyof TypeMap["model"][ModelKey<TypeMap, K>]["operations"]
              | "$allOperations"]?: P extends "$allOperations"
              ? DynamicQueryExtensionCb<
                  TypeMap,
                  "model",
                  ModelKey<TypeMap, K>,
                  keyof TypeMap["model"][ModelKey<TypeMap, K>]["operations"]
                >
              : P extends keyof TypeMap["model"][ModelKey<TypeMap, K>]["operations"]
                ? DynamicQueryExtensionCb<TypeMap, "model", ModelKey<TypeMap, K>, P>
                : never;
          }
        : K extends keyof TypeMap["other"]["operations"]
          ? DynamicQueryExtensionCb<[TypeMap], 0, "other", K>
          : never;
};

export declare type DynamicQueryExtensionCb<
  TypeMap extends TypeMapDef,
  _0 extends PropertyKey,
  _1 extends PropertyKey,
  _2 extends PropertyKey,
> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(
  args: A
) => Promise<TypeMap[_0][_1][_2]["result"]>;

export declare type DynamicQueryExtensionCbArgs<
  TypeMap extends TypeMapDef,
  _0 extends PropertyKey,
  _1 extends PropertyKey,
  _2 extends PropertyKey,
> = (_1 extends unknown
  ? _2 extends unknown
    ? {
        args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;
        model: _0 extends 0 ? undefined : _1;
        operation: _2;
        query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(
          args: A
        ) => PrismaPromise<TypeMap[_0][_1]["operations"][_2]["result"]>;
      }
    : never
  : never) & {
  query: (
    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>
  ) => PrismaPromise<TypeMap[_0][_1]["operations"][_2]["result"]>;
};

export declare type DynamicQueryExtensionCbArgsArgs<
  TypeMap extends TypeMapDef,
  _0 extends PropertyKey,
  _1 extends PropertyKey,
  _2 extends PropertyKey,
> = _2 extends "$queryRaw" | "$executeRaw" ? Sql : TypeMap[_0][_1]["operations"][_2]["args"];

/** Result */
export declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {
  [K in keyof R_]: {
    [P in keyof R_[K]]?: {
      needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;
      compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;
    };
  };
};

export declare type DynamicResultExtensionData<
  TypeMap extends TypeMapDef,
  M extends PropertyKey,
  S,
> = GetFindResult<
  TypeMap["model"][M]["payload"],
  {
    select: S;
  },
  {}
>;

export declare type DynamicResultExtensionNeeds<
  TypeMap extends TypeMapDef,
  M extends PropertyKey,
  S,
> = {
  [K in keyof S]: K extends keyof TypeMap["model"][M]["payload"]["scalars"] ? S[K] : never;
} & {
  [N in keyof TypeMap["model"][M]["payload"]["scalars"]]?: boolean;
};

/**
 * Placeholder value for "no text".
 */
export declare const empty: Sql;

export declare type EmptyToUnknown<T> = T;

declare interface Engine<InteractiveTransactionPayload = unknown> {
  /** The name of the engine. This is meant to be consumed externally */
  readonly name: string;
  onBeforeExit(callback: () => Promise<void>): void;
  start(): Promise<void>;
  stop(): Promise<void>;
  version(forceRun?: boolean): Promise<string> | string;
  request<T>(
    query: JsonQuery,
    options: RequestOptions<InteractiveTransactionPayload>
  ): Promise<QueryEngineResultData<T>>;
  requestBatch<T>(
    queries: JsonQuery[],
    options: RequestBatchOptions<InteractiveTransactionPayload>
  ): Promise<BatchQueryEngineResult<T>[]>;
  transaction(
    action: "start",
    headers: Transaction_2.TransactionHeaders,
    options: Transaction_2.Options
  ): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;
  transaction(
    action: "commit",
    headers: Transaction_2.TransactionHeaders,
    info: Transaction_2.InteractiveTransactionInfo<unknown>
  ): Promise<void>;
  transaction(
    action: "rollback",
    headers: Transaction_2.TransactionHeaders,
    info: Transaction_2.InteractiveTransactionInfo<unknown>
  ): Promise<void>;
  metrics(options: MetricsOptionsJson): Promise<Metrics>;
  metrics(options: MetricsOptionsPrometheus): Promise<string>;
  applyPendingMigrations(): Promise<void>;
}

declare interface EngineConfig {
  cwd: string;
  dirname: string;
  enableDebugLogs?: boolean;
  allowTriggerPanic?: boolean;
  prismaPath?: string;
  generator?: GeneratorConfig;
  /**
   * @remarks this field is used internally by Policy, do not rename or remove
   */
  overrideDatasources: Datasources;
  showColors?: boolean;
  logQueries?: boolean;
  logLevel?: "info" | "warn";
  env: Record<string, string>;
  flags?: string[];
  clientVersion: string;
  engineVersion: string;
  previewFeatures?: string[];
  engineEndpoint?: string;
  activeProvider?: string;
  logEmitter: LogEmitter;
  transactionOptions: Transaction_2.Options;
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.
   * If set, this is only used in the library engine, and all queries would be performed through it,
   * rather than Prisma's Rust drivers.
   * @remarks only used by LibraryEngine.ts
   */
  adapter?: SqlDriverAdapterFactory;
  /**
   * The contents of the schema encoded into a string
   */
  inlineSchema: string;
  /**
   * The contents of the datasource url saved in a string
   * @remarks only used by DataProxyEngine.ts
   * @remarks this field is used internally by Policy, do not rename or remove
   */
  inlineDatasources: GetPrismaClientConfig["inlineDatasources"];
  /**
   * The string hash that was produced for a given schema
   * @remarks only used by DataProxyEngine.ts
   */
  inlineSchemaHash: string;
  /**
   * The helper for interaction with OTEL tracing
   * @remarks enabling is determined by the client and @prisma/instrumentation package
   */
  tracingHelper: TracingHelper;
  /**
   * Information about whether we have not found a schema.prisma file in the
   * default location, and that we fell back to finding the schema.prisma file
   * in the current working directory. This usually means it has been bundled.
   */
  isBundled?: boolean;
  /**
   * Web Assembly module loading configuration
   */
  engineWasm?: EngineWasmLoadingConfig;
  compilerWasm?: CompilerWasmLoadingConfig;
  /**
   * Allows Accelerate to use runtime utilities from the client. These are
   * necessary for the AccelerateEngine to function correctly.
   */
  accelerateUtils?: {
    resolveDatasourceUrl: typeof resolveDatasourceUrl;
    getBatchRequestPayload: typeof getBatchRequestPayload;
    prismaGraphQLToJSError: typeof prismaGraphQLToJSError;
    PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;
    PrismaClientInitializationError: typeof PrismaClientInitializationError;
    PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;
    debug: (...args: any[]) => void;
    engineVersion: string;
    clientVersion: string;
  };
}

declare type EngineEvent<E extends EngineEventType> = E extends QueryEventType
  ? QueryEvent
  : LogEvent;

declare type EngineEventType = QueryEventType | LogEventType;

declare type EngineSpan = {
  id: EngineSpanId;
  parentId: string | null;
  name: string;
  startTime: HrTime;
  endTime: HrTime;
  kind: EngineSpanKind;
  attributes?: Record<string, unknown>;
  links?: EngineSpanId[];
};

declare type EngineSpanId = string;

declare type EngineSpanKind = "client" | "internal";

declare type EngineWasmLoadingConfig = {
  /**
   * WASM-bindgen runtime for corresponding module
   */
  getRuntime: () => Promise<{
    __wbg_set_wasm(exports: unknown): void;
    QueryEngine: QueryEngineConstructor;
  }>;
  /**
   * Loads the raw wasm module for the wasm query engine. This configuration is
   * generated specifically for each type of client, eg. Node.js client and Edge
   * clients will have different implementations.
   * @remarks this is a callback on purpose, we only load the wasm if needed.
   * @remarks only used by LibraryEngine
   */
  getQueryEngineWasmModule: () => Promise<unknown>;
};

declare type EnumValue = ReadonlyDeep_2<{
  name: string;
  dbName: string | null;
}>;

declare type EnvPaths = {
  rootEnvPath: string | null;
  schemaEnvPath: string | undefined;
};

declare interface EnvValue {
  fromEnvVar: null | string;
  value: null | string;
}

export declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends <T>() => T extends B
  ? 1
  : 2
  ? 1
  : 0;

declare type Error_2 =
  | {
      kind: "GenericJs";
      id: number;
    }
  | {
      kind: "UnsupportedNativeDataType";
      type: string;
    }
  | {
      kind: "InvalidIsolationLevel";
      level: string;
    }
  | {
      kind: "LengthMismatch";
      column?: string;
    }
  | {
      kind: "UniqueConstraintViolation";
      fields: string[];
    }
  | {
      kind: "NullConstraintViolation";
      fields: string[];
    }
  | {
      kind: "ForeignKeyConstraintViolation";
      constraint?:
        | {
            fields: string[];
          }
        | {
            index: string;
          }
        | {
            foreignKey: {};
          };
    }
  | {
      kind: "DatabaseDoesNotExist";
      db?: string;
    }
  | {
      kind: "DatabaseAlreadyExists";
      db?: string;
    }
  | {
      kind: "DatabaseAccessDenied";
      db?: string;
    }
  | {
      kind: "AuthenticationFailed";
      user?: string;
    }
  | {
      kind: "TransactionWriteConflict";
    }
  | {
      kind: "TableDoesNotExist";
      table?: string;
    }
  | {
      kind: "ColumnNotFound";
      column?: string;
    }
  | {
      kind: "TooManyConnections";
      cause: string;
    }
  | {
      kind: "SocketTimeout";
    }
  | {
      kind: "postgres";
      code: string;
      severity: string;
      message: string;
      detail: string | undefined;
      column: string | undefined;
      hint: string | undefined;
    }
  | {
      kind: "mysql";
      code: number;
      message: string;
      state: string;
    }
  | {
      kind: "sqlite";
      /**
       * Sqlite extended error code: https://www.sqlite.org/rescode.html
       */
      extendedCode: number;
      message: string;
    };

declare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R>
  ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>>
  : T extends (...args: infer A) => infer R
    ? (...args: A) => Result_4<ErrorCapturingInterface<R>>
    : T;

declare type ErrorCapturingInterface<T> = {
  [K in keyof T]: ErrorCapturingFunction<T[K]>;
};

declare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {
  readonly errorRegistry: ErrorRegistry;
}

declare type ErrorFormat = "pretty" | "colorless" | "minimal";

declare type ErrorRecord = {
  error: unknown;
};

declare interface ErrorRegistry {
  consumeError(id: number): ErrorRecord | undefined;
}

declare interface ErrorWithBatchIndex {
  batchRequestIdx?: number;
}

declare type EventCallback<E extends ExtendedEventType> = [E] extends ["beforeExit"]
  ? () => Promise<void>
  : [E] extends [LogLevel]
    ? (event: EngineEvent<E>) => void
    : never;

export declare type Exact<A, W> =
  | (A extends unknown
      ? W extends A
        ? {
            [K in keyof A]: Exact<A[K], W[K]>;
          }
        : W
      : never)
  | (A extends Narrowable ? A : never);

/**
 * Defines Exception.
 *
 * string or an object with one of (message or name or code) and optional stack
 */
declare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;

declare interface ExceptionWithCode {
  code: string | number;
  name?: string;
  message?: string;
  stack?: string;
}

declare interface ExceptionWithMessage {
  code?: string | number;
  message: string;
  name?: string;
  stack?: string;
}

declare interface ExceptionWithName {
  code?: string | number;
  message?: string;
  name: string;
  stack?: string;
}

declare type ExtendedEventType = LogLevel | "beforeExit";

declare type ExtendedSpanOptions = SpanOptions & {
  /** The name of the span */
  name: string;
  internal?: boolean;
  middleware?: boolean;
  /** Whether it propagates context (?=true) */
  active?: boolean;
  /** The context to append the span to */
  context?: Context;
};

/** $extends, defineExtension */
export declare interface ExtendsHook<
  Variant extends "extends" | "define",
  TypeMapCb extends TypeMapCbDef,
  ExtArgs extends Record<string, any>,
  TypeMap extends TypeMapDef = Call<
    TypeMapCb,
    {
      extArgs: ExtArgs;
    }
  >,
> {
  extArgs: ExtArgs;
  <
    R_ extends {
      [K in TypeMap["meta"]["modelProps"] | "$allModels"]?: unknown;
    },
    R,
    M_ extends {
      [K in TypeMap["meta"]["modelProps"] | "$allModels"]?: unknown;
    },
    M,
    Q_ extends {
      [K in
        | TypeMap["meta"]["modelProps"]
        | "$allModels"
        | keyof TypeMap["other"]["operations"]
        | "$allOperations"]?: unknown;
    },
    C_ extends {
      [K in string]?: unknown;
    },
    C,
    Args extends InternalArgs = InternalArgs<R, M, {}, C>,
    MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>,
  >(
    extension:
      | ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {
          $extends: {
            extArgs: Args;
          };
        })
      | {
          name?: string;
          query?: DynamicQueryExtensionArgs<Q_, TypeMap>;
          result?: DynamicResultExtensionArgs<R_, TypeMap> & R;
          model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;
          client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;
        }
  ): {
    extends: DynamicClientExtensionThis<
      Call<
        TypeMapCb,
        {
          extArgs: MergedArgs;
        }
      >,
      TypeMapCb,
      MergedArgs
    >;
    define: (client: any) => {
      $extends: {
        extArgs: Args;
      };
    };
  }[Variant];
}

export declare type ExtensionArgs = Optional<RequiredExtensionArgs>;

declare namespace Extensions {
  export { defineExtension, getExtensionContext };
}
export { Extensions };

declare namespace Extensions_2 {
  export {
    InternalArgs,
    DefaultArgs,
    GetPayloadResultExtensionKeys,
    GetPayloadResultExtensionObject,
    GetPayloadResult,
    GetSelect,
    GetOmit,
    DynamicQueryExtensionArgs,
    DynamicQueryExtensionCb,
    DynamicQueryExtensionCbArgs,
    DynamicQueryExtensionCbArgsArgs,
    DynamicResultExtensionArgs,
    DynamicResultExtensionNeeds,
    DynamicResultExtensionData,
    DynamicModelExtensionArgs,
    DynamicModelExtensionThis,
    DynamicModelExtensionOperationFn,
    DynamicModelExtensionFnResult,
    DynamicModelExtensionFnResultBase,
    DynamicModelExtensionFluentApi,
    DynamicModelExtensionFnResultNull,
    DynamicClientExtensionArgs,
    DynamicClientExtensionThis,
    ClientBuiltInProp,
    DynamicClientExtensionThisBuiltin,
    ExtendsHook,
    MergeExtArgs,
    AllModelsToStringIndex,
    TypeMapDef,
    DevTypeMapDef,
    DevTypeMapFnDef,
    ClientOptionDef,
    ClientOtherOps,
    TypeMapCbDef,
    ModelKey,
    RequiredExtensionArgs as UserArgs,
  };
}

export declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {
  omit: {
    [K in ModelName]: infer GlobalOmit;
  };
}
  ? GlobalOmit
  : {};

declare type Field = ReadonlyDeep_2<{
  kind: FieldKind;
  name: string;
  isRequired: boolean;
  isList: boolean;
  isUnique: boolean;
  isId: boolean;
  isReadOnly: boolean;
  isGenerated?: boolean;
  isUpdatedAt?: boolean;
  /**
   * Describes the data type in the same the way it is defined in the Prisma schema:
   * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName
   */
  type: string;
  /**
   * Native database type, if specified.
   * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,
   * `@db.Text` is encoded as `['Text', []]`.
   */
  nativeType?: [string, string[]] | null;
  dbName?: string | null;
  hasDefaultValue: boolean;
  default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];
  relationFromFields?: string[];
  relationToFields?: string[];
  relationOnDelete?: string;
  relationOnUpdate?: string;
  relationName?: string;
  documentation?: string;
}>;

declare type FieldDefault = ReadonlyDeep_2<{
  name: string;
  args: Array<string | number>;
}>;

declare type FieldDefaultScalar = string | boolean | number;

declare type FieldKind = "scalar" | "object" | "enum" | "unsupported";

declare type FieldLocation =
  | "scalar"
  | "inputObjectTypes"
  | "outputObjectTypes"
  | "enumTypes"
  | "fieldRefTypes";

declare type FieldNamespace = "model" | "prisma";

/**
 * A reference to a specific field of a specific model
 */
export declare interface FieldRef<Model, FieldType> {
  readonly modelName: Model;
  readonly name: string;
  readonly typeName: FieldType;
  readonly isList: boolean;
}

declare type FieldRefAllowType = TypeRef<"scalar" | "enumTypes">;

declare type FieldRefType = ReadonlyDeep_2<{
  name: string;
  allowTypes: FieldRefAllowType[];
  fields: SchemaArg[];
}>;

declare type FluentOperation =
  | "findUnique"
  | "findUniqueOrThrow"
  | "findFirst"
  | "findFirstOrThrow"
  | "create"
  | "update"
  | "upsert"
  | "delete";

export declare interface Fn<Params = unknown, Returns = unknown> {
  params: Params;
  returns: Returns;
}

declare interface GeneratorConfig {
  name: string;
  output: EnvValue | null;
  isCustomOutput?: boolean;
  provider: EnvValue;
  config: {
    /** `output` is a reserved name and will only be available directly at `generator.output` */
    output?: never;
    /** `provider` is a reserved name and will only be available directly at `generator.provider` */
    provider?: never;
    /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */
    binaryTargets?: never;
    /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */
    previewFeatures?: never;
  } & {
    [key: string]: string | string[] | undefined;
  };
  binaryTargets: BinaryTargetsEnvValue[];
  previewFeatures: string[];
  envPaths?: EnvPaths;
  sourceFilePath: string;
}

export declare type GetAggregateResult<P extends OperationPayload, A> = {
  [K in keyof A as K extends Aggregate ? K : never]: K extends "_count"
    ? A[K] extends true
      ? number
      : Count<A[K]>
    : {
        [J in keyof A[K] & string]: P["scalars"][J] | null;
      };
};

declare function getBatchRequestPayload(
  batch: JsonQuery[],
  transaction?: TransactionOptions_3<unknown>
): QueryEngineBatchRequest;

export declare type GetBatchResult = {
  count: number;
};

export declare type GetCountResult<A> = A extends {
  select: infer S;
}
  ? S extends true
    ? number
    : Count<S>
  : number;

declare function getExtensionContext<T>(that: T): Context_2<T>;

export declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<
  A,
  any
> extends 1
  ? DefaultSelection<P, A, GlobalOmitOptions>
  : A extends
        | ({
            select: infer S extends object;
          } & Record<string, unknown>)
        | ({
            include: infer I extends object;
          } & Record<string, unknown>)
    ? {
        [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null
          ? never
          : K]: (S & I)[K] extends object
          ? P extends SelectablePayloadFields<K, (infer O)[]>
            ? O extends OperationPayload
              ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[]
              : never
            : P extends SelectablePayloadFields<K, infer O | null>
              ? O extends OperationPayload
                ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | (SelectField<P, K> & null)
                : never
              : K extends "_count"
                ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>>
                : never
          : P extends SelectablePayloadFields<K, (infer O)[]>
            ? O extends OperationPayload
              ? DefaultSelection<O, {}, GlobalOmitOptions>[]
              : never
            : P extends SelectablePayloadFields<K, infer O | null>
              ? O extends OperationPayload
                ? DefaultSelection<O, {}, GlobalOmitOptions> | (SelectField<P, K> & null)
                : never
              : P extends {
                    scalars: {
                      [k in K]: infer O;
                    };
                  }
                ? O
                : K extends "_count"
                  ? Count<P["objects"]>
                  : never;
      } & (A extends {
        include: any;
      } & Record<string, unknown>
        ? DefaultSelection<
            P,
            A & {
              omit: A["omit"];
            },
            GlobalOmitOptions
          >
        : unknown)
    : DefaultSelection<P, A, GlobalOmitOptions>;

export declare type GetGroupByResult<P extends OperationPayload, A> = A extends {
  by: string[];
}
  ? Array<
      GetAggregateResult<P, A> & {
        [K in A["by"][number]]: P["scalars"][K];
      }
    >
  : A extends {
        by: string;
      }
    ? Array<
        GetAggregateResult<P, A> & {
          [K in A["by"]]: P["scalars"][K];
        }
      >
    : {}[];

export declare type GetOmit<
  BaseKeys extends string,
  R extends InternalArgs["result"][string],
  ExtraType = never,
> = {
  [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;
};

export declare type GetPayloadResult<
  Base extends Record<any, any>,
  R extends InternalArgs["result"][string],
> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;

export declare type GetPayloadResultExtensionKeys<
  R extends InternalArgs["result"][string],
  KR extends keyof R = string extends keyof R ? never : keyof R,
> = KR;

export declare type GetPayloadResultExtensionObject<R extends InternalArgs["result"][string]> = {
  [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {
    compute: (...args: any) => infer C;
  }
    ? C
    : never;
};

export declare function getPrismaClient(config: GetPrismaClientConfig): {
  new (
    optionsArg?: PrismaClientOptions
  ): {
    _originalClient: any;
    _runtimeDataModel: RuntimeDataModel;
    _requestHandler: RequestHandler;
    _connectionPromise?: Promise<any> | undefined;
    _disconnectionPromise?: Promise<any> | undefined;
    _engineConfig: EngineConfig;
    _accelerateEngineConfig: AccelerateEngineConfig;
    _clientVersion: string;
    _errorFormat: ErrorFormat;
    _tracingHelper: TracingHelper;
    _middlewares: MiddlewareHandler<QueryMiddleware>;
    _previewFeatures: string[];
    _activeProvider: string;
    _globalOmit?: GlobalOmitOptions | undefined;
    _extensions: MergedExtensionsList;
    /**
     * @remarks This is used internally by Policy, do not rename or remove
     */
    _engine: Engine;
    /**
     * A fully constructed/applied Client that references the parent
     * PrismaClient. This is used for Client extensions only.
     */
    _appliedParent: any;
    _createPrismaPromise: PrismaPromiseFactory;
    /**
     * Hook a middleware into the client
     * @param middleware to hook
     */
    $use(middleware: QueryMiddleware): void;
    $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;
    $connect(): Promise<void>;
    /**
     * Disconnect from the database
     */
    $disconnect(): Promise<void>;
    /**
     * Executes a raw query and always returns a number
     */
    $executeRawInternal(
      transaction: PrismaPromiseTransaction | undefined,
      clientMethod: string,
      args: RawQueryArgs,
      middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>
    ): Promise<number>;
    /**
     * Executes a raw query provided through a safe tag function
     * @see https://github.com/prisma/prisma/issues/7142
     *
     * @param query
     * @param values
     * @returns
     */
    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;
    /**
     * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections
     * @see https://github.com/prisma/prisma/issues/7142
     *
     * @param query
     * @param values
     * @returns
     */
    $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;
    /**
     * Executes a raw command only for MongoDB
     *
     * @param command
     * @returns
     */
    $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;
    /**
     * Executes a raw query and returns selected data
     */
    $queryRawInternal(
      transaction: PrismaPromiseTransaction | undefined,
      clientMethod: string,
      args: RawQueryArgs,
      middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>
    ): Promise<any>;
    /**
     * Executes a raw query provided through a safe tag function
     * @see https://github.com/prisma/prisma/issues/7142
     *
     * @param query
     * @param values
     * @returns
     */
    $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;
    /**
     * Counterpart to $queryRaw, that returns strongly typed results
     * @param typedSql
     */
    $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;
    /**
     * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections
     * @see https://github.com/prisma/prisma/issues/7142
     *
     * @param query
     * @param values
     * @returns
     */
    $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;
    /**
     * Execute a batch of requests in a transaction
     * @param requests
     * @param options
     */
    _transactionWithArray({
      promises,
      options,
    }: {
      promises: Array<PrismaPromise_2<any>>;
      options?: BatchTransactionOptions;
    }): Promise<any>;
    /**
     * Perform a long-running transaction
     * @param callback
     * @param options
     * @returns
     */
    _transactionWithCallback({
      callback,
      options,
    }: {
      callback: (client: Client) => Promise<unknown>;
      options?: TransactionOptions_2;
    }): Promise<unknown>;
    _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;
    /**
     * Execute queries within a transaction
     * @param input a callback or a query list
     * @param options to set timeouts (callback)
     * @returns
     */
    $transaction(input: any, options?: any): Promise<any>;
    /**
     * Runs the middlewares over params before executing a request
     * @param internalParams
     * @returns
     */
    _request(internalParams: InternalRequestParams): Promise<any>;
    _executeRequest({
      args,
      clientMethod,
      dataPath,
      callsite,
      action,
      model,
      argsMapper,
      transaction,
      unpacker,
      otelParentCtx,
      customDataProxyFetch,
    }: InternalRequestParams): Promise<any>;
    $metrics: MetricsClient;
    /**
     * Shortcut for checking a preview flag
     * @param feature preview flag
     * @returns
     */
    _hasPreviewFlag(feature: string): boolean;
    $applyPendingMigrations(): Promise<void>;
    $extends: typeof $extends;
    readonly [Symbol.toStringTag]: string;
  };
};

/**
 * Config that is stored into the generated client. When the generated client is
 * loaded, this same config is passed to {@link getPrismaClient} which creates a
 * closure with that config around a non-instantiated [[PrismaClient]].
 */
export declare type GetPrismaClientConfig = {
  runtimeDataModel: RuntimeDataModel;
  generator?: GeneratorConfig;
  relativeEnvPaths?: {
    rootEnvPath?: string | null;
    schemaEnvPath?: string | null;
  };
  relativePath: string;
  dirname: string;
  clientVersion: string;
  engineVersion: string;
  datasourceNames: string[];
  activeProvider: ActiveConnectorType;
  /**
   * The contents of the schema encoded into a string
   * @remarks only used for the purpose of data proxy
   */
  inlineSchema: string;
  /**
   * A special env object just for the data proxy edge runtime.
   * Allows bundlers to inject their own env variables (Vercel).
   * Allows platforms to declare global variables as env (Workers).
   * @remarks only used for the purpose of data proxy
   */
  injectableEdgeEnv?: () => LoadedEnv;
  /**
   * The contents of the datasource url saved in a string.
   * This can either be an env var name or connection string.
   * It is needed by the client to connect to the Data Proxy.
   * @remarks only used for the purpose of data proxy
   */
  inlineDatasources: {
    [name in string]: {
      url: EnvValue;
    };
  };
  /**
   * The string hash that was produced for a given schema
   * @remarks only used for the purpose of data proxy
   */
  inlineSchemaHash: string;
  /**
   * A marker to indicate that the client was not generated via `prisma
   * generate` but was generated via `generate --postinstall` script instead.
   * @remarks used to error for Vercel/Netlify for schema caching issues
   */
  postinstall?: boolean;
  /**
   * Information about the CI where the Prisma Client has been generated. The
   * name of the CI environment is stored at generation time because CI
   * information is not always available at runtime. Moreover, the edge client
   * has no notion of environment variables, so this works around that.
   * @remarks used to error for Vercel/Netlify for schema caching issues
   */
  ciName?: string;
  /**
   * Information about whether we have not found a schema.prisma file in the
   * default location, and that we fell back to finding the schema.prisma file
   * in the current working directory. This usually means it has been bundled.
   */
  isBundled?: boolean;
  /**
   * A boolean that is `false` when the client was generated with --no-engine. At
   * runtime, this means the client will be bound to be using the Data Proxy.
   */
  copyEngine?: boolean;
  /**
   * Optional wasm loading configuration
   */
  engineWasm?: EngineWasmLoadingConfig;
  compilerWasm?: CompilerWasmLoadingConfig;
};

export declare type GetResult<
  Payload extends OperationPayload,
  Args,
  OperationName extends Operation = "findUniqueOrThrow",
  GlobalOmitOptions = {},
> = {
  findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;
  findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;
  findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;
  findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;
  findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];
  create: GetFindResult<Payload, Args, GlobalOmitOptions>;
  createMany: GetBatchResult;
  createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];
  update: GetFindResult<Payload, Args, GlobalOmitOptions>;
  updateMany: GetBatchResult;
  updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];
  upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;
  delete: GetFindResult<Payload, Args, GlobalOmitOptions>;
  deleteMany: GetBatchResult;
  aggregate: GetAggregateResult<Payload, Args>;
  count: GetCountResult<Args>;
  groupBy: GetGroupByResult<Payload, Args>;
  $queryRaw: unknown;
  $queryRawTyped: unknown;
  $executeRaw: number;
  $queryRawUnsafe: unknown;
  $executeRawUnsafe: number;
  $runCommandRaw: JsonObject;
  findRaw: JsonObject;
  aggregateRaw: JsonObject;
}[OperationName];

export declare function getRuntime(): GetRuntimeOutput;

declare type GetRuntimeOutput = {
  id: RuntimeName;
  prettyName: string;
  isEdge: boolean;
};

export declare type GetSelect<
  Base extends Record<any, any>,
  R extends InternalArgs["result"][string],
  KR extends keyof R = string extends keyof R ? never : keyof R,
> = {
  [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];
};

declare type GlobalOmitOptions = {
  [modelName: string]: {
    [fieldName: string]: boolean;
  };
};

declare type HandleErrorParams = {
  args: JsArgs;
  error: any;
  clientMethod: string;
  callsite?: CallSite;
  transaction?: PrismaPromiseTransaction;
  modelName?: string;
  globalOmit?: GlobalOmitOptions;
};

declare type HrTime = [number, number];

/**
 * Defines High-Resolution Time.
 *
 * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 */
declare type HrTime_2 = [number, number];

declare type Index = ReadonlyDeep_2<{
  model: string;
  type: IndexType;
  isDefinedOnField: boolean;
  name?: string;
  dbName?: string;
  algorithm?: string;
  clustered?: boolean;
  fields: IndexField[];
}>;

declare type IndexField = ReadonlyDeep_2<{
  name: string;
  sortOrder?: SortOrder;
  length?: number;
  operatorClass?: string;
}>;

declare type IndexType = "id" | "normal" | "unique" | "fulltext";

/**
 * Matches a JSON array.
 * Unlike \`JsonArray\`, readonly arrays are assignable to this type.
 */
export declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

/**
 * Matches a JSON object.
 * Unlike \`JsonObject\`, this type allows undefined and read-only properties.
 */
export declare type InputJsonObject = {
  readonly [Key in string]?: InputJsonValue | null;
};

/**
 * Matches any valid value that can be used as an input for operations like
 * create and update as the value of a JSON field. Unlike \`JsonValue\`, this
 * type allows read-only arrays and read-only object properties and disallows
 * \`null\` at the top level.
 *
 * \`null\` cannot be used as the value of a JSON field because its meaning
 * would be ambiguous. Use \`Prisma.JsonNull\` to store the JSON null value or
 * \`Prisma.DbNull\` to clear the JSON value and set the field to the database
 * NULL value instead.
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
 */
export declare type InputJsonValue =
  | string
  | number
  | boolean
  | InputJsonObject
  | InputJsonArray
  | {
      toJSON(): unknown;
    };

declare type InputType = ReadonlyDeep_2<{
  name: string;
  constraints: {
    maxNumFields: number | null;
    minNumFields: number | null;
    fields?: string[];
  };
  meta?: {
    source?: string;
    grouping?: string;
  };
  fields: SchemaArg[];
}>;

declare type InputTypeRef = TypeRef<"scalar" | "inputObjectTypes" | "enumTypes" | "fieldRefTypes">;

declare type InteractiveTransactionInfo<Payload = unknown> = {
  /**
   * Transaction ID returned by the query engine.
   */
  id: string;
  /**
   * Arbitrary payload the meaning of which depends on the `Engine` implementation.
   * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.
   * In `LibraryEngine` and `BinaryEngine` it is currently not used.
   */
  payload: Payload;
};

declare type InteractiveTransactionOptions<Payload> =
  Transaction_2.InteractiveTransactionInfo<Payload>;

export declare type InternalArgs<
  R = {
    [K in string]: {
      [K in string]: unknown;
    };
  },
  M = {
    [K in string]: {
      [K in string]: unknown;
    };
  },
  Q = {
    [K in string]: {
      [K in string]: unknown;
    };
  },
  C = {
    [K in string]: unknown;
  },
> = {
  result: {
    [K in keyof R]: {
      [P in keyof R[K]]: () => R[K][P];
    };
  };
  model: {
    [K in keyof M]: {
      [P in keyof M[K]]: () => M[K][P];
    };
  };
  query: {
    [K in keyof Q]: {
      [P in keyof Q[K]]: () => Q[K][P];
    };
  };
  client: {
    [K in keyof C]: () => C[K];
  };
};

declare type InternalRequestParams = {
  /**
   * The original client method being called.
   * Even though the rootField / operation can be changed,
   * this method stays as it is, as it's what the user's
   * code looks like
   */
  clientMethod: string;
  /**
   * Name of js model that triggered the request. Might be used
   * for warnings or error messages
   */
  jsModelName?: string;
  callsite?: CallSite;
  transaction?: PrismaPromiseTransaction;
  unpacker?: Unpacker;
  otelParentCtx?: Context;
  /** Used to "desugar" a user input into an "expanded" one */
  argsMapper?: (args?: UserArgs_2) => UserArgs_2;
  /** Used to convert args for middleware and back */
  middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;
  /** Used for Accelerate client extension via Data Proxy */
  customDataProxyFetch?: CustomDataProxyFetch;
} & Omit<QueryMiddlewareParams, "runInTransaction">;

declare type IsolationLevel =
  | "READ UNCOMMITTED"
  | "READ COMMITTED"
  | "REPEATABLE READ"
  | "SNAPSHOT"
  | "SERIALIZABLE";

declare function isSkip(value: unknown): value is Skip;

export declare function isTypedSql(value: unknown): value is UnknownTypedSql;

export declare type ITXClientDenyList = (typeof denylist)[number];

export declare const itxClientDenyList: readonly (string | symbol)[];

declare interface Job {
  resolve: (data: any) => void;
  reject: (data: any) => void;
  request: any;
}

/**
 * Create a SQL query for a list of values.
 */
export declare function join(
  values: readonly RawValue[],
  separator?: string,
  prefix?: string,
  suffix?: string
): Sql;

export declare type JsArgs = {
  select?: Selection_2;
  include?: Selection_2;
  omit?: Omission;
  [argName: string]: JsInputValue;
};

export declare type JsInputValue =
  | null
  | undefined
  | string
  | number
  | boolean
  | bigint
  | Uint8Array
  | Date
  | DecimalJsLike
  | ObjectEnumValue
  | RawParameters
  | JsonConvertible
  | FieldRef<string, unknown>
  | JsInputValue[]
  | Skip
  | {
      [key: string]: JsInputValue;
    };

declare type JsonArgumentValue =
  | number
  | string
  | boolean
  | null
  | RawTaggedValue
  | JsonArgumentValue[]
  | {
      [key: string]: JsonArgumentValue;
    };

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}

export declare type JsonBatchQuery = {
  batch: JsonQuery[];
  transaction?: {
    isolationLevel?: IsolationLevel;
  };
};

export declare interface JsonConvertible {
  toJSON(): unknown;
}

declare type JsonFieldSelection = {
  arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;
  selection: JsonSelectionSet;
};

declare class JsonNull extends NullTypesEnumValue {
  #private;
}

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.
 */
export declare type JsonObject = {
  [Key in string]?: JsonValue;
};

export declare type JsonQuery = {
  modelName?: string;
  action: JsonQueryAction;
  query: JsonFieldSelection;
};

declare type JsonQueryAction =
  | "findUnique"
  | "findUniqueOrThrow"
  | "findFirst"
  | "findFirstOrThrow"
  | "findMany"
  | "createOne"
  | "createMany"
  | "createManyAndReturn"
  | "updateOne"
  | "updateMany"
  | "updateManyAndReturn"
  | "deleteOne"
  | "deleteMany"
  | "upsertOne"
  | "aggregate"
  | "groupBy"
  | "executeRaw"
  | "queryRaw"
  | "runCommandRaw"
  | "findRaw"
  | "aggregateRaw";

declare type JsonSelectionSet = {
  $scalars?: boolean;
  $composites?: boolean;
} & {
  [fieldName: string]: boolean | JsonFieldSelection;
};

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;

export declare type JsOutputValue =
  | null
  | string
  | number
  | boolean
  | bigint
  | Uint8Array
  | Date
  | Decimal
  | JsOutputValue[]
  | {
      [key: string]: JsOutputValue;
    };

export declare type JsPromise<T> = Promise<T> & {};

declare type KnownErrorParams = {
  code: string;
  clientVersion: string;
  meta?: Record<string, unknown>;
  batchRequestIdx?: number;
};

/**
 * A pointer from the current {@link Span} to another span in the same trace or
 * in a different trace.
 * Few examples of Link usage.
 * 1. Batch Processing: A batch of elements may contain elements associated
 *    with one or more traces/spans. Since there can only be one parent
 *    SpanContext, Link is used to keep reference to SpanContext of all
 *    elements in the batch.
 * 2. Public Endpoint: A SpanContext in incoming client request on a public
 *    endpoint is untrusted from service provider perspective. In such case it
 *    is advisable to start a new trace with appropriate sampling decision.
 *    However, it is desirable to associate incoming SpanContext to new trace
 *    initiated on service provider side so two traces (from Client and from
 *    Service Provider) can be correlated.
 */
declare interface Link {
  /** The {@link SpanContext} of a linked span. */
  context: SpanContext;
  /** A set of {@link SpanAttributes} on the link. */
  attributes?: SpanAttributes;
  /** Count of attributes of the link that were dropped due to collection limits */
  droppedAttributesCount?: number;
}

declare type LoadedEnv =
  | {
      message?: string;
      parsed: {
        [x: string]: string;
      };
    }
  | undefined;

declare type LocationInFile = {
  fileName: string;
  lineNumber: number | null;
  columnNumber: number | null;
};

declare type LogDefinition = {
  level: LogLevel;
  emit: "stdout" | "event";
};

/**
 * Typings for the events we emit.
 *
 * @remarks
 * If this is updated, our edge runtime shim needs to be updated as well.
 */
declare type LogEmitter = {
  on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;
  emit(event: QueryEventType, payload: QueryEvent): boolean;
  emit(event: LogEventType, payload: LogEvent): boolean;
};

declare type LogEvent = {
  timestamp: Date;
  message: string;
  target: string;
};

declare type LogEventType = "info" | "warn" | "error";

declare type LogLevel = "info" | "query" | "warn" | "error";

/**
 * Generates more strict variant of an enum which, unlike regular enum,
 * throws on non-existing property access. This can be useful in following situations:
 * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input
 * - enum values are generated dynamically from DMMF.
 *
 * In that case, if using normal enums and no compile-time typechecking, using non-existing property
 * will result in `undefined` value being used, which will be accepted. Using strict enum
 * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.
 *
 * Note: if you need to check for existence of a value in the enum you can still use either
 * `in` operator or `hasOwnProperty` function.
 *
 * @param definition
 * @returns
 */
export declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(
  definition: T
): T;

export declare function makeTypedQueryFactory(
  sql: string
): (...values: any[]) => TypedSql<any[], unknown>;

declare type Mappings = ReadonlyDeep_2<{
  modelOperations: ModelMapping[];
  otherOperations: {
    read: string[];
    write: string[];
  };
}>;

/**
 * Class that holds the list of all extensions, applied to particular instance,
 * as well as resolved versions of the components that need to apply on
 * different levels. Main idea of this class: avoid re-resolving as much of the
 * stuff as possible when new extensions are added while also delaying the
 * resolve until the point it is actually needed. For example, computed fields
 * of the model won't be resolved unless the model is actually queried. Neither
 * adding extensions with `client` component only cause other components to
 * recompute.
 */
declare class MergedExtensionsList {
  private head?;
  private constructor();
  static empty(): MergedExtensionsList;
  static single(extension: ExtensionArgs): MergedExtensionsList;
  isEmpty(): boolean;
  append(extension: ExtensionArgs): MergedExtensionsList;
  getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;
  getAllClientExtensions(): ClientArg | undefined;
  getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;
  getAllQueryCallbacks(jsModelName: string, operation: string): any;
  getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];
}

export declare type MergeExtArgs<
  TypeMap extends TypeMapDef,
  ExtArgs extends Record<any, any>,
  Args extends Record<any, any>,
> = ComputeDeep<
  ExtArgs &
    Args &
    AllModelsToStringIndex<TypeMap, Args, "result"> &
    AllModelsToStringIndex<TypeMap, Args, "model">
>;

export declare type Metric<T> = {
  key: string;
  value: T;
  labels: Record<string, string>;
  description: string;
};

export declare type MetricHistogram = {
  buckets: MetricHistogramBucket[];
  sum: number;
  count: number;
};

export declare type MetricHistogramBucket = [maxValue: number, count: number];

export declare type Metrics = {
  counters: Metric<number>[];
  gauges: Metric<number>[];
  histograms: Metric<MetricHistogram>[];
};

export declare class MetricsClient {
  private _client;
  constructor(client: Client);
  /**
   * Returns all metrics gathered up to this point in prometheus format.
   * Result of this call can be exposed directly to prometheus scraping endpoint
   *
   * @param options
   * @returns
   */
  prometheus(options?: MetricsOptions): Promise<string>;
  /**
   * Returns all metrics gathered up to this point in prometheus format.
   *
   * @param options
   * @returns
   */
  json(options?: MetricsOptions): Promise<Metrics>;
}

declare type MetricsOptions = {
  /**
   * Labels to add to every metrics in key-value format
   */
  globalLabels?: Record<string, string>;
};

declare type MetricsOptionsCommon = {
  globalLabels?: Record<string, string>;
};

declare type MetricsOptionsJson = {
  format: "json";
} & MetricsOptionsCommon;

declare type MetricsOptionsPrometheus = {
  format: "prometheus";
} & MetricsOptionsCommon;

declare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {
  requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;
  middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;
};

declare class MiddlewareHandler<M extends Function> {
  private _middlewares;
  use(middleware: M): void;
  get(id: number): M | undefined;
  has(id: number): boolean;
  length(): number;
}

declare type Model = ReadonlyDeep_2<{
  name: string;
  dbName: string | null;
  schema: string | null;
  fields: Field[];
  uniqueFields: string[][];
  uniqueIndexes: uniqueIndex[];
  documentation?: string;
  primaryKey: PrimaryKey | null;
  isGenerated?: boolean;
}>;

declare enum ModelAction {
  findUnique = "findUnique",
  findUniqueOrThrow = "findUniqueOrThrow",
  findFirst = "findFirst",
  findFirstOrThrow = "findFirstOrThrow",
  findMany = "findMany",
  create = "create",
  createMany = "createMany",
  createManyAndReturn = "createManyAndReturn",
  update = "update",
  updateMany = "updateMany",
  updateManyAndReturn = "updateManyAndReturn",
  upsert = "upsert",
  delete = "delete",
  deleteMany = "deleteMany",
  groupBy = "groupBy",
  count = "count", // TODO: count does not actually exist in DMMF
  aggregate = "aggregate",
  findRaw = "findRaw",
  aggregateRaw = "aggregateRaw",
}

export declare type ModelArg = {
  [MethodName in string]: unknown;
};

export declare type ModelArgs = {
  model: {
    [ModelName in string]: ModelArg;
  };
};

export declare type ModelKey<
  TypeMap extends TypeMapDef,
  M extends PropertyKey,
> = M extends keyof TypeMap["model"] ? M : Capitalize<M & string>;

declare type ModelMapping = ReadonlyDeep_2<{
  model: string;
  plural: string;
  findUnique?: string | null;
  findUniqueOrThrow?: string | null;
  findFirst?: string | null;
  findFirstOrThrow?: string | null;
  findMany?: string | null;
  create?: string | null;
  createMany?: string | null;
  createManyAndReturn?: string | null;
  update?: string | null;
  updateMany?: string | null;
  updateManyAndReturn?: string | null;
  upsert?: string | null;
  delete?: string | null;
  deleteMany?: string | null;
  aggregate?: string | null;
  groupBy?: string | null;
  count?: string | null;
  findRaw?: string | null;
  aggregateRaw?: string | null;
}>;

export declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;

export declare type ModelQueryOptionsCbArgs = {
  model: string;
  operation: string;
  args: JsArgs;
  query: (args: JsArgs) => Promise<unknown>;
};

declare type MultiBatchResponse = {
  type: "multi";
  plans: object[];
};

export declare type NameArgs = {
  name?: string;
};

export declare type Narrow<A> =
  | {
      [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;
    }
  | (A extends Narrowable ? A : never);

export declare type Narrowable = string | number | bigint | boolean | [];

export declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;

declare class NullTypesEnumValue extends ObjectEnumValue {
  _getNamespace(): string;
}

/**
 * Base class for unique values of object-valued enums.
 */
export declare abstract class ObjectEnumValue {
  constructor(arg?: symbol);
  abstract _getNamespace(): string;
  _getName(): string;
  toString(): string;
}

export declare const objectEnumValues: {
  classes: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };
  instances: {
    DbNull: DbNull;
    JsonNull: JsonNull;
    AnyNull: AnyNull;
  };
};

declare const officialPrismaAdapters: readonly [
  "@prisma/adapter-planetscale",
  "@prisma/adapter-neon",
  "@prisma/adapter-libsql",
  "@prisma/adapter-d1",
  "@prisma/adapter-pg",
  "@prisma/adapter-pg-worker",
];

export declare type Omission = Record<string, boolean | Skip>;

declare type Omit_2<T, K extends string | number | symbol> = {
  [P in keyof T as P extends K ? never : P]: T[P];
};
export { Omit_2 as Omit };

export declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;

export declare type Operation =
  | "findFirst"
  | "findFirstOrThrow"
  | "findUnique"
  | "findUniqueOrThrow"
  | "findMany"
  | "create"
  | "createMany"
  | "createManyAndReturn"
  | "update"
  | "updateMany"
  | "updateManyAndReturn"
  | "upsert"
  | "delete"
  | "deleteMany"
  | "aggregate"
  | "count"
  | "groupBy"
  | "$queryRaw"
  | "$executeRaw"
  | "$queryRawUnsafe"
  | "$executeRawUnsafe"
  | "findRaw"
  | "aggregateRaw"
  | "$runCommandRaw";

export declare type OperationPayload = {
  name: string;
  scalars: {
    [ScalarName in string]: unknown;
  };
  objects: {
    [ObjectName in string]: unknown;
  };
  composites: {
    [CompositeName in string]: unknown;
  };
};

export declare type Optional<O, K extends keyof any = keyof O> = {
  [P in K & keyof O]?: O[P];
} & {
  [P in Exclude<keyof O, K>]: O[P];
};

export declare type OptionalFlat<T> = {
  [K in keyof T]?: T[K];
};

export declare type OptionalKeys<O> = {
  [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;
}[keyof O];

declare type Options = {
  clientVersion: string;
};

export declare type Or<A extends 1 | 0, B extends 1 | 0> = {
  0: {
    0: 0;
    1: 1;
  };
  1: {
    0: 1;
    1: 1;
  };
}[A][B];

declare type OtherOperationMappings = ReadonlyDeep_2<{
  read: string[];
  write: string[];
}>;

declare type OutputType = ReadonlyDeep_2<{
  name: string;
  fields: SchemaField[];
}>;

declare type OutputTypeRef = TypeRef<"scalar" | "outputObjectTypes" | "enumTypes">;

export declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;

export declare type Param<out $Type, $Value extends string> = {
  readonly name: $Value;
};

export declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;

export declare type Path<O, P, Default = never> = O extends unknown
  ? P extends [infer K, ...infer R]
    ? K extends keyof O
      ? Path<O[K], R>
      : Default
    : O
  : never;

export declare type Payload<T, F extends Operation = never> = T extends {
  [K: symbol]: {
    types: {
      payload: any;
    };
  };
}
  ? T[symbol]["types"]["payload"]
  : any;

export declare type PayloadToResult<
  P,
  O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>,
> = {
  [K in keyof O]?: O[K][K] extends any[]
    ? PayloadToResult<O[K][K][number]>[]
    : O[K][K] extends object
      ? PayloadToResult<O[K][K]>
      : O[K][K];
};

declare type Pick_2<T, K extends string | number | symbol> = {
  [P in keyof T as P extends K ? P : never]: T[P];
};
export { Pick_2 as Pick };

declare type PrimaryKey = ReadonlyDeep_2<{
  name: string | null;
  fields: string[];
}>;

export declare class PrismaClientInitializationError extends Error {
  clientVersion: string;
  errorCode?: string;
  retryable?: boolean;
  constructor(message: string, clientVersion: string, errorCode?: string);
  get [Symbol.toStringTag](): string;
}

export declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {
  code: string;
  meta?: Record<string, unknown>;
  clientVersion: string;
  batchRequestIdx?: number;
  constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);
  get [Symbol.toStringTag](): string;
}

export declare type PrismaClientOptions = {
  /**
   * Overwrites the primary datasource url from your schema.prisma file
   */
  datasourceUrl?: string;
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.
   */
  adapter?: SqlDriverAdapterFactory | null;
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources;
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat;
  /**
   * The default values for Transaction options
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: Transaction_2.Options;
  /**
   * @example
   * \`\`\`
   * // Defaults to stdout
   * log: ['query', 'info', 'warn']
   *
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   * ]
   * \`\`\`
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>;
  omit?: GlobalOmitOptions;
  /**
   * @internal
   * You probably don't want to use this. \`__internal\` is used by internal tooling.
   */
  __internal?: {
    debug?: boolean;
    engine?: {
      cwd?: string;
      binaryPath?: string;
      endpoint?: string;
      allowTriggerPanic?: boolean;
    };
    /** This can be used for testing purposes */
    configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;
  };
};

export declare class PrismaClientRustPanicError extends Error {
  clientVersion: string;
  constructor(message: string, clientVersion: string);
  get [Symbol.toStringTag](): string;
}

export declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {
  clientVersion: string;
  batchRequestIdx?: number;
  constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);
  get [Symbol.toStringTag](): string;
}

export declare class PrismaClientValidationError extends Error {
  name: string;
  clientVersion: string;
  constructor(message: string, { clientVersion }: Options);
  get [Symbol.toStringTag](): string;
}

declare function prismaGraphQLToJSError(
  { error, user_facing_error }: RequestError,
  clientVersion: string,
  activeProvider: string
): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;

declare type PrismaOperationSpec<TArgs, TAction = string> = {
  args: TArgs;
  action: TAction;
  model: string;
};

export declare interface PrismaPromise<T> extends Promise<T> {
  [Symbol.toStringTag]: "PrismaPromise";
}

/**
 * Prisma's `Promise` that is backwards-compatible. All additions on top of the
 * original `Promise` are optional so that it can be backwards-compatible.
 * @see [[createPrismaPromise]]
 */
declare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any>
  extends Promise<TResult> {
  get spec(): TSpec;
  /**
   * Extension of the original `.then` function
   * @param onfulfilled same as regular promises
   * @param onrejected same as regular promises
   * @param transaction transaction options
   */
  then<R1 = TResult, R2 = never>(
    onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>,
    onrejected?: (error: unknown) => R2 | PromiseLike<R2>,
    transaction?: PrismaPromiseTransaction
  ): Promise<R1 | R2>;
  /**
   * Extension of the original `.catch` function
   * @param onrejected same as regular promises
   * @param transaction transaction options
   */
  catch<R = never>(
    onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null,
    transaction?: PrismaPromiseTransaction
  ): Promise<TResult | R>;
  /**
   * Extension of the original `.finally` function
   * @param onfinally same as regular promises
   * @param transaction transaction options
   */
  finally(
    onfinally?: (() => void) | undefined | null,
    transaction?: PrismaPromiseTransaction
  ): Promise<TResult>;
  /**
   * Called when executing a batch of regular tx
   * @param transaction transaction options for batch tx
   */
  requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;
}

declare type PrismaPromiseBatchTransaction = {
  kind: "batch";
  id: number;
  isolationLevel?: IsolationLevel;
  index: number;
  lock: PromiseLike<void>;
};

declare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;

/**
 * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which
 * is essentially a proxy for `Promise`. All the transaction-compatible client
 * methods return one, this allows for pre-preparing queries without executing
 * them until `.then` is called. It's the foundation of Prisma's query batching.
 * @param callback that will be wrapped within our promise implementation
 * @see [[PrismaPromise]]
 * @returns
 */
declare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(
  callback: PrismaPromiseCallback,
  op?: T
) => PrismaPromise_2<unknown>;

declare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {
  kind: "itx";
  id: string;
  payload: PayloadType;
};

declare type PrismaPromiseTransaction<PayloadType = unknown> =
  | PrismaPromiseBatchTransaction
  | PrismaPromiseInteractiveTransaction<PayloadType>;

export declare const PrivateResultType: unique symbol;

declare type Provider = "mysql" | "postgres" | "sqlite";

declare namespace Public {
  export { validator };
}
export { Public };

declare namespace Public_2 {
  export { Args, Result, Payload, PrismaPromise, Operation, Exact };
}

declare type Query = ReadonlyDeep_2<{
  name: string;
  args: SchemaArg[];
  output: QueryOutput;
}>;

declare interface Queryable<Query, Result> extends AdapterInfo {
  /**
   * Execute a query and return its result.
   */
  queryRaw(params: Query): Promise<Result>;
  /**
   * Execute a query and return the number of affected rows.
   */
  executeRaw(params: Query): Promise<number>;
}

declare type QueryCompiler = {
  compile(request: string): string;
  compileBatch(batchRequest: string): BatchResponse;
};

declare interface QueryCompilerConstructor {
  new (options: QueryCompilerOptions): QueryCompiler;
}

declare type QueryCompilerOptions = {
  datamodel: string;
  provider: Provider;
  connectionInfo: ConnectionInfo;
};

declare type QueryEngineBatchGraphQLRequest = {
  batch: QueryEngineRequest[];
  transaction?: boolean;
  isolationLevel?: IsolationLevel;
};

declare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;

declare type QueryEngineConfig = {
  datamodel: string;
  configDir: string;
  logQueries: boolean;
  ignoreEnvVarErrors: boolean;
  datasourceOverrides: Record<string, string>;
  env: Record<string, string | undefined>;
  logLevel: QueryEngineLogLevel;
  engineProtocol: QueryEngineProtocol;
  enableTracing: boolean;
};

declare interface QueryEngineConstructor {
  new (
    config: QueryEngineConfig,
    logger: (log: string) => void,
    adapter?: ErrorCapturingSqlDriverAdapter
  ): QueryEngineInstance;
}

declare type QueryEngineInstance = {
  connect(headers: string, requestId: string): Promise<void>;
  disconnect(headers: string, requestId: string): Promise<void>;
  /**
   * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`
   * @param headersStr JSON.stringified `QueryEngineRequestHeaders`
   */
  query(
    requestStr: string,
    headersStr: string,
    transactionId: string | undefined,
    requestId: string
  ): Promise<string>;
  sdlSchema?(): Promise<string>;
  startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;
  commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;
  rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;
  metrics?(options: string): Promise<string>;
  applyPendingMigrations?(): Promise<void>;
  trace(requestId: string): Promise<string | null>;
};

declare type QueryEngineLogLevel = "trace" | "debug" | "info" | "warn" | "error" | "off";

declare type QueryEngineProtocol = "graphql" | "json";

declare type QueryEngineRequest = {
  query: string;
  variables: Object;
};

declare type QueryEngineResultData<T> = {
  data: T;
};

declare type QueryEvent = {
  timestamp: Date;
  query: string;
  params: string;
  duration: number;
  target: string;
};

declare type QueryEventType = "query";

declare type QueryIntrospectionBuiltinType =
  | "int"
  | "bigint"
  | "float"
  | "double"
  | "string"
  | "enum"
  | "bytes"
  | "bool"
  | "char"
  | "decimal"
  | "json"
  | "xml"
  | "uuid"
  | "datetime"
  | "date"
  | "time"
  | "int-array"
  | "bigint-array"
  | "float-array"
  | "double-array"
  | "string-array"
  | "char-array"
  | "bytes-array"
  | "bool-array"
  | "decimal-array"
  | "json-array"
  | "xml-array"
  | "uuid-array"
  | "datetime-array"
  | "date-array"
  | "time-array"
  | "null"
  | "unknown";

declare type QueryMiddleware = (
  params: QueryMiddlewareParams,
  next: (params: QueryMiddlewareParams) => Promise<unknown>
) => Promise<unknown>;

declare type QueryMiddlewareParams = {
  /** The model this is executed on */
  model?: string;
  /** The action that is being handled */
  action: Action;
  /** TODO what is this */
  dataPath: string[];
  /** TODO what is this */
  runInTransaction: boolean;
  args?: UserArgs_2;
};

export declare type QueryOptions = {
  query: {
    [ModelName in string]:
      | {
          [ModelAction in string]: ModelQueryOptionsCb;
        }
      | QueryOptionsCb;
  };
};

export declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;

export declare type QueryOptionsCbArgs = {
  model?: string;
  operation: string;
  args: JsArgs | RawQueryArgs;
  query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;
};

declare type QueryOutput = ReadonlyDeep_2<{
  name: string;
  isRequired: boolean;
  isList: boolean;
}>;

/**
 * Create raw SQL statement.
 */
export declare function raw(value: string): Sql;

export declare type RawParameters = {
  __prismaRawParameters__: true;
  values: string;
};

export declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];

declare type RawResponse = {
  columns: string[];
  types: QueryIntrospectionBuiltinType[];
  rows: unknown[][];
};

declare type RawTaggedValue = {
  $type: "Raw";
  value: unknown;
};

/**
 * Supported value or SQL instance.
 */
export declare type RawValue = Value | Sql;

export declare type ReadonlyDeep<T> = {
  readonly [K in keyof T]: ReadonlyDeep<T[K]>;
};

declare type ReadonlyDeep_2<O> = {
  +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;
};

declare type Record_2<T extends string | number | symbol, U> = {
  [P in T]: U;
};
export { Record_2 as Record };

export declare type RenameAndNestPayloadKeys<P> = {
  [K in keyof P as K extends "scalars" | "objects" | "composites" ? keyof P[K] : never]: P[K];
};

declare type RequestBatchOptions<InteractiveTransactionPayload> = {
  transaction?: TransactionOptions_3<InteractiveTransactionPayload>;
  traceparent?: string;
  numTry?: number;
  containsWrite: boolean;
  customDataProxyFetch?: CustomDataProxyFetch;
};

declare interface RequestError {
  error: string;
  user_facing_error: {
    is_panic: boolean;
    message: string;
    meta?: Record<string, unknown>;
    error_code?: string;
    batch_request_idx?: number;
  };
}

declare class RequestHandler {
  client: Client;
  dataloader: DataLoader<RequestParams>;
  private logEmitter?;
  constructor(client: Client, logEmitter?: LogEmitter);
  request(params: RequestParams): Promise<any>;
  mapQueryEngineResult(
    { dataPath, unpacker }: RequestParams,
    response: QueryEngineResultData<any>
  ): any;
  /**
   * Handles the error and logs it, logging the error is done synchronously waiting for the event
   * handlers to finish.
   */
  handleAndLogRequestError(params: HandleErrorParams): never;
  handleRequestError({
    error,
    clientMethod,
    callsite,
    transaction,
    args,
    modelName,
    globalOmit,
  }: HandleErrorParams): never;
  sanitizeMessage(message: any): any;
  unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;
  get [Symbol.toStringTag](): string;
}

declare type RequestOptions<InteractiveTransactionPayload> = {
  traceparent?: string;
  numTry?: number;
  interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;
  isWrite: boolean;
  customDataProxyFetch?: CustomDataProxyFetch;
};

declare type RequestParams = {
  modelName?: string;
  action: Action;
  protocolQuery: JsonQuery;
  dataPath: string[];
  clientMethod: string;
  callsite?: CallSite;
  transaction?: PrismaPromiseTransaction;
  extensions: MergedExtensionsList;
  args?: any;
  headers?: Record<string, string>;
  unpacker?: Unpacker;
  otelParentCtx?: Context;
  otelChildCtx?: Context;
  globalOmit?: GlobalOmitOptions;
  customDataProxyFetch?: CustomDataProxyFetch;
};

declare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;
export { RequiredExtensionArgs };
export { RequiredExtensionArgs as UserArgs };

export declare type RequiredKeys<O> = {
  [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;
}[keyof O];

declare function resolveDatasourceUrl({
  inlineDatasources,
  overrideDatasources,
  env,
  clientVersion,
}: {
  inlineDatasources: GetPrismaClientConfig["inlineDatasources"];
  overrideDatasources: Datasources;
  env: Record<string, string | undefined>;
  clientVersion: string;
}): string;

export declare type Result<T, A, F extends Operation> = T extends {
  [K: symbol]: {
    types: {
      payload: any;
    };
  };
}
  ? GetResult<T[symbol]["types"]["payload"], A, F>
  : GetResult<
      {
        composites: {};
        objects: {};
        scalars: {};
        name: "";
      },
      {},
      F
    >;

export declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;

declare namespace Result_3 {
  export {
    Count,
    GetFindResult,
    SelectablePayloadFields,
    SelectField,
    DefaultSelection,
    UnwrapPayload,
    ApplyOmit,
    OmitValue,
    GetCountResult,
    Aggregate,
    GetAggregateResult,
    GetBatchResult,
    GetGroupByResult,
    GetResult,
    ExtractGlobalOmit,
  };
}

declare type Result_4<T> = {
  map<U>(fn: (value: T) => U): Result_4<U>;
  flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;
} & (
  | {
      readonly ok: true;
      readonly value: T;
    }
  | {
      readonly ok: false;
      readonly error: Error_2;
    }
);

export declare type ResultArg = {
  [FieldName in string]: ResultFieldDefinition;
};

export declare type ResultArgs = {
  result: {
    [ModelName in string]: ResultArg;
  };
};

export declare type ResultArgsFieldCompute = (model: any) => unknown;

export declare type ResultFieldDefinition = {
  needs?: {
    [FieldName in string]: boolean;
  };
  compute: ResultArgsFieldCompute;
};

export declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;

export declare type RuntimeDataModel = {
  readonly models: Record<string, RuntimeModel>;
  readonly enums: Record<string, RuntimeEnum>;
  readonly types: Record<string, RuntimeModel>;
};

declare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, "name">;

declare type RuntimeModel = Omit<DMMF_2.Model, "name">;

declare type RuntimeName = "workerd" | "deno" | "netlify" | "node" | "bun" | "edge-light" | "";

declare type Schema = ReadonlyDeep_2<{
  rootQueryType?: string;
  rootMutationType?: string;
  inputObjectTypes: {
    model?: InputType[];
    prisma: InputType[];
  };
  outputObjectTypes: {
    model: OutputType[];
    prisma: OutputType[];
  };
  enumTypes: {
    model?: SchemaEnum[];
    prisma: SchemaEnum[];
  };
  fieldRefTypes: {
    prisma?: FieldRefType[];
  };
}>;

declare type SchemaArg = ReadonlyDeep_2<{
  name: string;
  comment?: string;
  isNullable: boolean;
  isRequired: boolean;
  inputTypes: InputTypeRef[];
  deprecation?: Deprecation;
}>;

declare type SchemaEnum = ReadonlyDeep_2<{
  name: string;
  values: string[];
}>;

declare type SchemaField = ReadonlyDeep_2<{
  name: string;
  isNullable?: boolean;
  outputType: OutputTypeRef;
  args: SchemaArg[];
  deprecation?: Deprecation;
  documentation?: string;
}>;

export declare type Select<T, U> = T extends U ? T : never;

export declare type SelectablePayloadFields<K extends PropertyKey, O> =
  | {
      objects: {
        [k in K]: O;
      };
    }
  | {
      composites: {
        [k in K]: O;
      };
    };

export declare type SelectField<
  P extends SelectablePayloadFields<any, any>,
  K extends PropertyKey,
> = P extends {
  objects: Record<K, any>;
}
  ? P["objects"][K]
  : P extends {
        composites: Record<K, any>;
      }
    ? P["composites"][K]
    : never;

declare type Selection_2 = Record<string, boolean | Skip | JsArgs>;
export { Selection_2 as Selection };

export declare function serializeJsonQuery({
  modelName,
  action,
  args,
  runtimeDataModel,
  extensions,
  callsite,
  clientMethod,
  errorFormat,
  clientVersion,
  previewFeatures,
  globalOmit,
}: SerializeParams): JsonQuery;

declare type SerializeParams = {
  runtimeDataModel: RuntimeDataModel;
  modelName?: string;
  action: Action;
  args?: JsArgs;
  extensions?: MergedExtensionsList;
  callsite?: CallSite;
  clientMethod: string;
  clientVersion: string;
  errorFormat: ErrorFormat;
  previewFeatures: string[];
  globalOmit?: GlobalOmitOptions;
};

declare class Skip {
  constructor(param?: symbol);
  ifUndefined<T>(value: T | undefined): T | Skip;
}

export declare const skip: Skip;

declare type SortOrder = "asc" | "desc";

/**
 * An interface that represents a span. A span represents a single operation
 * within a trace. Examples of span might include remote procedure calls or a
 * in-process function calls to sub-components. A Trace has a single, top-level
 * "root" Span that in turn may have zero or more child Spans, which in turn
 * may have children.
 *
 * Spans are created by the {@link Tracer.startSpan} method.
 */
declare interface Span {
  /**
   * Returns the {@link SpanContext} object associated with this Span.
   *
   * Get an immutable, serializable identifier for this span that can be used
   * to create new child spans. Returned SpanContext is usable even after the
   * span ends.
   *
   * @returns the SpanContext object associated with this Span.
   */
  spanContext(): SpanContext;
  /**
   * Sets an attribute to the span.
   *
   * Sets a single Attribute with the key and value passed as arguments.
   *
   * @param key the key for this attribute.
   * @param value the value for this attribute. Setting a value null or
   *              undefined is invalid and will result in undefined behavior.
   */
  setAttribute(key: string, value: SpanAttributeValue): this;
  /**
   * Sets attributes to the span.
   *
   * @param attributes the attributes that will be added.
   *                   null or undefined attribute values
   *                   are invalid and will result in undefined behavior.
   */
  setAttributes(attributes: SpanAttributes): this;
  /**
   * Adds an event to the Span.
   *
   * @param name the name of the event.
   * @param [attributesOrStartTime] the attributes that will be added; these are
   *     associated with this event. Can be also a start time
   *     if type is {@type TimeInput} and 3rd param is undefined
   * @param [startTime] start time of the event.
   */
  addEvent(
    name: string,
    attributesOrStartTime?: SpanAttributes | TimeInput,
    startTime?: TimeInput
  ): this;
  /**
   * Adds a single link to the span.
   *
   * Links added after the creation will not affect the sampling decision.
   * It is preferred span links be added at span creation.
   *
   * @param link the link to add.
   */
  addLink(link: Link): this;
  /**
   * Adds multiple links to the span.
   *
   * Links added after the creation will not affect the sampling decision.
   * It is preferred span links be added at span creation.
   *
   * @param links the links to add.
   */
  addLinks(links: Link[]): this;
  /**
   * Sets a status to the span. If used, this will override the default Span
   * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value
   * of previous calls to SetStatus on the Span.
   *
   * @param status the SpanStatus to set.
   */
  setStatus(status: SpanStatus): this;
  /**
   * Updates the Span name.
   *
   * This will override the name provided via {@link Tracer.startSpan}.
   *
   * Upon this update, any sampling behavior based on Span name will depend on
   * the implementation.
   *
   * @param name the Span name.
   */
  updateName(name: string): this;
  /**
   * Marks the end of Span execution.
   *
   * Call to End of a Span MUST not have any effects on child spans. Those may
   * still be running and can be ended later.
   *
   * Do not return `this`. The Span generally should not be used after it
   * is ended so chaining is not desired in this context.
   *
   * @param [endTime] the time to set as Span's end time. If not provided,
   *     use the current time as the span's end time.
   */
  end(endTime?: TimeInput): void;
  /**
   * Returns the flag whether this span will be recorded.
   *
   * @returns true if this Span is active and recording information like events
   *     with the `AddEvent` operation and attributes using `setAttributes`.
   */
  isRecording(): boolean;
  /**
   * Sets exception as a span event
   * @param exception the exception the only accepted values are string or Error
   * @param [time] the time to set as Span's event time. If not provided,
   *     use the current time.
   */
  recordException(exception: Exception, time?: TimeInput): void;
}

/**
 * @deprecated please use {@link Attributes}
 */
declare type SpanAttributes = Attributes;

/**
 * @deprecated please use {@link AttributeValue}
 */
declare type SpanAttributeValue = AttributeValue;

declare type SpanCallback<R> = (span?: Span, context?: Context) => R;

/**
 * A SpanContext represents the portion of a {@link Span} which must be
 * serialized and propagated along side of a {@link Baggage}.
 */
declare interface SpanContext {
  /**
   * The ID of the trace that this span belongs to. It is worldwide unique
   * with practically sufficient probability by being made as 16 randomly
   * generated bytes, encoded as a 32 lowercase hex characters corresponding to
   * 128 bits.
   */
  traceId: string;
  /**
   * The ID of the Span. It is globally unique with practically sufficient
   * probability by being made as 8 randomly generated bytes, encoded as a 16
   * lowercase hex characters corresponding to 64 bits.
   */
  spanId: string;
  /**
   * Only true if the SpanContext was propagated from a remote parent.
   */
  isRemote?: boolean;
  /**
   * Trace flags to propagate.
   *
   * It is represented as 1 byte (bitmap). Bit to represent whether trace is
   * sampled or not. When set, the least significant bit documents that the
   * caller may have recorded trace data. A caller who does not record trace
   * data out-of-band leaves this flag unset.
   *
   * see {@link TraceFlags} for valid flag values.
   */
  traceFlags: number;
  /**
   * Tracing-system-specific info to propagate.
   *
   * The tracestate field value is a `list` as defined below. The `list` is a
   * series of `list-members` separated by commas `,`, and a list-member is a
   * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
   * surrounding `list-members` are ignored. There can be a maximum of 32
   * `list-members` in a `list`.
   * More Info: https://www.w3.org/TR/trace-context/#tracestate-field
   *
   * Examples:
   *     Single tracing system (generic format):
   *         tracestate: rojo=00f067aa0ba902b7
   *     Multiple tracing systems (with different formatting):
   *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE
   */
  traceState?: TraceState;
}

declare enum SpanKind {
  /** Default value. Indicates that the span is used internally. */
  INTERNAL = 0,
  /**
   * Indicates that the span covers server-side handling of an RPC or other
   * remote request.
   */
  SERVER = 1,
  /**
   * Indicates that the span covers the client-side wrapper around an RPC or
   * other remote request.
   */
  CLIENT = 2,
  /**
   * Indicates that the span describes producer sending a message to a
   * broker. Unlike client and server, there is no direct critical path latency
   * relationship between producer and consumer spans.
   */
  PRODUCER = 3,
  /**
   * Indicates that the span describes consumer receiving a message from a
   * broker. Unlike client and server, there is no direct critical path latency
   * relationship between producer and consumer spans.
   */
  CONSUMER = 4,
}

/**
 * Options needed for span creation
 */
declare interface SpanOptions {
  /**
   * The SpanKind of a span
   * @default {@link SpanKind.INTERNAL}
   */
  kind?: SpanKind;
  /** A span's attributes */
  attributes?: SpanAttributes;
  /** {@link Link}s span to other spans */
  links?: Link[];
  /** A manually specified start time for the created `Span` object. */
  startTime?: TimeInput;
  /** The new span should be a root span. (Ignore parent from context). */
  root?: boolean;
}

declare interface SpanStatus {
  /** The status code of this message. */
  code: SpanStatusCode;
  /** A developer-facing error message. */
  message?: string;
}

/**
 * An enumeration of status codes.
 */
declare enum SpanStatusCode {
  /**
   * The default status.
   */
  UNSET = 0,
  /**
   * The operation has been validated by an Application developer or
   * Operator to have completed successfully.
   */
  OK = 1,
  /**
   * The operation contains an error.
   */
  ERROR = 2,
}

/**
 * A SQL instance can be nested within each other to build SQL strings.
 */
export declare class Sql {
  readonly values: Value[];
  readonly strings: string[];
  constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);
  get sql(): string;
  get statement(): string;
  get text(): string;
  inspect(): {
    sql: string;
    statement: string;
    text: string;
    values: unknown[];
  };
}

declare interface SqlDriverAdapter extends SqlQueryable {
  /**
   * Execute multiple SQL statements separated by semicolon.
   */
  executeScript(script: string): Promise<void>;
  /**
   * Start new transaction.
   */
  startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;
  /**
   * Optional method that returns extra connection info
   */
  getConnectionInfo?(): ConnectionInfo;
  /**
   * Dispose of the connection and release any resources.
   */
  dispose(): Promise<void>;
}

export declare interface SqlDriverAdapterFactory
  extends DriverAdapterFactory<SqlQuery, SqlResultSet> {
  connect(): Promise<SqlDriverAdapter>;
}

declare type SqlQuery = {
  sql: string;
  args: Array<unknown>;
  argTypes: Array<ArgType>;
};

declare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {}

declare interface SqlResultSet {
  /**
   * List of column types appearing in a database query, in the same order as `columnNames`.
   * They are used within the Query Engine to convert values from JS to Quaint values.
   */
  columnTypes: Array<ColumnType>;
  /**
   * List of column names appearing in a database query, in the same order as `columnTypes`.
   */
  columnNames: Array<string>;
  /**
   * List of rows retrieved from a database query.
   * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.
   */
  rows: Array<Array<unknown>>;
  /**
   * The last ID of an `INSERT` statement, if any.
   * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.
   */
  lastInsertId?: string;
}

/**
 * Create a SQL object from a template string.
 */
export declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;

/**
 * Defines TimeInput.
 *
 * hrtime, epoch milliseconds, performance.now() or Date
 */
declare type TimeInput = HrTime_2 | number | Date;

export declare type ToTuple<T> = T extends any[] ? T : [T];

declare interface TraceState {
  /**
   * Create a new TraceState which inherits from this TraceState and has the
   * given key set.
   * The new entry will always be added in the front of the list of states.
   *
   * @param key key of the TraceState entry.
   * @param value value of the TraceState entry.
   */
  set(key: string, value: string): TraceState;
  /**
   * Return a new TraceState which inherits from this TraceState but does not
   * contain the given key.
   *
   * @param key the key for the TraceState entry to be removed.
   */
  unset(key: string): TraceState;
  /**
   * Returns the value to which the specified key is mapped, or `undefined` if
   * this map contains no mapping for the key.
   *
   * @param key with which the specified value is to be associated.
   * @returns the value to which the specified key is mapped, or `undefined` if
   *     this map contains no mapping for the key.
   */
  get(key: string): string | undefined;
  /**
   * Serializes the TraceState to a `list` as defined below. The `list` is a
   * series of `list-members` separated by commas `,`, and a list-member is a
   * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
   * surrounding `list-members` are ignored. There can be a maximum of 32
   * `list-members` in a `list`.
   *
   * @returns the serialized string.
   */
  serialize(): string;
}

declare interface TracingHelper {
  isEnabled(): boolean;
  getTraceParent(context?: Context): string;
  dispatchEngineSpans(spans: EngineSpan[]): void;
  getActiveContext(): Context | undefined;
  runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;
}

declare interface Transaction extends AdapterInfo, SqlQueryable {
  /**
   * Transaction options.
   */
  readonly options: TransactionOptions;
  /**
   * Commit the transaction.
   */
  commit(): Promise<void>;
  /**
   * Roll back the transaction.
   */
  rollback(): Promise<void>;
}

declare namespace Transaction_2 {
  export { TransactionOptions_2 as Options, InteractiveTransactionInfo, TransactionHeaders };
}

declare type TransactionHeaders = {
  traceparent?: string;
};

declare type TransactionOptions = {
  usePhantomQuery: boolean;
};

declare type TransactionOptions_2 = {
  maxWait?: number;
  timeout?: number;
  isolationLevel?: IsolationLevel;
};

declare type TransactionOptions_3<InteractiveTransactionPayload> =
  | {
      kind: "itx";
      options: InteractiveTransactionOptions<InteractiveTransactionPayload>;
    }
  | {
      kind: "batch";
      options: BatchTransactionOptions;
    };

export declare class TypedSql<Values extends readonly unknown[], Result> {
  [PrivateResultType]: Result;
  constructor(sql: string, values: Values);
  get sql(): string;
  get values(): Values;
}

export declare type TypeMapCbDef = Fn<
  {
    extArgs: InternalArgs;
  },
  TypeMapDef
>;

/** Shared */
export declare type TypeMapDef = Record<any, any>;

declare type TypeRef<AllowedLocations extends FieldLocation> = {
  isList: boolean;
  type: string;
  location: AllowedLocations;
  namespace?: FieldNamespace;
};

declare namespace Types {
  export {
    Result_3 as Result,
    Extensions_2 as Extensions,
    Utils,
    Public_2 as Public,
    isSkip,
    Skip,
    skip,
    UnknownTypedSql,
    OperationPayload as Payload,
  };
}
export { Types };

declare type uniqueIndex = ReadonlyDeep_2<{
  name: string;
  fields: string[];
}>;

declare type UnknownErrorParams = {
  clientVersion: string;
  batchRequestIdx?: number;
};

export declare type UnknownTypedSql = TypedSql<unknown[], unknown>;

declare type Unpacker = (data: any) => any;

export declare type UnwrapPayload<P> = {} extends P
  ? unknown
  : {
      [K in keyof P]: P[K] extends {
        scalars: infer S;
        composites: infer C;
      }[]
        ? Array<S & UnwrapPayload<C>>
        : P[K] extends {
              scalars: infer S;
              composites: infer C;
            } | null
          ? (S & UnwrapPayload<C>) | Select<P[K], null>
          : never;
    };

export declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;

export declare type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}`
    ? Tuple[K] extends PrismaPromise<infer X>
      ? X
      : UnwrapPromise<Tuple[K]>
    : UnwrapPromise<Tuple[K]>;
};

/**
 * Input that flows from the user into the Client.
 */
declare type UserArgs_2 = any;

declare namespace Utils {
  export {
    EmptyToUnknown,
    NeverToUnknown,
    PatchFlat,
    Omit_2 as Omit,
    Pick_2 as Pick,
    ComputeDeep,
    Compute,
    OptionalFlat,
    ReadonlyDeep,
    Narrowable,
    Narrow,
    Exact,
    Cast,
    Record_2 as Record,
    UnwrapPromise,
    UnwrapTuple,
    Path,
    Fn,
    Call,
    RequiredKeys,
    OptionalKeys,
    Optional,
    Return,
    ToTuple,
    RenameAndNestPayloadKeys,
    PayloadToResult,
    Select,
    Equals,
    Or,
    JsPromise,
  };
}

declare function validator<V>(): <S>(select: Exact<S, V>) => S;

declare function validator<
  C,
  M extends Exclude<keyof C, `$${string}`>,
  O extends keyof C[M] & Operation,
>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;

declare function validator<
  C,
  M extends Exclude<keyof C, `$${string}`>,
  O extends keyof C[M] & Operation,
  P extends keyof Args<C[M], O>,
>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;

/**
 * Values supported by SQL engine.
 */
export declare type Value = unknown;

export declare function warnEnvConflicts(envPaths: any): void;

export declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;

export {};
</file>

<file path="src/generated/prisma/client.d.ts">
export * from "./index";
</file>

<file path="src/generated/prisma/default.d.ts">
export * from "./index";
</file>

<file path="src/generated/prisma/edge.d.ts">
export * from "./default";
</file>

<file path="src/generated/prisma/wasm.d.ts">
export * from "./index";
</file>

<file path="src/lib/supabase/client.ts">
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error("Missing Supabase environment variables");
  }

  return createBrowserClient(supabaseUrl, supabaseAnonKey);
}
</file>

<file path="src/lib/supabase/server.ts">
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = cookies();
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error("Missing Supabase environment variables");
  }

  return createServerClient(supabaseUrl, supabaseAnonKey, {
    cookies: {
      getAll() {
        return cookieStore.getAll();
      },
      setAll(cookiesToSet) {
        try {
          for (const cookie of cookiesToSet) {
            const { name, value, options } = cookie;
            cookieStore.set(name, value, options);
          }
        } catch {
          // The `setAll` method was called from a Server Component.
          // This can be ignored if you have middleware refreshing
          // user sessions.
        }
      },
    },
  });
}
</file>

<file path="src/lib/prisma.ts">
import { PrismaClient } from "../generated/prisma";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/middleware.ts">
import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  });

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error("Missing Supabase environment variables");
  }

  const supabase = createServerClient(supabaseUrl, supabaseAnonKey, {
    cookies: {
      getAll() {
        return request.cookies.getAll();
      },
      setAll(cookiesToSet) {
        for (const { name, value, options } of cookiesToSet) {
          request.cookies.set(name, value);
        }

        supabaseResponse = NextResponse.next({
          request,
        });

        for (const { name, value, options } of cookiesToSet) {
          supabaseResponse.cookies.set(name, value, options);
        }
      },
    },
  });

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (
    !user &&
    !request.nextUrl.pathname.startsWith("/login") &&
    !request.nextUrl.pathname.startsWith("/auth")
  ) {
    const url = request.nextUrl.clone();
    url.pathname = "/login";
    return NextResponse.redirect(url);
  }

  return supabaseResponse;
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)"],
};
</file>

<file path="src/generated/prisma/index.d.ts">
/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Clinic
 *
 */
export type Clinic = $Result.DefaultSelection<Prisma.$ClinicPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Provider
 *
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>;
/**
 * Model MetricDefinition
 *
 */
export type MetricDefinition = $Result.DefaultSelection<Prisma.$MetricDefinitionPayload>;
/**
 * Model DataSource
 *
 */
export type DataSource = $Result.DefaultSelection<Prisma.$DataSourcePayload>;
/**
 * Model ColumnMapping
 *
 */
export type ColumnMapping = $Result.DefaultSelection<Prisma.$ColumnMappingPayload>;
/**
 * Model MetricValue
 *
 */
export type MetricValue = $Result.DefaultSelection<Prisma.$MetricValuePayload>;
/**
 * Model Goal
 *
 */
export type Goal = $Result.DefaultSelection<Prisma.$GoalPayload>;
/**
 * Model Dashboard
 *
 */
export type Dashboard = $Result.DefaultSelection<Prisma.$DashboardPayload>;
/**
 * Model Widget
 *
 */
export type Widget = $Result.DefaultSelection<Prisma.$WidgetPayload>;

/**
 * ##  Prisma Client  ≤À¢
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clinics
 * const clinics = await prisma.clinic.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client  ≤À¢
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clinics
   * const clinics = await prisma.clinic.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.clinic`: Exposes CRUD operations for the **Clinic** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Clinics
   * const clinics = await prisma.clinic.findMany()
   * ```
   */
  get clinic(): Prisma.ClinicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Providers
   * const providers = await prisma.provider.findMany()
   * ```
   */
  get provider(): Prisma.ProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metricDefinition`: Exposes CRUD operations for the **MetricDefinition** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more MetricDefinitions
   * const metricDefinitions = await prisma.metricDefinition.findMany()
   * ```
   */
  get metricDefinition(): Prisma.MetricDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataSource`: Exposes CRUD operations for the **DataSource** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DataSources
   * const dataSources = await prisma.dataSource.findMany()
   * ```
   */
  get dataSource(): Prisma.DataSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.columnMapping`: Exposes CRUD operations for the **ColumnMapping** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ColumnMappings
   * const columnMappings = await prisma.columnMapping.findMany()
   * ```
   */
  get columnMapping(): Prisma.ColumnMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metricValue`: Exposes CRUD operations for the **MetricValue** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more MetricValues
   * const metricValues = await prisma.metricValue.findMany()
   * ```
   */
  get metricValue(): Prisma.MetricValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **Goal** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Goals
   * const goals = await prisma.goal.findMany()
   * ```
   */
  get goal(): Prisma.GoalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboard`: Exposes CRUD operations for the **Dashboard** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Dashboards
   * const dashboards = await prisma.dashboard.findMany()
   * ```
   */
  get dashboard(): Prisma.DashboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.widget`: Exposes CRUD operations for the **Widget** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Widgets
   * const widgets = await prisma.widget.findMany()
   * ```
   */
  get widget(): Prisma.WidgetDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
    ? False
    : T extends Date
      ? False
      : T extends Uint8Array
        ? False
        : T extends BigInt
          ? False
          : T extends object
            ? True
            : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<"OR", K>, Extends<"AND", K>>, Extends<"NOT", K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Clinic: "Clinic";
    User: "User";
    Provider: "Provider";
    MetricDefinition: "MetricDefinition";
    DataSource: "DataSource";
    ColumnMapping: "ColumnMapping";
    MetricValue: "MetricValue";
    Goal: "Goal";
    Dashboard: "Dashboard";
    Widget: "Widget";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "clinic"
        | "user"
        | "provider"
        | "metricDefinition"
        | "dataSource"
        | "columnMapping"
        | "metricValue"
        | "goal"
        | "dashboard"
        | "widget";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Clinic: {
        payload: Prisma.$ClinicPayload<ExtArgs>;
        fields: Prisma.ClinicFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ClinicFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ClinicFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>;
          };
          findFirst: {
            args: Prisma.ClinicFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ClinicFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>;
          };
          findMany: {
            args: Prisma.ClinicFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[];
          };
          create: {
            args: Prisma.ClinicCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>;
          };
          createMany: {
            args: Prisma.ClinicCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ClinicCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[];
          };
          delete: {
            args: Prisma.ClinicDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>;
          };
          update: {
            args: Prisma.ClinicUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>;
          };
          deleteMany: {
            args: Prisma.ClinicDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ClinicUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ClinicUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[];
          };
          upsert: {
            args: Prisma.ClinicUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>;
          };
          aggregate: {
            args: Prisma.ClinicAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateClinic>;
          };
          groupBy: {
            args: Prisma.ClinicGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ClinicGroupByOutputType>[];
          };
          count: {
            args: Prisma.ClinicCountArgs<ExtArgs>;
            result: $Utils.Optional<ClinicCountAggregateOutputType> | number;
          };
        };
      };
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>;
        fields: Prisma.ProviderFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>;
          };
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>;
          };
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[];
          };
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>;
          };
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ProviderCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[];
          };
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>;
          };
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>;
          };
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ProviderUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[];
          };
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>;
          };
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProvider>;
          };
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProviderGroupByOutputType>[];
          };
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>;
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number;
          };
        };
      };
      MetricDefinition: {
        payload: Prisma.$MetricDefinitionPayload<ExtArgs>;
        fields: Prisma.MetricDefinitionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MetricDefinitionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MetricDefinitionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload>;
          };
          findFirst: {
            args: Prisma.MetricDefinitionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MetricDefinitionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload>;
          };
          findMany: {
            args: Prisma.MetricDefinitionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload>[];
          };
          create: {
            args: Prisma.MetricDefinitionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload>;
          };
          createMany: {
            args: Prisma.MetricDefinitionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MetricDefinitionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload>[];
          };
          delete: {
            args: Prisma.MetricDefinitionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload>;
          };
          update: {
            args: Prisma.MetricDefinitionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload>;
          };
          deleteMany: {
            args: Prisma.MetricDefinitionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MetricDefinitionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MetricDefinitionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload>[];
          };
          upsert: {
            args: Prisma.MetricDefinitionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricDefinitionPayload>;
          };
          aggregate: {
            args: Prisma.MetricDefinitionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMetricDefinition>;
          };
          groupBy: {
            args: Prisma.MetricDefinitionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MetricDefinitionGroupByOutputType>[];
          };
          count: {
            args: Prisma.MetricDefinitionCountArgs<ExtArgs>;
            result: $Utils.Optional<MetricDefinitionCountAggregateOutputType> | number;
          };
        };
      };
      DataSource: {
        payload: Prisma.$DataSourcePayload<ExtArgs>;
        fields: Prisma.DataSourceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DataSourceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DataSourceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>;
          };
          findFirst: {
            args: Prisma.DataSourceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DataSourceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>;
          };
          findMany: {
            args: Prisma.DataSourceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>[];
          };
          create: {
            args: Prisma.DataSourceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>;
          };
          createMany: {
            args: Prisma.DataSourceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DataSourceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>[];
          };
          delete: {
            args: Prisma.DataSourceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>;
          };
          update: {
            args: Prisma.DataSourceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>;
          };
          deleteMany: {
            args: Prisma.DataSourceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DataSourceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.DataSourceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>[];
          };
          upsert: {
            args: Prisma.DataSourceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DataSourcePayload>;
          };
          aggregate: {
            args: Prisma.DataSourceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDataSource>;
          };
          groupBy: {
            args: Prisma.DataSourceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DataSourceGroupByOutputType>[];
          };
          count: {
            args: Prisma.DataSourceCountArgs<ExtArgs>;
            result: $Utils.Optional<DataSourceCountAggregateOutputType> | number;
          };
        };
      };
      ColumnMapping: {
        payload: Prisma.$ColumnMappingPayload<ExtArgs>;
        fields: Prisma.ColumnMappingFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ColumnMappingFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ColumnMappingFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload>;
          };
          findFirst: {
            args: Prisma.ColumnMappingFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ColumnMappingFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload>;
          };
          findMany: {
            args: Prisma.ColumnMappingFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload>[];
          };
          create: {
            args: Prisma.ColumnMappingCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload>;
          };
          createMany: {
            args: Prisma.ColumnMappingCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ColumnMappingCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload>[];
          };
          delete: {
            args: Prisma.ColumnMappingDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload>;
          };
          update: {
            args: Prisma.ColumnMappingUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload>;
          };
          deleteMany: {
            args: Prisma.ColumnMappingDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ColumnMappingUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ColumnMappingUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload>[];
          };
          upsert: {
            args: Prisma.ColumnMappingUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ColumnMappingPayload>;
          };
          aggregate: {
            args: Prisma.ColumnMappingAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateColumnMapping>;
          };
          groupBy: {
            args: Prisma.ColumnMappingGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ColumnMappingGroupByOutputType>[];
          };
          count: {
            args: Prisma.ColumnMappingCountArgs<ExtArgs>;
            result: $Utils.Optional<ColumnMappingCountAggregateOutputType> | number;
          };
        };
      };
      MetricValue: {
        payload: Prisma.$MetricValuePayload<ExtArgs>;
        fields: Prisma.MetricValueFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MetricValueFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MetricValueFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload>;
          };
          findFirst: {
            args: Prisma.MetricValueFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MetricValueFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload>;
          };
          findMany: {
            args: Prisma.MetricValueFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload>[];
          };
          create: {
            args: Prisma.MetricValueCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload>;
          };
          createMany: {
            args: Prisma.MetricValueCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MetricValueCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload>[];
          };
          delete: {
            args: Prisma.MetricValueDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload>;
          };
          update: {
            args: Prisma.MetricValueUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload>;
          };
          deleteMany: {
            args: Prisma.MetricValueDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MetricValueUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.MetricValueUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload>[];
          };
          upsert: {
            args: Prisma.MetricValueUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MetricValuePayload>;
          };
          aggregate: {
            args: Prisma.MetricValueAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMetricValue>;
          };
          groupBy: {
            args: Prisma.MetricValueGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MetricValueGroupByOutputType>[];
          };
          count: {
            args: Prisma.MetricValueCountArgs<ExtArgs>;
            result: $Utils.Optional<MetricValueCountAggregateOutputType> | number;
          };
        };
      };
      Goal: {
        payload: Prisma.$GoalPayload<ExtArgs>;
        fields: Prisma.GoalFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.GoalFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>;
          };
          findFirst: {
            args: Prisma.GoalFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>;
          };
          findMany: {
            args: Prisma.GoalFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[];
          };
          create: {
            args: Prisma.GoalCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>;
          };
          createMany: {
            args: Prisma.GoalCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[];
          };
          delete: {
            args: Prisma.GoalDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>;
          };
          update: {
            args: Prisma.GoalUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>;
          };
          deleteMany: {
            args: Prisma.GoalDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.GoalUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.GoalUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>[];
          };
          upsert: {
            args: Prisma.GoalUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GoalPayload>;
          };
          aggregate: {
            args: Prisma.GoalAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateGoal>;
          };
          groupBy: {
            args: Prisma.GoalGroupByArgs<ExtArgs>;
            result: $Utils.Optional<GoalGroupByOutputType>[];
          };
          count: {
            args: Prisma.GoalCountArgs<ExtArgs>;
            result: $Utils.Optional<GoalCountAggregateOutputType> | number;
          };
        };
      };
      Dashboard: {
        payload: Prisma.$DashboardPayload<ExtArgs>;
        fields: Prisma.DashboardFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DashboardFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DashboardFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>;
          };
          findFirst: {
            args: Prisma.DashboardFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DashboardFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>;
          };
          findMany: {
            args: Prisma.DashboardFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[];
          };
          create: {
            args: Prisma.DashboardCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>;
          };
          createMany: {
            args: Prisma.DashboardCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DashboardCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[];
          };
          delete: {
            args: Prisma.DashboardDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>;
          };
          update: {
            args: Prisma.DashboardUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>;
          };
          deleteMany: {
            args: Prisma.DashboardDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DashboardUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.DashboardUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>[];
          };
          upsert: {
            args: Prisma.DashboardUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DashboardPayload>;
          };
          aggregate: {
            args: Prisma.DashboardAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDashboard>;
          };
          groupBy: {
            args: Prisma.DashboardGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DashboardGroupByOutputType>[];
          };
          count: {
            args: Prisma.DashboardCountArgs<ExtArgs>;
            result: $Utils.Optional<DashboardCountAggregateOutputType> | number;
          };
        };
      };
      Widget: {
        payload: Prisma.$WidgetPayload<ExtArgs>;
        fields: Prisma.WidgetFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WidgetFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WidgetFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>;
          };
          findFirst: {
            args: Prisma.WidgetFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WidgetFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>;
          };
          findMany: {
            args: Prisma.WidgetFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>[];
          };
          create: {
            args: Prisma.WidgetCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>;
          };
          createMany: {
            args: Prisma.WidgetCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WidgetCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>[];
          };
          delete: {
            args: Prisma.WidgetDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>;
          };
          update: {
            args: Prisma.WidgetUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>;
          };
          deleteMany: {
            args: Prisma.WidgetDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WidgetUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WidgetUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>[];
          };
          upsert: {
            args: Prisma.WidgetUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WidgetPayload>;
          };
          aggregate: {
            args: Prisma.WidgetAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWidget>;
          };
          groupBy: {
            args: Prisma.WidgetGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WidgetGroupByOutputType>[];
          };
          count: {
            args: Prisma.WidgetCountArgs<ExtArgs>;
            result: $Utils.Optional<WidgetCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    clinic?: ClinicOmit;
    user?: UserOmit;
    provider?: ProviderOmit;
    metricDefinition?: MetricDefinitionOmit;
    dataSource?: DataSourceOmit;
    columnMapping?: ColumnMappingOmit;
    metricValue?: MetricValueOmit;
    goal?: GoalOmit;
    dashboard?: DashboardOmit;
    widget?: WidgetOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
    ? T["emit"] extends "event"
      ? T["level"]
      : never
    : never;
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type ClinicCountOutputType
   */

  export type ClinicCountOutputType = {
    users: number;
    providers: number;
    metrics: number;
    goals: number;
  };

  export type ClinicCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    users?: boolean | ClinicCountOutputTypeCountUsersArgs;
    providers?: boolean | ClinicCountOutputTypeCountProvidersArgs;
    metrics?: boolean | ClinicCountOutputTypeCountMetricsArgs;
    goals?: boolean | ClinicCountOutputTypeCountGoalsArgs;
  };

  // Custom InputTypes
  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ClinicCountOutputType
     */
    select?: ClinicCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
  };

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountProvidersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProviderWhereInput;
  };

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MetricValueWhereInput;
  };

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountGoalsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GoalWhereInput;
  };

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    dashboards: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    dashboards?: boolean | UserCountOutputTypeCountDashboardsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDashboardsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DashboardWhereInput;
  };

  /**
   * Count Type ProviderCountOutputType
   */

  export type ProviderCountOutputType = {
    metrics: number;
    goals: number;
  };

  export type ProviderCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    metrics?: boolean | ProviderCountOutputTypeCountMetricsArgs;
    goals?: boolean | ProviderCountOutputTypeCountGoalsArgs;
  };

  // Custom InputTypes
  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MetricValueWhereInput;
  };

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountGoalsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GoalWhereInput;
  };

  /**
   * Count Type MetricDefinitionCountOutputType
   */

  export type MetricDefinitionCountOutputType = {
    metrics: number;
    columnMappings: number;
    goals: number;
    widgets: number;
  };

  export type MetricDefinitionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    metrics?: boolean | MetricDefinitionCountOutputTypeCountMetricsArgs;
    columnMappings?: boolean | MetricDefinitionCountOutputTypeCountColumnMappingsArgs;
    goals?: boolean | MetricDefinitionCountOutputTypeCountGoalsArgs;
    widgets?: boolean | MetricDefinitionCountOutputTypeCountWidgetsArgs;
  };

  // Custom InputTypes
  /**
   * MetricDefinitionCountOutputType without action
   */
  export type MetricDefinitionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinitionCountOutputType
     */
    select?: MetricDefinitionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * MetricDefinitionCountOutputType without action
   */
  export type MetricDefinitionCountOutputTypeCountMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MetricValueWhereInput;
  };

  /**
   * MetricDefinitionCountOutputType without action
   */
  export type MetricDefinitionCountOutputTypeCountColumnMappingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ColumnMappingWhereInput;
  };

  /**
   * MetricDefinitionCountOutputType without action
   */
  export type MetricDefinitionCountOutputTypeCountGoalsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GoalWhereInput;
  };

  /**
   * MetricDefinitionCountOutputType without action
   */
  export type MetricDefinitionCountOutputTypeCountWidgetsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WidgetWhereInput;
  };

  /**
   * Count Type DataSourceCountOutputType
   */

  export type DataSourceCountOutputType = {
    columnMappings: number;
    metrics: number;
  };

  export type DataSourceCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    columnMappings?: boolean | DataSourceCountOutputTypeCountColumnMappingsArgs;
    metrics?: boolean | DataSourceCountOutputTypeCountMetricsArgs;
  };

  // Custom InputTypes
  /**
   * DataSourceCountOutputType without action
   */
  export type DataSourceCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSourceCountOutputType
     */
    select?: DataSourceCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * DataSourceCountOutputType without action
   */
  export type DataSourceCountOutputTypeCountColumnMappingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ColumnMappingWhereInput;
  };

  /**
   * DataSourceCountOutputType without action
   */
  export type DataSourceCountOutputTypeCountMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MetricValueWhereInput;
  };

  /**
   * Count Type DashboardCountOutputType
   */

  export type DashboardCountOutputType = {
    widgets: number;
  };

  export type DashboardCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    widgets?: boolean | DashboardCountOutputTypeCountWidgetsArgs;
  };

  // Custom InputTypes
  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DashboardCountOutputType
     */
    select?: DashboardCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * DashboardCountOutputType without action
   */
  export type DashboardCountOutputTypeCountWidgetsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WidgetWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Clinic
   */

  export type AggregateClinic = {
    _count: ClinicCountAggregateOutputType | null;
    _min: ClinicMinAggregateOutputType | null;
    _max: ClinicMaxAggregateOutputType | null;
  };

  export type ClinicMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    location: string | null;
    status: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ClinicMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    location: string | null;
    status: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ClinicCountAggregateOutputType = {
    id: number;
    name: number;
    location: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ClinicMinAggregateInputType = {
    id?: true;
    name?: true;
    location?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ClinicMaxAggregateInputType = {
    id?: true;
    name?: true;
    location?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ClinicCountAggregateInputType = {
    id?: true;
    name?: true;
    location?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ClinicAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Clinic to aggregate.
     */
    where?: ClinicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ClinicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Clinics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clinics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Clinics
     **/
    _count?: true | ClinicCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ClinicMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ClinicMaxAggregateInputType;
  };

  export type GetClinicAggregateType<T extends ClinicAggregateArgs> = {
    [P in keyof T & keyof AggregateClinic]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic[P]>
      : GetScalarType<T[P], AggregateClinic[P]>;
  };

  export type ClinicGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ClinicWhereInput;
    orderBy?: ClinicOrderByWithAggregationInput | ClinicOrderByWithAggregationInput[];
    by: ClinicScalarFieldEnum[] | ClinicScalarFieldEnum;
    having?: ClinicScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ClinicCountAggregateInputType | true;
    _min?: ClinicMinAggregateInputType;
    _max?: ClinicMaxAggregateInputType;
  };

  export type ClinicGroupByOutputType = {
    id: string;
    name: string;
    location: string;
    status: string;
    createdAt: Date;
    updatedAt: Date;
    _count: ClinicCountAggregateOutputType | null;
    _min: ClinicMinAggregateOutputType | null;
    _max: ClinicMaxAggregateOutputType | null;
  };

  type GetClinicGroupByPayload<T extends ClinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ClinicGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ClinicGroupByOutputType[P]>
          : GetScalarType<T[P], ClinicGroupByOutputType[P]>;
      }
    >
  >;

  export type ClinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        location?: boolean;
        status?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        users?: boolean | Clinic$usersArgs<ExtArgs>;
        providers?: boolean | Clinic$providersArgs<ExtArgs>;
        metrics?: boolean | Clinic$metricsArgs<ExtArgs>;
        goals?: boolean | Clinic$goalsArgs<ExtArgs>;
        _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["clinic"]
    >;

  export type ClinicSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      location?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["clinic"]
  >;

  export type ClinicSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      location?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["clinic"]
  >;

  export type ClinicSelectScalar = {
    id?: boolean;
    name?: boolean;
    location?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ClinicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      "id" | "name" | "location" | "status" | "createdAt" | "updatedAt",
      ExtArgs["result"]["clinic"]
    >;
  export type ClinicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Clinic$usersArgs<ExtArgs>;
    providers?: boolean | Clinic$providersArgs<ExtArgs>;
    metrics?: boolean | Clinic$metricsArgs<ExtArgs>;
    goals?: boolean | Clinic$goalsArgs<ExtArgs>;
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ClinicIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type ClinicIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $ClinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clinic";
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[];
      providers: Prisma.$ProviderPayload<ExtArgs>[];
      metrics: Prisma.$MetricValuePayload<ExtArgs>[];
      goals: Prisma.$GoalPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        location: string;
        status: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["clinic"]
    >;
    composites: {};
  };

  type ClinicGetPayload<S extends boolean | null | undefined | ClinicDefaultArgs> =
    $Result.GetResult<Prisma.$ClinicPayload, S>;

  type ClinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ClinicFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ClinicCountAggregateInputType | true;
  };

  export interface ClinicDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Clinic"]; meta: { name: "Clinic" } };
    /**
     * Find zero or one Clinic that matches the filter.
     * @param {ClinicFindUniqueArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicFindUniqueArgs>(
      args: SelectSubset<T, ClinicFindUniqueArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Clinic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicFindUniqueOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ClinicFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Clinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicFindFirstArgs>(
      args?: SelectSubset<T, ClinicFindFirstArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Clinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClinicFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Clinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinics
     * const clinics = await prisma.clinic.findMany()
     *
     * // Get first 10 Clinics
     * const clinics = await prisma.clinic.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const clinicWithIdOnly = await prisma.clinic.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ClinicFindManyArgs>(
      args?: SelectSubset<T, ClinicFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Clinic.
     * @param {ClinicCreateArgs} args - Arguments to create a Clinic.
     * @example
     * // Create one Clinic
     * const Clinic = await prisma.clinic.create({
     *   data: {
     *     // ... data to create a Clinic
     *   }
     * })
     *
     */
    create<T extends ClinicCreateArgs>(
      args: SelectSubset<T, ClinicCreateArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Clinics.
     * @param {ClinicCreateManyArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ClinicCreateManyArgs>(
      args?: SelectSubset<T, ClinicCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Clinics and returns the data saved in the database.
     * @param {ClinicCreateManyAndReturnArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ClinicCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ClinicCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Clinic.
     * @param {ClinicDeleteArgs} args - Arguments to delete one Clinic.
     * @example
     * // Delete one Clinic
     * const Clinic = await prisma.clinic.delete({
     *   where: {
     *     // ... filter to delete one Clinic
     *   }
     * })
     *
     */
    delete<T extends ClinicDeleteArgs>(
      args: SelectSubset<T, ClinicDeleteArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Clinic.
     * @param {ClinicUpdateArgs} args - Arguments to update one Clinic.
     * @example
     * // Update one Clinic
     * const clinic = await prisma.clinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ClinicUpdateArgs>(
      args: SelectSubset<T, ClinicUpdateArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Clinics.
     * @param {ClinicDeleteManyArgs} args - Arguments to filter Clinics to delete.
     * @example
     * // Delete a few Clinics
     * const { count } = await prisma.clinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ClinicDeleteManyArgs>(
      args?: SelectSubset<T, ClinicDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ClinicUpdateManyArgs>(
      args: SelectSubset<T, ClinicUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Clinics and returns the data updated in the database.
     * @param {ClinicUpdateManyAndReturnArgs} args - Arguments to update many Clinics.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ClinicUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ClinicUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Clinic.
     * @param {ClinicUpsertArgs} args - Arguments to update or create a Clinic.
     * @example
     * // Update or create a Clinic
     * const clinic = await prisma.clinic.upsert({
     *   create: {
     *     // ... data to create a Clinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic we want to update
     *   }
     * })
     */
    upsert<T extends ClinicUpsertArgs>(
      args: SelectSubset<T, ClinicUpsertArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicCountArgs} args - Arguments to filter Clinics to count.
     * @example
     * // Count the number of Clinics
     * const count = await prisma.clinic.count({
     *   where: {
     *     // ... the filter for the Clinics we want to count
     *   }
     * })
     **/
    count<T extends ClinicCountArgs>(
      args?: Subset<T, ClinicCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ClinicCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ClinicAggregateArgs>(
      args: Subset<T, ClinicAggregateArgs>
    ): Prisma.PrismaPromise<GetClinicAggregateType<T>>;

    /**
     * Group by Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ClinicGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicGroupByArgs["orderBy"] }
        : { orderBy?: ClinicGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ClinicGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetClinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Clinic model
     */
    readonly fields: ClinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    users<T extends Clinic$usersArgs<ExtArgs> = {}>(
      args?: Subset<T, Clinic$usersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    providers<T extends Clinic$providersArgs<ExtArgs> = {}>(
      args?: Subset<T, Clinic$providersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    metrics<T extends Clinic$metricsArgs<ExtArgs> = {}>(
      args?: Subset<T, Clinic$metricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$MetricValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    goals<T extends Clinic$goalsArgs<ExtArgs> = {}>(
      args?: Subset<T, Clinic$goalsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Clinic model
   */
  interface ClinicFieldRefs {
    readonly id: FieldRef<"Clinic", "String">;
    readonly name: FieldRef<"Clinic", "String">;
    readonly location: FieldRef<"Clinic", "String">;
    readonly status: FieldRef<"Clinic", "String">;
    readonly createdAt: FieldRef<"Clinic", "DateTime">;
    readonly updatedAt: FieldRef<"Clinic", "DateTime">;
  }

  // Custom InputTypes
  /**
   * Clinic findUnique
   */
  export type ClinicFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null;
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput;
  };

  /**
   * Clinic findUniqueOrThrow
   */
  export type ClinicFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null;
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput;
  };

  /**
   * Clinic findFirst
   */
  export type ClinicFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null;
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Clinics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clinics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[];
  };

  /**
   * Clinic findFirstOrThrow
   */
  export type ClinicFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null;
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Clinics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clinics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[];
  };

  /**
   * Clinic findMany
   */
  export type ClinicFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null;
    /**
     * Filter, which Clinics to fetch.
     */
    where?: ClinicWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Clinics.
     */
    cursor?: ClinicWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Clinics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Clinics.
     */
    skip?: number;
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[];
  };

  /**
   * Clinic create
   */
  export type ClinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Clinic
       */
      select?: ClinicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Clinic
       */
      omit?: ClinicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ClinicInclude<ExtArgs> | null;
      /**
       * The data needed to create a Clinic.
       */
      data: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>;
    };

  /**
   * Clinic createMany
   */
  export type ClinicCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Clinic createManyAndReturn
   */
  export type ClinicCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null;
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Clinic update
   */
  export type ClinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Clinic
       */
      select?: ClinicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Clinic
       */
      omit?: ClinicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ClinicInclude<ExtArgs> | null;
      /**
       * The data needed to update a Clinic.
       */
      data: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>;
      /**
       * Choose, which Clinic to update.
       */
      where: ClinicWhereUniqueInput;
    };

  /**
   * Clinic updateMany
   */
  export type ClinicUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>;
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput;
    /**
     * Limit how many Clinics to update.
     */
    limit?: number;
  };

  /**
   * Clinic updateManyAndReturn
   */
  export type ClinicUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null;
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>;
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput;
    /**
     * Limit how many Clinics to update.
     */
    limit?: number;
  };

  /**
   * Clinic upsert
   */
  export type ClinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Clinic
       */
      select?: ClinicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Clinic
       */
      omit?: ClinicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ClinicInclude<ExtArgs> | null;
      /**
       * The filter to search for the Clinic to update in case it exists.
       */
      where: ClinicWhereUniqueInput;
      /**
       * In case the Clinic found by the `where` argument doesn't exist, create a new Clinic with this data.
       */
      create: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>;
      /**
       * In case the Clinic was found with the provided `where` argument, update it with this data.
       */
      update: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>;
    };

  /**
   * Clinic delete
   */
  export type ClinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Clinic
       */
      select?: ClinicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Clinic
       */
      omit?: ClinicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ClinicInclude<ExtArgs> | null;
      /**
       * Filter which Clinic to delete.
       */
      where: ClinicWhereUniqueInput;
    };

  /**
   * Clinic deleteMany
   */
  export type ClinicDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Clinics to delete
     */
    where?: ClinicWhereInput;
    /**
     * Limit how many Clinics to delete.
     */
    limit?: number;
  };

  /**
   * Clinic.users
   */
  export type Clinic$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      where?: UserWhereInput;
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      cursor?: UserWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * Clinic.providers
   */
  export type Clinic$providersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    where?: ProviderWhereInput;
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[];
    cursor?: ProviderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[];
  };

  /**
   * Clinic.metrics
   */
  export type Clinic$metricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    where?: MetricValueWhereInput;
    orderBy?: MetricValueOrderByWithRelationInput | MetricValueOrderByWithRelationInput[];
    cursor?: MetricValueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MetricValueScalarFieldEnum | MetricValueScalarFieldEnum[];
  };

  /**
   * Clinic.goals
   */
  export type Clinic$goalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Goal
       */
      select?: GoalSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Goal
       */
      omit?: GoalOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: GoalInclude<ExtArgs> | null;
      where?: GoalWhereInput;
      orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[];
      cursor?: GoalWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[];
    };

  /**
   * Clinic without action
   */
  export type ClinicDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null;
  };

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    name: string | null;
    role: string | null;
    lastLogin: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    clinicId: string | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    name: string | null;
    role: string | null;
    lastLogin: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    clinicId: string | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    name: number;
    role: number;
    lastLogin: number;
    createdAt: number;
    updatedAt: number;
    clinicId: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    name?: true;
    role?: true;
    lastLogin?: true;
    createdAt?: true;
    updatedAt?: true;
    clinicId?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    name?: true;
    role?: true;
    lastLogin?: true;
    createdAt?: true;
    updatedAt?: true;
    clinicId?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    name?: true;
    role?: true;
    lastLogin?: true;
    createdAt?: true;
    updatedAt?: true;
    clinicId?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput;
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
      by: UserScalarFieldEnum[] | UserScalarFieldEnum;
      having?: UserScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: UserCountAggregateInputType | true;
      _min?: UserMinAggregateInputType;
      _max?: UserMaxAggregateInputType;
    };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    name: string;
    role: string;
    lastLogin: Date | null;
    createdAt: Date;
    updatedAt: Date;
    clinicId: string;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        email?: boolean;
        name?: boolean;
        role?: boolean;
        lastLogin?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        clinicId?: boolean;
        clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
        dashboards?: boolean | User$dashboardsArgs<ExtArgs>;
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["user"]
    >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      name?: boolean;
      role?: boolean;
      lastLogin?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      clinicId?: boolean;
      clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      name?: boolean;
      role?: boolean;
      lastLogin?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      clinicId?: boolean;
      clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["user"]
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    name?: boolean;
    role?: boolean;
    lastLogin?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    clinicId?: boolean;
  };

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      "id" | "email" | "name" | "role" | "lastLogin" | "createdAt" | "updatedAt" | "clinicId",
      ExtArgs["result"]["user"]
    >;
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
    dashboards?: boolean | User$dashboardsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
  };
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
  };

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User";
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>;
      dashboards: Prisma.$DashboardPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        name: string;
        role: string;
        lastLogin: Date | null;
        createdAt: Date;
        updatedAt: Date;
        clinicId: string;
      },
      ExtArgs["result"]["user"]
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["User"]; meta: { name: "User" } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs["orderBy"] }
        : { orderBy?: UserGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClinicDefaultArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      | $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    dashboards<T extends User$dashboardsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$dashboardsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", "String">;
    readonly email: FieldRef<"User", "String">;
    readonly name: FieldRef<"User", "String">;
    readonly role: FieldRef<"User", "String">;
    readonly lastLogin: FieldRef<"User", "DateTime">;
    readonly createdAt: FieldRef<"User", "DateTime">;
    readonly updatedAt: FieldRef<"User", "DateTime">;
    readonly clinicId: FieldRef<"User", "String">;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `¬±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.dashboards
   */
  export type User$dashboardsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    where?: DashboardWhereInput;
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[];
    cursor?: DashboardWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
    };

  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null;
    _min: ProviderMinAggregateOutputType | null;
    _max: ProviderMaxAggregateOutputType | null;
  };

  export type ProviderMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    providerType: string | null;
    status: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    clinicId: string | null;
  };

  export type ProviderMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    providerType: string | null;
    status: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    clinicId: string | null;
  };

  export type ProviderCountAggregateOutputType = {
    id: number;
    name: number;
    providerType: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    clinicId: number;
    _all: number;
  };

  export type ProviderMinAggregateInputType = {
    id?: true;
    name?: true;
    providerType?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    clinicId?: true;
  };

  export type ProviderMaxAggregateInputType = {
    id?: true;
    name?: true;
    providerType?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    clinicId?: true;
  };

  export type ProviderCountAggregateInputType = {
    id?: true;
    name?: true;
    providerType?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    clinicId?: true;
    _all?: true;
  };

  export type ProviderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Providers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Providers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Providers
     **/
    _count?: true | ProviderCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProviderMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProviderMaxAggregateInputType;
  };

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
    [P in keyof T & keyof AggregateProvider]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>;
  };

  export type ProviderGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProviderWhereInput;
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[];
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum;
    having?: ProviderScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProviderCountAggregateInputType | true;
    _min?: ProviderMinAggregateInputType;
    _max?: ProviderMaxAggregateInputType;
  };

  export type ProviderGroupByOutputType = {
    id: string;
    name: string;
    providerType: string;
    status: string;
    createdAt: Date;
    updatedAt: Date;
    clinicId: string;
    _count: ProviderCountAggregateOutputType | null;
    _min: ProviderMinAggregateOutputType | null;
    _max: ProviderMaxAggregateOutputType | null;
  };

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ProviderGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
          : GetScalarType<T[P], ProviderGroupByOutputType[P]>;
      }
    >
  >;

  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        providerType?: boolean;
        status?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        clinicId?: boolean;
        clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
        metrics?: boolean | Provider$metricsArgs<ExtArgs>;
        goals?: boolean | Provider$goalsArgs<ExtArgs>;
        _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["provider"]
    >;

  export type ProviderSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      providerType?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      clinicId?: boolean;
      clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["provider"]
  >;

  export type ProviderSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      providerType?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      clinicId?: boolean;
      clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["provider"]
  >;

  export type ProviderSelectScalar = {
    id?: boolean;
    name?: boolean;
    providerType?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    clinicId?: boolean;
  };

  export type ProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      "id" | "name" | "providerType" | "status" | "createdAt" | "updatedAt" | "clinicId",
      ExtArgs["result"]["provider"]
    >;
  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
      metrics?: boolean | Provider$metricsArgs<ExtArgs>;
      goals?: boolean | Provider$goalsArgs<ExtArgs>;
      _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type ProviderIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
  };
  export type ProviderIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>;
  };

  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: "Provider";
      objects: {
        clinic: Prisma.$ClinicPayload<ExtArgs>;
        metrics: Prisma.$MetricValuePayload<ExtArgs>[];
        goals: Prisma.$GoalPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          providerType: string;
          status: string;
          createdAt: Date;
          updatedAt: Date;
          clinicId: string;
        },
        ExtArgs["result"]["provider"]
      >;
      composites: {};
    };

  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> =
    $Result.GetResult<Prisma.$ProviderPayload, S>;

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ProviderFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ProviderCountAggregateInputType | true;
  };

  export interface ProviderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Provider"];
      meta: { name: "Provider" };
    };
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderFindUniqueArgs>(
      args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<
        Prisma.$ProviderPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Provider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<
        Prisma.$ProviderPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderFindFirstArgs>(
      args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     *
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProviderFindManyArgs>(
      args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     *
     */
    create<T extends ProviderCreateArgs>(
      args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Providers.
     * @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProviderCreateManyArgs>(
      args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Providers and returns the data saved in the database.
     * @param {ProviderCreateManyAndReturnArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ProviderCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ProviderCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProviderPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     *
     */
    delete<T extends ProviderDeleteArgs>(
      args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProviderUpdateArgs>(
      args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProviderDeleteManyArgs>(
      args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProviderUpdateManyArgs>(
      args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Providers and returns the data updated in the database.
     * @param {ProviderUpdateManyAndReturnArgs} args - Arguments to update many Providers.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ProviderUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ProviderUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProviderPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
     */
    upsert<T extends ProviderUpsertArgs>(
      args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
     **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ProviderCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProviderAggregateArgs>(
      args: Subset<T, ProviderAggregateArgs>
    ): Prisma.PrismaPromise<GetProviderAggregateType<T>>;

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs["orderBy"] }
        : { orderBy?: ProviderGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Provider model
     */
    readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ClinicDefaultArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      | $Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    metrics<T extends Provider$metricsArgs<ExtArgs> = {}>(
      args?: Subset<T, Provider$metricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$MetricValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    goals<T extends Provider$goalsArgs<ExtArgs> = {}>(
      args?: Subset<T, Provider$goalsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Provider model
   */
  interface ProviderFieldRefs {
    readonly id: FieldRef<"Provider", "String">;
    readonly name: FieldRef<"Provider", "String">;
    readonly providerType: FieldRef<"Provider", "String">;
    readonly status: FieldRef<"Provider", "String">;
    readonly createdAt: FieldRef<"Provider", "DateTime">;
    readonly updatedAt: FieldRef<"Provider", "DateTime">;
    readonly clinicId: FieldRef<"Provider", "String">;
  }

  // Custom InputTypes
  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput;
  };

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput;
  };

  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Providers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Providers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[];
  };

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Providers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Providers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[];
  };

  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Providers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Providers.
     */
    skip?: number;
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[];
  };

  /**
   * Provider create
   */
  export type ProviderCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>;
  };

  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Provider createManyAndReturn
   */
  export type ProviderCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Provider update
   */
  export type ProviderUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>;
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput;
  };

  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>;
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput;
    /**
     * Limit how many Providers to update.
     */
    limit?: number;
  };

  /**
   * Provider updateManyAndReturn
   */
  export type ProviderUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>;
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput;
    /**
     * Limit how many Providers to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput;
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>;
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>;
  };

  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput;
  };

  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput;
    /**
     * Limit how many Providers to delete.
     */
    limit?: number;
  };

  /**
   * Provider.metrics
   */
  export type Provider$metricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    where?: MetricValueWhereInput;
    orderBy?: MetricValueOrderByWithRelationInput | MetricValueOrderByWithRelationInput[];
    cursor?: MetricValueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MetricValueScalarFieldEnum | MetricValueScalarFieldEnum[];
  };

  /**
   * Provider.goals
   */
  export type Provider$goalsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    where?: GoalWhereInput;
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[];
    cursor?: GoalWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[];
  };

  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
  };

  /**
   * Model MetricDefinition
   */

  export type AggregateMetricDefinition = {
    _count: MetricDefinitionCountAggregateOutputType | null;
    _min: MetricDefinitionMinAggregateOutputType | null;
    _max: MetricDefinitionMaxAggregateOutputType | null;
  };

  export type MetricDefinitionMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    dataType: string | null;
    calculationFormula: string | null;
    category: string | null;
    isComposite: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MetricDefinitionMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    dataType: string | null;
    calculationFormula: string | null;
    category: string | null;
    isComposite: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MetricDefinitionCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    dataType: number;
    calculationFormula: number;
    category: number;
    isComposite: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type MetricDefinitionMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    dataType?: true;
    calculationFormula?: true;
    category?: true;
    isComposite?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MetricDefinitionMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    dataType?: true;
    calculationFormula?: true;
    category?: true;
    isComposite?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MetricDefinitionCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    dataType?: true;
    calculationFormula?: true;
    category?: true;
    isComposite?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type MetricDefinitionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MetricDefinition to aggregate.
     */
    where?: MetricDefinitionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MetricDefinitions to fetch.
     */
    orderBy?: MetricDefinitionOrderByWithRelationInput | MetricDefinitionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MetricDefinitionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` MetricDefinitions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MetricDefinitions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned MetricDefinitions
     **/
    _count?: true | MetricDefinitionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MetricDefinitionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MetricDefinitionMaxAggregateInputType;
  };

  export type GetMetricDefinitionAggregateType<T extends MetricDefinitionAggregateArgs> = {
    [P in keyof T & keyof AggregateMetricDefinition]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetricDefinition[P]>
      : GetScalarType<T[P], AggregateMetricDefinition[P]>;
  };

  export type MetricDefinitionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MetricDefinitionWhereInput;
    orderBy?:
      | MetricDefinitionOrderByWithAggregationInput
      | MetricDefinitionOrderByWithAggregationInput[];
    by: MetricDefinitionScalarFieldEnum[] | MetricDefinitionScalarFieldEnum;
    having?: MetricDefinitionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MetricDefinitionCountAggregateInputType | true;
    _min?: MetricDefinitionMinAggregateInputType;
    _max?: MetricDefinitionMaxAggregateInputType;
  };

  export type MetricDefinitionGroupByOutputType = {
    id: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula: string | null;
    category: string;
    isComposite: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: MetricDefinitionCountAggregateOutputType | null;
    _min: MetricDefinitionMinAggregateOutputType | null;
    _max: MetricDefinitionMaxAggregateOutputType | null;
  };

  type GetMetricDefinitionGroupByPayload<T extends MetricDefinitionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MetricDefinitionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof MetricDefinitionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetricDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], MetricDefinitionGroupByOutputType[P]>;
        }
      >
    >;

  export type MetricDefinitionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      dataType?: boolean;
      calculationFormula?: boolean;
      category?: boolean;
      isComposite?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      metrics?: boolean | MetricDefinition$metricsArgs<ExtArgs>;
      columnMappings?: boolean | MetricDefinition$columnMappingsArgs<ExtArgs>;
      goals?: boolean | MetricDefinition$goalsArgs<ExtArgs>;
      widgets?: boolean | MetricDefinition$widgetsArgs<ExtArgs>;
      _count?: boolean | MetricDefinitionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["metricDefinition"]
  >;

  export type MetricDefinitionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      dataType?: boolean;
      calculationFormula?: boolean;
      category?: boolean;
      isComposite?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["metricDefinition"]
  >;

  export type MetricDefinitionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      dataType?: boolean;
      calculationFormula?: boolean;
      category?: boolean;
      isComposite?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["metricDefinition"]
  >;

  export type MetricDefinitionSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    dataType?: boolean;
    calculationFormula?: boolean;
    category?: boolean;
    isComposite?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type MetricDefinitionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "name"
    | "description"
    | "dataType"
    | "calculationFormula"
    | "category"
    | "isComposite"
    | "createdAt"
    | "updatedAt",
    ExtArgs["result"]["metricDefinition"]
  >;
  export type MetricDefinitionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    metrics?: boolean | MetricDefinition$metricsArgs<ExtArgs>;
    columnMappings?: boolean | MetricDefinition$columnMappingsArgs<ExtArgs>;
    goals?: boolean | MetricDefinition$goalsArgs<ExtArgs>;
    widgets?: boolean | MetricDefinition$widgetsArgs<ExtArgs>;
    _count?: boolean | MetricDefinitionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type MetricDefinitionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type MetricDefinitionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $MetricDefinitionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "MetricDefinition";
    objects: {
      metrics: Prisma.$MetricValuePayload<ExtArgs>[];
      columnMappings: Prisma.$ColumnMappingPayload<ExtArgs>[];
      goals: Prisma.$GoalPayload<ExtArgs>[];
      widgets: Prisma.$WidgetPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string;
        dataType: string;
        calculationFormula: string | null;
        category: string;
        isComposite: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["metricDefinition"]
    >;
    composites: {};
  };

  type MetricDefinitionGetPayload<
    S extends boolean | null | undefined | MetricDefinitionDefaultArgs,
  > = $Result.GetResult<Prisma.$MetricDefinitionPayload, S>;

  type MetricDefinitionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<MetricDefinitionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: MetricDefinitionCountAggregateInputType | true;
  };

  export interface MetricDefinitionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["MetricDefinition"];
      meta: { name: "MetricDefinition" };
    };
    /**
     * Find zero or one MetricDefinition that matches the filter.
     * @param {MetricDefinitionFindUniqueArgs} args - Arguments to find a MetricDefinition
     * @example
     * // Get one MetricDefinition
     * const metricDefinition = await prisma.metricDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetricDefinitionFindUniqueArgs>(
      args: SelectSubset<T, MetricDefinitionFindUniqueArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      $Result.GetResult<
        Prisma.$MetricDefinitionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one MetricDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetricDefinitionFindUniqueOrThrowArgs} args - Arguments to find a MetricDefinition
     * @example
     * // Get one MetricDefinition
     * const metricDefinition = await prisma.metricDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetricDefinitionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MetricDefinitionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      $Result.GetResult<
        Prisma.$MetricDefinitionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MetricDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricDefinitionFindFirstArgs} args - Arguments to find a MetricDefinition
     * @example
     * // Get one MetricDefinition
     * const metricDefinition = await prisma.metricDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetricDefinitionFindFirstArgs>(
      args?: SelectSubset<T, MetricDefinitionFindFirstArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      $Result.GetResult<
        Prisma.$MetricDefinitionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MetricDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricDefinitionFindFirstOrThrowArgs} args - Arguments to find a MetricDefinition
     * @example
     * // Get one MetricDefinition
     * const metricDefinition = await prisma.metricDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetricDefinitionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MetricDefinitionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      $Result.GetResult<
        Prisma.$MetricDefinitionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more MetricDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetricDefinitions
     * const metricDefinitions = await prisma.metricDefinition.findMany()
     *
     * // Get first 10 MetricDefinitions
     * const metricDefinitions = await prisma.metricDefinition.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const metricDefinitionWithIdOnly = await prisma.metricDefinition.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MetricDefinitionFindManyArgs>(
      args?: SelectSubset<T, MetricDefinitionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MetricDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a MetricDefinition.
     * @param {MetricDefinitionCreateArgs} args - Arguments to create a MetricDefinition.
     * @example
     * // Create one MetricDefinition
     * const MetricDefinition = await prisma.metricDefinition.create({
     *   data: {
     *     // ... data to create a MetricDefinition
     *   }
     * })
     *
     */
    create<T extends MetricDefinitionCreateArgs>(
      args: SelectSubset<T, MetricDefinitionCreateArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      $Result.GetResult<Prisma.$MetricDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many MetricDefinitions.
     * @param {MetricDefinitionCreateManyArgs} args - Arguments to create many MetricDefinitions.
     * @example
     * // Create many MetricDefinitions
     * const metricDefinition = await prisma.metricDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MetricDefinitionCreateManyArgs>(
      args?: SelectSubset<T, MetricDefinitionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many MetricDefinitions and returns the data saved in the database.
     * @param {MetricDefinitionCreateManyAndReturnArgs} args - Arguments to create many MetricDefinitions.
     * @example
     * // Create many MetricDefinitions
     * const metricDefinition = await prisma.metricDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many MetricDefinitions and only return the `id`
     * const metricDefinitionWithIdOnly = await prisma.metricDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MetricDefinitionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MetricDefinitionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MetricDefinitionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a MetricDefinition.
     * @param {MetricDefinitionDeleteArgs} args - Arguments to delete one MetricDefinition.
     * @example
     * // Delete one MetricDefinition
     * const MetricDefinition = await prisma.metricDefinition.delete({
     *   where: {
     *     // ... filter to delete one MetricDefinition
     *   }
     * })
     *
     */
    delete<T extends MetricDefinitionDeleteArgs>(
      args: SelectSubset<T, MetricDefinitionDeleteArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      $Result.GetResult<Prisma.$MetricDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one MetricDefinition.
     * @param {MetricDefinitionUpdateArgs} args - Arguments to update one MetricDefinition.
     * @example
     * // Update one MetricDefinition
     * const metricDefinition = await prisma.metricDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MetricDefinitionUpdateArgs>(
      args: SelectSubset<T, MetricDefinitionUpdateArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      $Result.GetResult<Prisma.$MetricDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more MetricDefinitions.
     * @param {MetricDefinitionDeleteManyArgs} args - Arguments to filter MetricDefinitions to delete.
     * @example
     * // Delete a few MetricDefinitions
     * const { count } = await prisma.metricDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MetricDefinitionDeleteManyArgs>(
      args?: SelectSubset<T, MetricDefinitionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MetricDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetricDefinitions
     * const metricDefinition = await prisma.metricDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MetricDefinitionUpdateManyArgs>(
      args: SelectSubset<T, MetricDefinitionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MetricDefinitions and returns the data updated in the database.
     * @param {MetricDefinitionUpdateManyAndReturnArgs} args - Arguments to update many MetricDefinitions.
     * @example
     * // Update many MetricDefinitions
     * const metricDefinition = await prisma.metricDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more MetricDefinitions and only return the `id`
     * const metricDefinitionWithIdOnly = await prisma.metricDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MetricDefinitionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MetricDefinitionUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MetricDefinitionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one MetricDefinition.
     * @param {MetricDefinitionUpsertArgs} args - Arguments to update or create a MetricDefinition.
     * @example
     * // Update or create a MetricDefinition
     * const metricDefinition = await prisma.metricDefinition.upsert({
     *   create: {
     *     // ... data to create a MetricDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetricDefinition we want to update
     *   }
     * })
     */
    upsert<T extends MetricDefinitionUpsertArgs>(
      args: SelectSubset<T, MetricDefinitionUpsertArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      $Result.GetResult<Prisma.$MetricDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of MetricDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricDefinitionCountArgs} args - Arguments to filter MetricDefinitions to count.
     * @example
     * // Count the number of MetricDefinitions
     * const count = await prisma.metricDefinition.count({
     *   where: {
     *     // ... the filter for the MetricDefinitions we want to count
     *   }
     * })
     **/
    count<T extends MetricDefinitionCountArgs>(
      args?: Subset<T, MetricDefinitionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], MetricDefinitionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a MetricDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MetricDefinitionAggregateArgs>(
      args: Subset<T, MetricDefinitionAggregateArgs>
    ): Prisma.PrismaPromise<GetMetricDefinitionAggregateType<T>>;

    /**
     * Group by MetricDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MetricDefinitionGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetricDefinitionGroupByArgs["orderBy"] }
        : { orderBy?: MetricDefinitionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MetricDefinitionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetMetricDefinitionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the MetricDefinition model
     */
    readonly fields: MetricDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MetricDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetricDefinitionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    metrics<T extends MetricDefinition$metricsArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricDefinition$metricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$MetricValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    columnMappings<T extends MetricDefinition$columnMappingsArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricDefinition$columnMappingsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ColumnMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    goals<T extends MetricDefinition$goalsArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricDefinition$goalsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    widgets<T extends MetricDefinition$widgetsArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricDefinition$widgetsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the MetricDefinition model
   */
  interface MetricDefinitionFieldRefs {
    readonly id: FieldRef<"MetricDefinition", "String">;
    readonly name: FieldRef<"MetricDefinition", "String">;
    readonly description: FieldRef<"MetricDefinition", "String">;
    readonly dataType: FieldRef<"MetricDefinition", "String">;
    readonly calculationFormula: FieldRef<"MetricDefinition", "String">;
    readonly category: FieldRef<"MetricDefinition", "String">;
    readonly isComposite: FieldRef<"MetricDefinition", "Boolean">;
    readonly createdAt: FieldRef<"MetricDefinition", "DateTime">;
    readonly updatedAt: FieldRef<"MetricDefinition", "DateTime">;
  }

  // Custom InputTypes
  /**
   * MetricDefinition findUnique
   */
  export type MetricDefinitionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    /**
     * Filter, which MetricDefinition to fetch.
     */
    where: MetricDefinitionWhereUniqueInput;
  };

  /**
   * MetricDefinition findUniqueOrThrow
   */
  export type MetricDefinitionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    /**
     * Filter, which MetricDefinition to fetch.
     */
    where: MetricDefinitionWhereUniqueInput;
  };

  /**
   * MetricDefinition findFirst
   */
  export type MetricDefinitionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    /**
     * Filter, which MetricDefinition to fetch.
     */
    where?: MetricDefinitionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MetricDefinitions to fetch.
     */
    orderBy?: MetricDefinitionOrderByWithRelationInput | MetricDefinitionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MetricDefinitions.
     */
    cursor?: MetricDefinitionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` MetricDefinitions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MetricDefinitions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MetricDefinitions.
     */
    distinct?: MetricDefinitionScalarFieldEnum | MetricDefinitionScalarFieldEnum[];
  };

  /**
   * MetricDefinition findFirstOrThrow
   */
  export type MetricDefinitionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    /**
     * Filter, which MetricDefinition to fetch.
     */
    where?: MetricDefinitionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MetricDefinitions to fetch.
     */
    orderBy?: MetricDefinitionOrderByWithRelationInput | MetricDefinitionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MetricDefinitions.
     */
    cursor?: MetricDefinitionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` MetricDefinitions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MetricDefinitions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MetricDefinitions.
     */
    distinct?: MetricDefinitionScalarFieldEnum | MetricDefinitionScalarFieldEnum[];
  };

  /**
   * MetricDefinition findMany
   */
  export type MetricDefinitionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    /**
     * Filter, which MetricDefinitions to fetch.
     */
    where?: MetricDefinitionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MetricDefinitions to fetch.
     */
    orderBy?: MetricDefinitionOrderByWithRelationInput | MetricDefinitionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing MetricDefinitions.
     */
    cursor?: MetricDefinitionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` MetricDefinitions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MetricDefinitions.
     */
    skip?: number;
    distinct?: MetricDefinitionScalarFieldEnum | MetricDefinitionScalarFieldEnum[];
  };

  /**
   * MetricDefinition create
   */
  export type MetricDefinitionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    /**
     * The data needed to create a MetricDefinition.
     */
    data: XOR<MetricDefinitionCreateInput, MetricDefinitionUncheckedCreateInput>;
  };

  /**
   * MetricDefinition createMany
   */
  export type MetricDefinitionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many MetricDefinitions.
     */
    data: MetricDefinitionCreateManyInput | MetricDefinitionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * MetricDefinition createManyAndReturn
   */
  export type MetricDefinitionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * The data used to create many MetricDefinitions.
     */
    data: MetricDefinitionCreateManyInput | MetricDefinitionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * MetricDefinition update
   */
  export type MetricDefinitionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    /**
     * The data needed to update a MetricDefinition.
     */
    data: XOR<MetricDefinitionUpdateInput, MetricDefinitionUncheckedUpdateInput>;
    /**
     * Choose, which MetricDefinition to update.
     */
    where: MetricDefinitionWhereUniqueInput;
  };

  /**
   * MetricDefinition updateMany
   */
  export type MetricDefinitionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update MetricDefinitions.
     */
    data: XOR<MetricDefinitionUpdateManyMutationInput, MetricDefinitionUncheckedUpdateManyInput>;
    /**
     * Filter which MetricDefinitions to update
     */
    where?: MetricDefinitionWhereInput;
    /**
     * Limit how many MetricDefinitions to update.
     */
    limit?: number;
  };

  /**
   * MetricDefinition updateManyAndReturn
   */
  export type MetricDefinitionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * The data used to update MetricDefinitions.
     */
    data: XOR<MetricDefinitionUpdateManyMutationInput, MetricDefinitionUncheckedUpdateManyInput>;
    /**
     * Filter which MetricDefinitions to update
     */
    where?: MetricDefinitionWhereInput;
    /**
     * Limit how many MetricDefinitions to update.
     */
    limit?: number;
  };

  /**
   * MetricDefinition upsert
   */
  export type MetricDefinitionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    /**
     * The filter to search for the MetricDefinition to update in case it exists.
     */
    where: MetricDefinitionWhereUniqueInput;
    /**
     * In case the MetricDefinition found by the `where` argument doesn't exist, create a new MetricDefinition with this data.
     */
    create: XOR<MetricDefinitionCreateInput, MetricDefinitionUncheckedCreateInput>;
    /**
     * In case the MetricDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetricDefinitionUpdateInput, MetricDefinitionUncheckedUpdateInput>;
  };

  /**
   * MetricDefinition delete
   */
  export type MetricDefinitionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    /**
     * Filter which MetricDefinition to delete.
     */
    where: MetricDefinitionWhereUniqueInput;
  };

  /**
   * MetricDefinition deleteMany
   */
  export type MetricDefinitionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MetricDefinitions to delete
     */
    where?: MetricDefinitionWhereInput;
    /**
     * Limit how many MetricDefinitions to delete.
     */
    limit?: number;
  };

  /**
   * MetricDefinition.metrics
   */
  export type MetricDefinition$metricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    where?: MetricValueWhereInput;
    orderBy?: MetricValueOrderByWithRelationInput | MetricValueOrderByWithRelationInput[];
    cursor?: MetricValueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MetricValueScalarFieldEnum | MetricValueScalarFieldEnum[];
  };

  /**
   * MetricDefinition.columnMappings
   */
  export type MetricDefinition$columnMappingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    where?: ColumnMappingWhereInput;
    orderBy?: ColumnMappingOrderByWithRelationInput | ColumnMappingOrderByWithRelationInput[];
    cursor?: ColumnMappingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ColumnMappingScalarFieldEnum | ColumnMappingScalarFieldEnum[];
  };

  /**
   * MetricDefinition.goals
   */
  export type MetricDefinition$goalsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    where?: GoalWhereInput;
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[];
    cursor?: GoalWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[];
  };

  /**
   * MetricDefinition.widgets
   */
  export type MetricDefinition$widgetsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null;
    where?: WidgetWhereInput;
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[];
    cursor?: WidgetWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[];
  };

  /**
   * MetricDefinition without action
   */
  export type MetricDefinitionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
  };

  /**
   * Model DataSource
   */

  export type AggregateDataSource = {
    _count: DataSourceCountAggregateOutputType | null;
    _min: DataSourceMinAggregateOutputType | null;
    _max: DataSourceMaxAggregateOutputType | null;
  };

  export type DataSourceMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    spreadsheetId: string | null;
    sheetName: string | null;
    lastSyncedAt: Date | null;
    syncFrequency: string | null;
    connectionStatus: string | null;
    appScriptId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type DataSourceMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    spreadsheetId: string | null;
    sheetName: string | null;
    lastSyncedAt: Date | null;
    syncFrequency: string | null;
    connectionStatus: string | null;
    appScriptId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type DataSourceCountAggregateOutputType = {
    id: number;
    name: number;
    spreadsheetId: number;
    sheetName: number;
    lastSyncedAt: number;
    syncFrequency: number;
    connectionStatus: number;
    appScriptId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type DataSourceMinAggregateInputType = {
    id?: true;
    name?: true;
    spreadsheetId?: true;
    sheetName?: true;
    lastSyncedAt?: true;
    syncFrequency?: true;
    connectionStatus?: true;
    appScriptId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type DataSourceMaxAggregateInputType = {
    id?: true;
    name?: true;
    spreadsheetId?: true;
    sheetName?: true;
    lastSyncedAt?: true;
    syncFrequency?: true;
    connectionStatus?: true;
    appScriptId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type DataSourceCountAggregateInputType = {
    id?: true;
    name?: true;
    spreadsheetId?: true;
    sheetName?: true;
    lastSyncedAt?: true;
    syncFrequency?: true;
    connectionStatus?: true;
    appScriptId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type DataSourceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DataSource to aggregate.
     */
    where?: DataSourceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DataSources to fetch.
     */
    orderBy?: DataSourceOrderByWithRelationInput | DataSourceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DataSourceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` DataSources from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DataSources.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DataSources
     **/
    _count?: true | DataSourceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DataSourceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DataSourceMaxAggregateInputType;
  };

  export type GetDataSourceAggregateType<T extends DataSourceAggregateArgs> = {
    [P in keyof T & keyof AggregateDataSource]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataSource[P]>
      : GetScalarType<T[P], AggregateDataSource[P]>;
  };

  export type DataSourceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DataSourceWhereInput;
    orderBy?: DataSourceOrderByWithAggregationInput | DataSourceOrderByWithAggregationInput[];
    by: DataSourceScalarFieldEnum[] | DataSourceScalarFieldEnum;
    having?: DataSourceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DataSourceCountAggregateInputType | true;
    _min?: DataSourceMinAggregateInputType;
    _max?: DataSourceMaxAggregateInputType;
  };

  export type DataSourceGroupByOutputType = {
    id: string;
    name: string;
    spreadsheetId: string;
    sheetName: string;
    lastSyncedAt: Date | null;
    syncFrequency: string;
    connectionStatus: string;
    appScriptId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: DataSourceCountAggregateOutputType | null;
    _min: DataSourceMinAggregateOutputType | null;
    _max: DataSourceMaxAggregateOutputType | null;
  };

  type GetDataSourceGroupByPayload<T extends DataSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataSourceGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof DataSourceGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], DataSourceGroupByOutputType[P]>
          : GetScalarType<T[P], DataSourceGroupByOutputType[P]>;
      }
    >
  >;

  export type DataSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        spreadsheetId?: boolean;
        sheetName?: boolean;
        lastSyncedAt?: boolean;
        syncFrequency?: boolean;
        connectionStatus?: boolean;
        appScriptId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        columnMappings?: boolean | DataSource$columnMappingsArgs<ExtArgs>;
        metrics?: boolean | DataSource$metricsArgs<ExtArgs>;
        _count?: boolean | DataSourceCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["dataSource"]
    >;

  export type DataSourceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      spreadsheetId?: boolean;
      sheetName?: boolean;
      lastSyncedAt?: boolean;
      syncFrequency?: boolean;
      connectionStatus?: boolean;
      appScriptId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["dataSource"]
  >;

  export type DataSourceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      spreadsheetId?: boolean;
      sheetName?: boolean;
      lastSyncedAt?: boolean;
      syncFrequency?: boolean;
      connectionStatus?: boolean;
      appScriptId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs["result"]["dataSource"]
  >;

  export type DataSourceSelectScalar = {
    id?: boolean;
    name?: boolean;
    spreadsheetId?: boolean;
    sheetName?: boolean;
    lastSyncedAt?: boolean;
    syncFrequency?: boolean;
    connectionStatus?: boolean;
    appScriptId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type DataSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "name"
      | "spreadsheetId"
      | "sheetName"
      | "lastSyncedAt"
      | "syncFrequency"
      | "connectionStatus"
      | "appScriptId"
      | "createdAt"
      | "updatedAt",
      ExtArgs["result"]["dataSource"]
    >;
  export type DataSourceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    columnMappings?: boolean | DataSource$columnMappingsArgs<ExtArgs>;
    metrics?: boolean | DataSource$metricsArgs<ExtArgs>;
    _count?: boolean | DataSourceCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type DataSourceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type DataSourceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $DataSourcePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "DataSource";
    objects: {
      columnMappings: Prisma.$ColumnMappingPayload<ExtArgs>[];
      metrics: Prisma.$MetricValuePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        spreadsheetId: string;
        sheetName: string;
        lastSyncedAt: Date | null;
        syncFrequency: string;
        connectionStatus: string;
        appScriptId: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs["result"]["dataSource"]
    >;
    composites: {};
  };

  type DataSourceGetPayload<S extends boolean | null | undefined | DataSourceDefaultArgs> =
    $Result.GetResult<Prisma.$DataSourcePayload, S>;

  type DataSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataSourceFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: DataSourceCountAggregateInputType | true;
    };

  export interface DataSourceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["DataSource"];
      meta: { name: "DataSource" };
    };
    /**
     * Find zero or one DataSource that matches the filter.
     * @param {DataSourceFindUniqueArgs} args - Arguments to find a DataSource
     * @example
     * // Get one DataSource
     * const dataSource = await prisma.dataSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataSourceFindUniqueArgs>(
      args: SelectSubset<T, DataSourceFindUniqueArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      $Result.GetResult<
        Prisma.$DataSourcePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one DataSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataSourceFindUniqueOrThrowArgs} args - Arguments to find a DataSource
     * @example
     * // Get one DataSource
     * const dataSource = await prisma.dataSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataSourceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DataSourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      $Result.GetResult<
        Prisma.$DataSourcePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DataSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceFindFirstArgs} args - Arguments to find a DataSource
     * @example
     * // Get one DataSource
     * const dataSource = await prisma.dataSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataSourceFindFirstArgs>(
      args?: SelectSubset<T, DataSourceFindFirstArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      $Result.GetResult<
        Prisma.$DataSourcePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DataSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceFindFirstOrThrowArgs} args - Arguments to find a DataSource
     * @example
     * // Get one DataSource
     * const dataSource = await prisma.dataSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataSourceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DataSourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      $Result.GetResult<
        Prisma.$DataSourcePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more DataSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataSources
     * const dataSources = await prisma.dataSource.findMany()
     *
     * // Get first 10 DataSources
     * const dataSources = await prisma.dataSource.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const dataSourceWithIdOnly = await prisma.dataSource.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DataSourceFindManyArgs>(
      args?: SelectSubset<T, DataSourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a DataSource.
     * @param {DataSourceCreateArgs} args - Arguments to create a DataSource.
     * @example
     * // Create one DataSource
     * const DataSource = await prisma.dataSource.create({
     *   data: {
     *     // ... data to create a DataSource
     *   }
     * })
     *
     */
    create<T extends DataSourceCreateArgs>(
      args: SelectSubset<T, DataSourceCreateArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      $Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many DataSources.
     * @param {DataSourceCreateManyArgs} args - Arguments to create many DataSources.
     * @example
     * // Create many DataSources
     * const dataSource = await prisma.dataSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DataSourceCreateManyArgs>(
      args?: SelectSubset<T, DataSourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many DataSources and returns the data saved in the database.
     * @param {DataSourceCreateManyAndReturnArgs} args - Arguments to create many DataSources.
     * @example
     * // Create many DataSources
     * const dataSource = await prisma.dataSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DataSources and only return the `id`
     * const dataSourceWithIdOnly = await prisma.dataSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DataSourceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DataSourceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DataSourcePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a DataSource.
     * @param {DataSourceDeleteArgs} args - Arguments to delete one DataSource.
     * @example
     * // Delete one DataSource
     * const DataSource = await prisma.dataSource.delete({
     *   where: {
     *     // ... filter to delete one DataSource
     *   }
     * })
     *
     */
    delete<T extends DataSourceDeleteArgs>(
      args: SelectSubset<T, DataSourceDeleteArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      $Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one DataSource.
     * @param {DataSourceUpdateArgs} args - Arguments to update one DataSource.
     * @example
     * // Update one DataSource
     * const dataSource = await prisma.dataSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DataSourceUpdateArgs>(
      args: SelectSubset<T, DataSourceUpdateArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      $Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more DataSources.
     * @param {DataSourceDeleteManyArgs} args - Arguments to filter DataSources to delete.
     * @example
     * // Delete a few DataSources
     * const { count } = await prisma.dataSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DataSourceDeleteManyArgs>(
      args?: SelectSubset<T, DataSourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DataSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataSources
     * const dataSource = await prisma.dataSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DataSourceUpdateManyArgs>(
      args: SelectSubset<T, DataSourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DataSources and returns the data updated in the database.
     * @param {DataSourceUpdateManyAndReturnArgs} args - Arguments to update many DataSources.
     * @example
     * // Update many DataSources
     * const dataSource = await prisma.dataSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DataSources and only return the `id`
     * const dataSourceWithIdOnly = await prisma.dataSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DataSourceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DataSourceUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DataSourcePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one DataSource.
     * @param {DataSourceUpsertArgs} args - Arguments to update or create a DataSource.
     * @example
     * // Update or create a DataSource
     * const dataSource = await prisma.dataSource.upsert({
     *   create: {
     *     // ... data to create a DataSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataSource we want to update
     *   }
     * })
     */
    upsert<T extends DataSourceUpsertArgs>(
      args: SelectSubset<T, DataSourceUpsertArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      $Result.GetResult<Prisma.$DataSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of DataSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceCountArgs} args - Arguments to filter DataSources to count.
     * @example
     * // Count the number of DataSources
     * const count = await prisma.dataSource.count({
     *   where: {
     *     // ... the filter for the DataSources we want to count
     *   }
     * })
     **/
    count<T extends DataSourceCountArgs>(
      args?: Subset<T, DataSourceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], DataSourceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a DataSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DataSourceAggregateArgs>(
      args: Subset<T, DataSourceAggregateArgs>
    ): Prisma.PrismaPromise<GetDataSourceAggregateType<T>>;

    /**
     * Group by DataSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DataSourceGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataSourceGroupByArgs["orderBy"] }
        : { orderBy?: DataSourceGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DataSourceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetDataSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the DataSource model
     */
    readonly fields: DataSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataSourceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    columnMappings<T extends DataSource$columnMappingsArgs<ExtArgs> = {}>(
      args?: Subset<T, DataSource$columnMappingsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ColumnMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    metrics<T extends DataSource$metricsArgs<ExtArgs> = {}>(
      args?: Subset<T, DataSource$metricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$MetricValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the DataSource model
   */
  interface DataSourceFieldRefs {
    readonly id: FieldRef<"DataSource", "String">;
    readonly name: FieldRef<"DataSource", "String">;
    readonly spreadsheetId: FieldRef<"DataSource", "String">;
    readonly sheetName: FieldRef<"DataSource", "String">;
    readonly lastSyncedAt: FieldRef<"DataSource", "DateTime">;
    readonly syncFrequency: FieldRef<"DataSource", "String">;
    readonly connectionStatus: FieldRef<"DataSource", "String">;
    readonly appScriptId: FieldRef<"DataSource", "String">;
    readonly createdAt: FieldRef<"DataSource", "DateTime">;
    readonly updatedAt: FieldRef<"DataSource", "DateTime">;
  }

  // Custom InputTypes
  /**
   * DataSource findUnique
   */
  export type DataSourceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    /**
     * Filter, which DataSource to fetch.
     */
    where: DataSourceWhereUniqueInput;
  };

  /**
   * DataSource findUniqueOrThrow
   */
  export type DataSourceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    /**
     * Filter, which DataSource to fetch.
     */
    where: DataSourceWhereUniqueInput;
  };

  /**
   * DataSource findFirst
   */
  export type DataSourceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    /**
     * Filter, which DataSource to fetch.
     */
    where?: DataSourceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DataSources to fetch.
     */
    orderBy?: DataSourceOrderByWithRelationInput | DataSourceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DataSources.
     */
    cursor?: DataSourceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` DataSources from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DataSources.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DataSources.
     */
    distinct?: DataSourceScalarFieldEnum | DataSourceScalarFieldEnum[];
  };

  /**
   * DataSource findFirstOrThrow
   */
  export type DataSourceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    /**
     * Filter, which DataSource to fetch.
     */
    where?: DataSourceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DataSources to fetch.
     */
    orderBy?: DataSourceOrderByWithRelationInput | DataSourceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DataSources.
     */
    cursor?: DataSourceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` DataSources from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DataSources.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DataSources.
     */
    distinct?: DataSourceScalarFieldEnum | DataSourceScalarFieldEnum[];
  };

  /**
   * DataSource findMany
   */
  export type DataSourceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    /**
     * Filter, which DataSources to fetch.
     */
    where?: DataSourceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DataSources to fetch.
     */
    orderBy?: DataSourceOrderByWithRelationInput | DataSourceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DataSources.
     */
    cursor?: DataSourceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` DataSources from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DataSources.
     */
    skip?: number;
    distinct?: DataSourceScalarFieldEnum | DataSourceScalarFieldEnum[];
  };

  /**
   * DataSource create
   */
  export type DataSourceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    /**
     * The data needed to create a DataSource.
     */
    data: XOR<DataSourceCreateInput, DataSourceUncheckedCreateInput>;
  };

  /**
   * DataSource createMany
   */
  export type DataSourceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DataSources.
     */
    data: DataSourceCreateManyInput | DataSourceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DataSource createManyAndReturn
   */
  export type DataSourceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * The data used to create many DataSources.
     */
    data: DataSourceCreateManyInput | DataSourceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DataSource update
   */
  export type DataSourceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    /**
     * The data needed to update a DataSource.
     */
    data: XOR<DataSourceUpdateInput, DataSourceUncheckedUpdateInput>;
    /**
     * Choose, which DataSource to update.
     */
    where: DataSourceWhereUniqueInput;
  };

  /**
   * DataSource updateMany
   */
  export type DataSourceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DataSources.
     */
    data: XOR<DataSourceUpdateManyMutationInput, DataSourceUncheckedUpdateManyInput>;
    /**
     * Filter which DataSources to update
     */
    where?: DataSourceWhereInput;
    /**
     * Limit how many DataSources to update.
     */
    limit?: number;
  };

  /**
   * DataSource updateManyAndReturn
   */
  export type DataSourceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * The data used to update DataSources.
     */
    data: XOR<DataSourceUpdateManyMutationInput, DataSourceUncheckedUpdateManyInput>;
    /**
     * Filter which DataSources to update
     */
    where?: DataSourceWhereInput;
    /**
     * Limit how many DataSources to update.
     */
    limit?: number;
  };

  /**
   * DataSource upsert
   */
  export type DataSourceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    /**
     * The filter to search for the DataSource to update in case it exists.
     */
    where: DataSourceWhereUniqueInput;
    /**
     * In case the DataSource found by the `where` argument doesn't exist, create a new DataSource with this data.
     */
    create: XOR<DataSourceCreateInput, DataSourceUncheckedCreateInput>;
    /**
     * In case the DataSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataSourceUpdateInput, DataSourceUncheckedUpdateInput>;
  };

  /**
   * DataSource delete
   */
  export type DataSourceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    /**
     * Filter which DataSource to delete.
     */
    where: DataSourceWhereUniqueInput;
  };

  /**
   * DataSource deleteMany
   */
  export type DataSourceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DataSources to delete
     */
    where?: DataSourceWhereInput;
    /**
     * Limit how many DataSources to delete.
     */
    limit?: number;
  };

  /**
   * DataSource.columnMappings
   */
  export type DataSource$columnMappingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    where?: ColumnMappingWhereInput;
    orderBy?: ColumnMappingOrderByWithRelationInput | ColumnMappingOrderByWithRelationInput[];
    cursor?: ColumnMappingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ColumnMappingScalarFieldEnum | ColumnMappingScalarFieldEnum[];
  };

  /**
   * DataSource.metrics
   */
  export type DataSource$metricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    where?: MetricValueWhereInput;
    orderBy?: MetricValueOrderByWithRelationInput | MetricValueOrderByWithRelationInput[];
    cursor?: MetricValueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MetricValueScalarFieldEnum | MetricValueScalarFieldEnum[];
  };

  /**
   * DataSource without action
   */
  export type DataSourceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
  };

  /**
   * Model ColumnMapping
   */

  export type AggregateColumnMapping = {
    _count: ColumnMappingCountAggregateOutputType | null;
    _min: ColumnMappingMinAggregateOutputType | null;
    _max: ColumnMappingMaxAggregateOutputType | null;
  };

  export type ColumnMappingMinAggregateOutputType = {
    id: string | null;
    columnName: string | null;
    transformationRule: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    dataSourceId: string | null;
    metricDefinitionId: string | null;
  };

  export type ColumnMappingMaxAggregateOutputType = {
    id: string | null;
    columnName: string | null;
    transformationRule: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    dataSourceId: string | null;
    metricDefinitionId: string | null;
  };

  export type ColumnMappingCountAggregateOutputType = {
    id: number;
    columnName: number;
    transformationRule: number;
    createdAt: number;
    updatedAt: number;
    dataSourceId: number;
    metricDefinitionId: number;
    _all: number;
  };

  export type ColumnMappingMinAggregateInputType = {
    id?: true;
    columnName?: true;
    transformationRule?: true;
    createdAt?: true;
    updatedAt?: true;
    dataSourceId?: true;
    metricDefinitionId?: true;
  };

  export type ColumnMappingMaxAggregateInputType = {
    id?: true;
    columnName?: true;
    transformationRule?: true;
    createdAt?: true;
    updatedAt?: true;
    dataSourceId?: true;
    metricDefinitionId?: true;
  };

  export type ColumnMappingCountAggregateInputType = {
    id?: true;
    columnName?: true;
    transformationRule?: true;
    createdAt?: true;
    updatedAt?: true;
    dataSourceId?: true;
    metricDefinitionId?: true;
    _all?: true;
  };

  export type ColumnMappingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ColumnMapping to aggregate.
     */
    where?: ColumnMappingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ColumnMappings to fetch.
     */
    orderBy?: ColumnMappingOrderByWithRelationInput | ColumnMappingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ColumnMappingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` ColumnMappings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ColumnMappings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ColumnMappings
     **/
    _count?: true | ColumnMappingCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ColumnMappingMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ColumnMappingMaxAggregateInputType;
  };

  export type GetColumnMappingAggregateType<T extends ColumnMappingAggregateArgs> = {
    [P in keyof T & keyof AggregateColumnMapping]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColumnMapping[P]>
      : GetScalarType<T[P], AggregateColumnMapping[P]>;
  };

  export type ColumnMappingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ColumnMappingWhereInput;
    orderBy?: ColumnMappingOrderByWithAggregationInput | ColumnMappingOrderByWithAggregationInput[];
    by: ColumnMappingScalarFieldEnum[] | ColumnMappingScalarFieldEnum;
    having?: ColumnMappingScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ColumnMappingCountAggregateInputType | true;
    _min?: ColumnMappingMinAggregateInputType;
    _max?: ColumnMappingMaxAggregateInputType;
  };

  export type ColumnMappingGroupByOutputType = {
    id: string;
    columnName: string;
    transformationRule: string | null;
    createdAt: Date;
    updatedAt: Date;
    dataSourceId: string;
    metricDefinitionId: string;
    _count: ColumnMappingCountAggregateOutputType | null;
    _min: ColumnMappingMinAggregateOutputType | null;
    _max: ColumnMappingMaxAggregateOutputType | null;
  };

  type GetColumnMappingGroupByPayload<T extends ColumnMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColumnMappingGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ColumnMappingGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ColumnMappingGroupByOutputType[P]>
          : GetScalarType<T[P], ColumnMappingGroupByOutputType[P]>;
      }
    >
  >;

  export type ColumnMappingSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      columnName?: boolean;
      transformationRule?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      dataSourceId?: boolean;
      metricDefinitionId?: boolean;
      dataSource?: boolean | DataSourceDefaultArgs<ExtArgs>;
      metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["columnMapping"]
  >;

  export type ColumnMappingSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      columnName?: boolean;
      transformationRule?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      dataSourceId?: boolean;
      metricDefinitionId?: boolean;
      dataSource?: boolean | DataSourceDefaultArgs<ExtArgs>;
      metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["columnMapping"]
  >;

  export type ColumnMappingSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      columnName?: boolean;
      transformationRule?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      dataSourceId?: boolean;
      metricDefinitionId?: boolean;
      dataSource?: boolean | DataSourceDefaultArgs<ExtArgs>;
      metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["columnMapping"]
  >;

  export type ColumnMappingSelectScalar = {
    id?: boolean;
    columnName?: boolean;
    transformationRule?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    dataSourceId?: boolean;
    metricDefinitionId?: boolean;
  };

  export type ColumnMappingOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "id"
    | "columnName"
    | "transformationRule"
    | "createdAt"
    | "updatedAt"
    | "dataSourceId"
    | "metricDefinitionId",
    ExtArgs["result"]["columnMapping"]
  >;
  export type ColumnMappingInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    dataSource?: boolean | DataSourceDefaultArgs<ExtArgs>;
    metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
  };
  export type ColumnMappingIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    dataSource?: boolean | DataSourceDefaultArgs<ExtArgs>;
    metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
  };
  export type ColumnMappingIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    dataSource?: boolean | DataSourceDefaultArgs<ExtArgs>;
    metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
  };

  export type $ColumnMappingPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "ColumnMapping";
    objects: {
      dataSource: Prisma.$DataSourcePayload<ExtArgs>;
      metricDefinition: Prisma.$MetricDefinitionPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        columnName: string;
        transformationRule: string | null;
        createdAt: Date;
        updatedAt: Date;
        dataSourceId: string;
        metricDefinitionId: string;
      },
      ExtArgs["result"]["columnMapping"]
    >;
    composites: {};
  };

  type ColumnMappingGetPayload<S extends boolean | null | undefined | ColumnMappingDefaultArgs> =
    $Result.GetResult<Prisma.$ColumnMappingPayload, S>;

  type ColumnMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ColumnMappingFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: ColumnMappingCountAggregateInputType | true;
    };

  export interface ColumnMappingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["ColumnMapping"];
      meta: { name: "ColumnMapping" };
    };
    /**
     * Find zero or one ColumnMapping that matches the filter.
     * @param {ColumnMappingFindUniqueArgs} args - Arguments to find a ColumnMapping
     * @example
     * // Get one ColumnMapping
     * const columnMapping = await prisma.columnMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColumnMappingFindUniqueArgs>(
      args: SelectSubset<T, ColumnMappingFindUniqueArgs<ExtArgs>>
    ): Prisma__ColumnMappingClient<
      $Result.GetResult<
        Prisma.$ColumnMappingPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ColumnMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ColumnMappingFindUniqueOrThrowArgs} args - Arguments to find a ColumnMapping
     * @example
     * // Get one ColumnMapping
     * const columnMapping = await prisma.columnMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColumnMappingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ColumnMappingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ColumnMappingClient<
      $Result.GetResult<
        Prisma.$ColumnMappingPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ColumnMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnMappingFindFirstArgs} args - Arguments to find a ColumnMapping
     * @example
     * // Get one ColumnMapping
     * const columnMapping = await prisma.columnMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColumnMappingFindFirstArgs>(
      args?: SelectSubset<T, ColumnMappingFindFirstArgs<ExtArgs>>
    ): Prisma__ColumnMappingClient<
      $Result.GetResult<
        Prisma.$ColumnMappingPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ColumnMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnMappingFindFirstOrThrowArgs} args - Arguments to find a ColumnMapping
     * @example
     * // Get one ColumnMapping
     * const columnMapping = await prisma.columnMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColumnMappingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ColumnMappingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ColumnMappingClient<
      $Result.GetResult<
        Prisma.$ColumnMappingPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ColumnMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ColumnMappings
     * const columnMappings = await prisma.columnMapping.findMany()
     *
     * // Get first 10 ColumnMappings
     * const columnMappings = await prisma.columnMapping.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const columnMappingWithIdOnly = await prisma.columnMapping.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ColumnMappingFindManyArgs>(
      args?: SelectSubset<T, ColumnMappingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ColumnMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a ColumnMapping.
     * @param {ColumnMappingCreateArgs} args - Arguments to create a ColumnMapping.
     * @example
     * // Create one ColumnMapping
     * const ColumnMapping = await prisma.columnMapping.create({
     *   data: {
     *     // ... data to create a ColumnMapping
     *   }
     * })
     *
     */
    create<T extends ColumnMappingCreateArgs>(
      args: SelectSubset<T, ColumnMappingCreateArgs<ExtArgs>>
    ): Prisma__ColumnMappingClient<
      $Result.GetResult<Prisma.$ColumnMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ColumnMappings.
     * @param {ColumnMappingCreateManyArgs} args - Arguments to create many ColumnMappings.
     * @example
     * // Create many ColumnMappings
     * const columnMapping = await prisma.columnMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ColumnMappingCreateManyArgs>(
      args?: SelectSubset<T, ColumnMappingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ColumnMappings and returns the data saved in the database.
     * @param {ColumnMappingCreateManyAndReturnArgs} args - Arguments to create many ColumnMappings.
     * @example
     * // Create many ColumnMappings
     * const columnMapping = await prisma.columnMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ColumnMappings and only return the `id`
     * const columnMappingWithIdOnly = await prisma.columnMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ColumnMappingCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ColumnMappingCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ColumnMappingPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ColumnMapping.
     * @param {ColumnMappingDeleteArgs} args - Arguments to delete one ColumnMapping.
     * @example
     * // Delete one ColumnMapping
     * const ColumnMapping = await prisma.columnMapping.delete({
     *   where: {
     *     // ... filter to delete one ColumnMapping
     *   }
     * })
     *
     */
    delete<T extends ColumnMappingDeleteArgs>(
      args: SelectSubset<T, ColumnMappingDeleteArgs<ExtArgs>>
    ): Prisma__ColumnMappingClient<
      $Result.GetResult<Prisma.$ColumnMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ColumnMapping.
     * @param {ColumnMappingUpdateArgs} args - Arguments to update one ColumnMapping.
     * @example
     * // Update one ColumnMapping
     * const columnMapping = await prisma.columnMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ColumnMappingUpdateArgs>(
      args: SelectSubset<T, ColumnMappingUpdateArgs<ExtArgs>>
    ): Prisma__ColumnMappingClient<
      $Result.GetResult<Prisma.$ColumnMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ColumnMappings.
     * @param {ColumnMappingDeleteManyArgs} args - Arguments to filter ColumnMappings to delete.
     * @example
     * // Delete a few ColumnMappings
     * const { count } = await prisma.columnMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ColumnMappingDeleteManyArgs>(
      args?: SelectSubset<T, ColumnMappingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ColumnMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ColumnMappings
     * const columnMapping = await prisma.columnMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ColumnMappingUpdateManyArgs>(
      args: SelectSubset<T, ColumnMappingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ColumnMappings and returns the data updated in the database.
     * @param {ColumnMappingUpdateManyAndReturnArgs} args - Arguments to update many ColumnMappings.
     * @example
     * // Update many ColumnMappings
     * const columnMapping = await prisma.columnMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ColumnMappings and only return the `id`
     * const columnMappingWithIdOnly = await prisma.columnMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ColumnMappingUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ColumnMappingUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ColumnMappingPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ColumnMapping.
     * @param {ColumnMappingUpsertArgs} args - Arguments to update or create a ColumnMapping.
     * @example
     * // Update or create a ColumnMapping
     * const columnMapping = await prisma.columnMapping.upsert({
     *   create: {
     *     // ... data to create a ColumnMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ColumnMapping we want to update
     *   }
     * })
     */
    upsert<T extends ColumnMappingUpsertArgs>(
      args: SelectSubset<T, ColumnMappingUpsertArgs<ExtArgs>>
    ): Prisma__ColumnMappingClient<
      $Result.GetResult<Prisma.$ColumnMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ColumnMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnMappingCountArgs} args - Arguments to filter ColumnMappings to count.
     * @example
     * // Count the number of ColumnMappings
     * const count = await prisma.columnMapping.count({
     *   where: {
     *     // ... the filter for the ColumnMappings we want to count
     *   }
     * })
     **/
    count<T extends ColumnMappingCountArgs>(
      args?: Subset<T, ColumnMappingCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ColumnMappingCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ColumnMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ColumnMappingAggregateArgs>(
      args: Subset<T, ColumnMappingAggregateArgs>
    ): Prisma.PrismaPromise<GetColumnMappingAggregateType<T>>;

    /**
     * Group by ColumnMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColumnMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ColumnMappingGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColumnMappingGroupByArgs["orderBy"] }
        : { orderBy?: ColumnMappingGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ColumnMappingGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetColumnMappingGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ColumnMapping model
     */
    readonly fields: ColumnMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ColumnMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColumnMappingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    dataSource<T extends DataSourceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, DataSourceDefaultArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      | $Result.GetResult<
          Prisma.$DataSourcePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    metricDefinition<T extends MetricDefinitionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricDefinitionDefaultArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      | $Result.GetResult<
          Prisma.$MetricDefinitionPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ColumnMapping model
   */
  interface ColumnMappingFieldRefs {
    readonly id: FieldRef<"ColumnMapping", "String">;
    readonly columnName: FieldRef<"ColumnMapping", "String">;
    readonly transformationRule: FieldRef<"ColumnMapping", "String">;
    readonly createdAt: FieldRef<"ColumnMapping", "DateTime">;
    readonly updatedAt: FieldRef<"ColumnMapping", "DateTime">;
    readonly dataSourceId: FieldRef<"ColumnMapping", "String">;
    readonly metricDefinitionId: FieldRef<"ColumnMapping", "String">;
  }

  // Custom InputTypes
  /**
   * ColumnMapping findUnique
   */
  export type ColumnMappingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    /**
     * Filter, which ColumnMapping to fetch.
     */
    where: ColumnMappingWhereUniqueInput;
  };

  /**
   * ColumnMapping findUniqueOrThrow
   */
  export type ColumnMappingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    /**
     * Filter, which ColumnMapping to fetch.
     */
    where: ColumnMappingWhereUniqueInput;
  };

  /**
   * ColumnMapping findFirst
   */
  export type ColumnMappingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    /**
     * Filter, which ColumnMapping to fetch.
     */
    where?: ColumnMappingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ColumnMappings to fetch.
     */
    orderBy?: ColumnMappingOrderByWithRelationInput | ColumnMappingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ColumnMappings.
     */
    cursor?: ColumnMappingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` ColumnMappings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ColumnMappings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ColumnMappings.
     */
    distinct?: ColumnMappingScalarFieldEnum | ColumnMappingScalarFieldEnum[];
  };

  /**
   * ColumnMapping findFirstOrThrow
   */
  export type ColumnMappingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    /**
     * Filter, which ColumnMapping to fetch.
     */
    where?: ColumnMappingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ColumnMappings to fetch.
     */
    orderBy?: ColumnMappingOrderByWithRelationInput | ColumnMappingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ColumnMappings.
     */
    cursor?: ColumnMappingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` ColumnMappings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ColumnMappings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ColumnMappings.
     */
    distinct?: ColumnMappingScalarFieldEnum | ColumnMappingScalarFieldEnum[];
  };

  /**
   * ColumnMapping findMany
   */
  export type ColumnMappingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    /**
     * Filter, which ColumnMappings to fetch.
     */
    where?: ColumnMappingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ColumnMappings to fetch.
     */
    orderBy?: ColumnMappingOrderByWithRelationInput | ColumnMappingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ColumnMappings.
     */
    cursor?: ColumnMappingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` ColumnMappings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ColumnMappings.
     */
    skip?: number;
    distinct?: ColumnMappingScalarFieldEnum | ColumnMappingScalarFieldEnum[];
  };

  /**
   * ColumnMapping create
   */
  export type ColumnMappingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    /**
     * The data needed to create a ColumnMapping.
     */
    data: XOR<ColumnMappingCreateInput, ColumnMappingUncheckedCreateInput>;
  };

  /**
   * ColumnMapping createMany
   */
  export type ColumnMappingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ColumnMappings.
     */
    data: ColumnMappingCreateManyInput | ColumnMappingCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ColumnMapping createManyAndReturn
   */
  export type ColumnMappingCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * The data used to create many ColumnMappings.
     */
    data: ColumnMappingCreateManyInput | ColumnMappingCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ColumnMapping update
   */
  export type ColumnMappingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    /**
     * The data needed to update a ColumnMapping.
     */
    data: XOR<ColumnMappingUpdateInput, ColumnMappingUncheckedUpdateInput>;
    /**
     * Choose, which ColumnMapping to update.
     */
    where: ColumnMappingWhereUniqueInput;
  };

  /**
   * ColumnMapping updateMany
   */
  export type ColumnMappingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ColumnMappings.
     */
    data: XOR<ColumnMappingUpdateManyMutationInput, ColumnMappingUncheckedUpdateManyInput>;
    /**
     * Filter which ColumnMappings to update
     */
    where?: ColumnMappingWhereInput;
    /**
     * Limit how many ColumnMappings to update.
     */
    limit?: number;
  };

  /**
   * ColumnMapping updateManyAndReturn
   */
  export type ColumnMappingUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * The data used to update ColumnMappings.
     */
    data: XOR<ColumnMappingUpdateManyMutationInput, ColumnMappingUncheckedUpdateManyInput>;
    /**
     * Filter which ColumnMappings to update
     */
    where?: ColumnMappingWhereInput;
    /**
     * Limit how many ColumnMappings to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ColumnMapping upsert
   */
  export type ColumnMappingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    /**
     * The filter to search for the ColumnMapping to update in case it exists.
     */
    where: ColumnMappingWhereUniqueInput;
    /**
     * In case the ColumnMapping found by the `where` argument doesn't exist, create a new ColumnMapping with this data.
     */
    create: XOR<ColumnMappingCreateInput, ColumnMappingUncheckedCreateInput>;
    /**
     * In case the ColumnMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColumnMappingUpdateInput, ColumnMappingUncheckedUpdateInput>;
  };

  /**
   * ColumnMapping delete
   */
  export type ColumnMappingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
    /**
     * Filter which ColumnMapping to delete.
     */
    where: ColumnMappingWhereUniqueInput;
  };

  /**
   * ColumnMapping deleteMany
   */
  export type ColumnMappingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ColumnMappings to delete
     */
    where?: ColumnMappingWhereInput;
    /**
     * Limit how many ColumnMappings to delete.
     */
    limit?: number;
  };

  /**
   * ColumnMapping without action
   */
  export type ColumnMappingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ColumnMapping
     */
    select?: ColumnMappingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ColumnMapping
     */
    omit?: ColumnMappingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColumnMappingInclude<ExtArgs> | null;
  };

  /**
   * Model MetricValue
   */

  export type AggregateMetricValue = {
    _count: MetricValueCountAggregateOutputType | null;
    _min: MetricValueMinAggregateOutputType | null;
    _max: MetricValueMaxAggregateOutputType | null;
  };

  export type MetricValueMinAggregateOutputType = {
    id: string | null;
    date: Date | null;
    value: string | null;
    sourceType: string | null;
    sourceSheet: string | null;
    externalId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    metricDefinitionId: string | null;
    clinicId: string | null;
    providerId: string | null;
    dataSourceId: string | null;
  };

  export type MetricValueMaxAggregateOutputType = {
    id: string | null;
    date: Date | null;
    value: string | null;
    sourceType: string | null;
    sourceSheet: string | null;
    externalId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    metricDefinitionId: string | null;
    clinicId: string | null;
    providerId: string | null;
    dataSourceId: string | null;
  };

  export type MetricValueCountAggregateOutputType = {
    id: number;
    date: number;
    value: number;
    sourceType: number;
    sourceSheet: number;
    externalId: number;
    createdAt: number;
    updatedAt: number;
    metricDefinitionId: number;
    clinicId: number;
    providerId: number;
    dataSourceId: number;
    _all: number;
  };

  export type MetricValueMinAggregateInputType = {
    id?: true;
    date?: true;
    value?: true;
    sourceType?: true;
    sourceSheet?: true;
    externalId?: true;
    createdAt?: true;
    updatedAt?: true;
    metricDefinitionId?: true;
    clinicId?: true;
    providerId?: true;
    dataSourceId?: true;
  };

  export type MetricValueMaxAggregateInputType = {
    id?: true;
    date?: true;
    value?: true;
    sourceType?: true;
    sourceSheet?: true;
    externalId?: true;
    createdAt?: true;
    updatedAt?: true;
    metricDefinitionId?: true;
    clinicId?: true;
    providerId?: true;
    dataSourceId?: true;
  };

  export type MetricValueCountAggregateInputType = {
    id?: true;
    date?: true;
    value?: true;
    sourceType?: true;
    sourceSheet?: true;
    externalId?: true;
    createdAt?: true;
    updatedAt?: true;
    metricDefinitionId?: true;
    clinicId?: true;
    providerId?: true;
    dataSourceId?: true;
    _all?: true;
  };

  export type MetricValueAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MetricValue to aggregate.
     */
    where?: MetricValueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MetricValues to fetch.
     */
    orderBy?: MetricValueOrderByWithRelationInput | MetricValueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MetricValueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` MetricValues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MetricValues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned MetricValues
     **/
    _count?: true | MetricValueCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MetricValueMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MetricValueMaxAggregateInputType;
  };

  export type GetMetricValueAggregateType<T extends MetricValueAggregateArgs> = {
    [P in keyof T & keyof AggregateMetricValue]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetricValue[P]>
      : GetScalarType<T[P], AggregateMetricValue[P]>;
  };

  export type MetricValueGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MetricValueWhereInput;
    orderBy?: MetricValueOrderByWithAggregationInput | MetricValueOrderByWithAggregationInput[];
    by: MetricValueScalarFieldEnum[] | MetricValueScalarFieldEnum;
    having?: MetricValueScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MetricValueCountAggregateInputType | true;
    _min?: MetricValueMinAggregateInputType;
    _max?: MetricValueMaxAggregateInputType;
  };

  export type MetricValueGroupByOutputType = {
    id: string;
    date: Date;
    value: string;
    sourceType: string;
    sourceSheet: string | null;
    externalId: string | null;
    createdAt: Date;
    updatedAt: Date;
    metricDefinitionId: string;
    clinicId: string | null;
    providerId: string | null;
    dataSourceId: string | null;
    _count: MetricValueCountAggregateOutputType | null;
    _min: MetricValueMinAggregateOutputType | null;
    _max: MetricValueMaxAggregateOutputType | null;
  };

  type GetMetricValueGroupByPayload<T extends MetricValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetricValueGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof MetricValueGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], MetricValueGroupByOutputType[P]>
          : GetScalarType<T[P], MetricValueGroupByOutputType[P]>;
      }
    >
  >;

  export type MetricValueSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      date?: boolean;
      value?: boolean;
      sourceType?: boolean;
      sourceSheet?: boolean;
      externalId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      metricDefinitionId?: boolean;
      clinicId?: boolean;
      providerId?: boolean;
      dataSourceId?: boolean;
      metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
      clinic?: boolean | MetricValue$clinicArgs<ExtArgs>;
      provider?: boolean | MetricValue$providerArgs<ExtArgs>;
      dataSource?: boolean | MetricValue$dataSourceArgs<ExtArgs>;
    },
    ExtArgs["result"]["metricValue"]
  >;

  export type MetricValueSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      date?: boolean;
      value?: boolean;
      sourceType?: boolean;
      sourceSheet?: boolean;
      externalId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      metricDefinitionId?: boolean;
      clinicId?: boolean;
      providerId?: boolean;
      dataSourceId?: boolean;
      metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
      clinic?: boolean | MetricValue$clinicArgs<ExtArgs>;
      provider?: boolean | MetricValue$providerArgs<ExtArgs>;
      dataSource?: boolean | MetricValue$dataSourceArgs<ExtArgs>;
    },
    ExtArgs["result"]["metricValue"]
  >;

  export type MetricValueSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      date?: boolean;
      value?: boolean;
      sourceType?: boolean;
      sourceSheet?: boolean;
      externalId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      metricDefinitionId?: boolean;
      clinicId?: boolean;
      providerId?: boolean;
      dataSourceId?: boolean;
      metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
      clinic?: boolean | MetricValue$clinicArgs<ExtArgs>;
      provider?: boolean | MetricValue$providerArgs<ExtArgs>;
      dataSource?: boolean | MetricValue$dataSourceArgs<ExtArgs>;
    },
    ExtArgs["result"]["metricValue"]
  >;

  export type MetricValueSelectScalar = {
    id?: boolean;
    date?: boolean;
    value?: boolean;
    sourceType?: boolean;
    sourceSheet?: boolean;
    externalId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    metricDefinitionId?: boolean;
    clinicId?: boolean;
    providerId?: boolean;
    dataSourceId?: boolean;
  };

  export type MetricValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "date"
      | "value"
      | "sourceType"
      | "sourceSheet"
      | "externalId"
      | "createdAt"
      | "updatedAt"
      | "metricDefinitionId"
      | "clinicId"
      | "providerId"
      | "dataSourceId",
      ExtArgs["result"]["metricValue"]
    >;
  export type MetricValueInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
    clinic?: boolean | MetricValue$clinicArgs<ExtArgs>;
    provider?: boolean | MetricValue$providerArgs<ExtArgs>;
    dataSource?: boolean | MetricValue$dataSourceArgs<ExtArgs>;
  };
  export type MetricValueIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
    clinic?: boolean | MetricValue$clinicArgs<ExtArgs>;
    provider?: boolean | MetricValue$providerArgs<ExtArgs>;
    dataSource?: boolean | MetricValue$dataSourceArgs<ExtArgs>;
  };
  export type MetricValueIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
    clinic?: boolean | MetricValue$clinicArgs<ExtArgs>;
    provider?: boolean | MetricValue$providerArgs<ExtArgs>;
    dataSource?: boolean | MetricValue$dataSourceArgs<ExtArgs>;
  };

  export type $MetricValuePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "MetricValue";
    objects: {
      metricDefinition: Prisma.$MetricDefinitionPayload<ExtArgs>;
      clinic: Prisma.$ClinicPayload<ExtArgs> | null;
      provider: Prisma.$ProviderPayload<ExtArgs> | null;
      dataSource: Prisma.$DataSourcePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        date: Date;
        value: string;
        sourceType: string;
        sourceSheet: string | null;
        externalId: string | null;
        createdAt: Date;
        updatedAt: Date;
        metricDefinitionId: string;
        clinicId: string | null;
        providerId: string | null;
        dataSourceId: string | null;
      },
      ExtArgs["result"]["metricValue"]
    >;
    composites: {};
  };

  type MetricValueGetPayload<S extends boolean | null | undefined | MetricValueDefaultArgs> =
    $Result.GetResult<Prisma.$MetricValuePayload, S>;

  type MetricValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetricValueFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: MetricValueCountAggregateInputType | true;
    };

  export interface MetricValueDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["MetricValue"];
      meta: { name: "MetricValue" };
    };
    /**
     * Find zero or one MetricValue that matches the filter.
     * @param {MetricValueFindUniqueArgs} args - Arguments to find a MetricValue
     * @example
     * // Get one MetricValue
     * const metricValue = await prisma.metricValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetricValueFindUniqueArgs>(
      args: SelectSubset<T, MetricValueFindUniqueArgs<ExtArgs>>
    ): Prisma__MetricValueClient<
      $Result.GetResult<
        Prisma.$MetricValuePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one MetricValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetricValueFindUniqueOrThrowArgs} args - Arguments to find a MetricValue
     * @example
     * // Get one MetricValue
     * const metricValue = await prisma.metricValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetricValueFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MetricValueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MetricValueClient<
      $Result.GetResult<
        Prisma.$MetricValuePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MetricValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricValueFindFirstArgs} args - Arguments to find a MetricValue
     * @example
     * // Get one MetricValue
     * const metricValue = await prisma.metricValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetricValueFindFirstArgs>(
      args?: SelectSubset<T, MetricValueFindFirstArgs<ExtArgs>>
    ): Prisma__MetricValueClient<
      $Result.GetResult<
        Prisma.$MetricValuePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first MetricValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricValueFindFirstOrThrowArgs} args - Arguments to find a MetricValue
     * @example
     * // Get one MetricValue
     * const metricValue = await prisma.metricValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetricValueFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MetricValueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MetricValueClient<
      $Result.GetResult<
        Prisma.$MetricValuePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more MetricValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetricValues
     * const metricValues = await prisma.metricValue.findMany()
     *
     * // Get first 10 MetricValues
     * const metricValues = await prisma.metricValue.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const metricValueWithIdOnly = await prisma.metricValue.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MetricValueFindManyArgs>(
      args?: SelectSubset<T, MetricValueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MetricValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a MetricValue.
     * @param {MetricValueCreateArgs} args - Arguments to create a MetricValue.
     * @example
     * // Create one MetricValue
     * const MetricValue = await prisma.metricValue.create({
     *   data: {
     *     // ... data to create a MetricValue
     *   }
     * })
     *
     */
    create<T extends MetricValueCreateArgs>(
      args: SelectSubset<T, MetricValueCreateArgs<ExtArgs>>
    ): Prisma__MetricValueClient<
      $Result.GetResult<Prisma.$MetricValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many MetricValues.
     * @param {MetricValueCreateManyArgs} args - Arguments to create many MetricValues.
     * @example
     * // Create many MetricValues
     * const metricValue = await prisma.metricValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MetricValueCreateManyArgs>(
      args?: SelectSubset<T, MetricValueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many MetricValues and returns the data saved in the database.
     * @param {MetricValueCreateManyAndReturnArgs} args - Arguments to create many MetricValues.
     * @example
     * // Create many MetricValues
     * const metricValue = await prisma.metricValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many MetricValues and only return the `id`
     * const metricValueWithIdOnly = await prisma.metricValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MetricValueCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MetricValueCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MetricValuePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a MetricValue.
     * @param {MetricValueDeleteArgs} args - Arguments to delete one MetricValue.
     * @example
     * // Delete one MetricValue
     * const MetricValue = await prisma.metricValue.delete({
     *   where: {
     *     // ... filter to delete one MetricValue
     *   }
     * })
     *
     */
    delete<T extends MetricValueDeleteArgs>(
      args: SelectSubset<T, MetricValueDeleteArgs<ExtArgs>>
    ): Prisma__MetricValueClient<
      $Result.GetResult<Prisma.$MetricValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one MetricValue.
     * @param {MetricValueUpdateArgs} args - Arguments to update one MetricValue.
     * @example
     * // Update one MetricValue
     * const metricValue = await prisma.metricValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MetricValueUpdateArgs>(
      args: SelectSubset<T, MetricValueUpdateArgs<ExtArgs>>
    ): Prisma__MetricValueClient<
      $Result.GetResult<Prisma.$MetricValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more MetricValues.
     * @param {MetricValueDeleteManyArgs} args - Arguments to filter MetricValues to delete.
     * @example
     * // Delete a few MetricValues
     * const { count } = await prisma.metricValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MetricValueDeleteManyArgs>(
      args?: SelectSubset<T, MetricValueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MetricValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetricValues
     * const metricValue = await prisma.metricValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MetricValueUpdateManyArgs>(
      args: SelectSubset<T, MetricValueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MetricValues and returns the data updated in the database.
     * @param {MetricValueUpdateManyAndReturnArgs} args - Arguments to update many MetricValues.
     * @example
     * // Update many MetricValues
     * const metricValue = await prisma.metricValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more MetricValues and only return the `id`
     * const metricValueWithIdOnly = await prisma.metricValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends MetricValueUpdateManyAndReturnArgs>(
      args: SelectSubset<T, MetricValueUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MetricValuePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one MetricValue.
     * @param {MetricValueUpsertArgs} args - Arguments to update or create a MetricValue.
     * @example
     * // Update or create a MetricValue
     * const metricValue = await prisma.metricValue.upsert({
     *   create: {
     *     // ... data to create a MetricValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetricValue we want to update
     *   }
     * })
     */
    upsert<T extends MetricValueUpsertArgs>(
      args: SelectSubset<T, MetricValueUpsertArgs<ExtArgs>>
    ): Prisma__MetricValueClient<
      $Result.GetResult<Prisma.$MetricValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of MetricValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricValueCountArgs} args - Arguments to filter MetricValues to count.
     * @example
     * // Count the number of MetricValues
     * const count = await prisma.metricValue.count({
     *   where: {
     *     // ... the filter for the MetricValues we want to count
     *   }
     * })
     **/
    count<T extends MetricValueCountArgs>(
      args?: Subset<T, MetricValueCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], MetricValueCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a MetricValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MetricValueAggregateArgs>(
      args: Subset<T, MetricValueAggregateArgs>
    ): Prisma.PrismaPromise<GetMetricValueAggregateType<T>>;

    /**
     * Group by MetricValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MetricValueGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetricValueGroupByArgs["orderBy"] }
        : { orderBy?: MetricValueGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MetricValueGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetMetricValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the MetricValue model
     */
    readonly fields: MetricValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MetricValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetricValueClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    metricDefinition<T extends MetricDefinitionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricDefinitionDefaultArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      | $Result.GetResult<
          Prisma.$MetricDefinitionPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    clinic<T extends MetricValue$clinicArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricValue$clinicArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<
        Prisma.$ClinicPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    provider<T extends MetricValue$providerArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricValue$providerArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<
        Prisma.$ProviderPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    dataSource<T extends MetricValue$dataSourceArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricValue$dataSourceArgs<ExtArgs>>
    ): Prisma__DataSourceClient<
      $Result.GetResult<
        Prisma.$DataSourcePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the MetricValue model
   */
  interface MetricValueFieldRefs {
    readonly id: FieldRef<"MetricValue", "String">;
    readonly date: FieldRef<"MetricValue", "DateTime">;
    readonly value: FieldRef<"MetricValue", "String">;
    readonly sourceType: FieldRef<"MetricValue", "String">;
    readonly sourceSheet: FieldRef<"MetricValue", "String">;
    readonly externalId: FieldRef<"MetricValue", "String">;
    readonly createdAt: FieldRef<"MetricValue", "DateTime">;
    readonly updatedAt: FieldRef<"MetricValue", "DateTime">;
    readonly metricDefinitionId: FieldRef<"MetricValue", "String">;
    readonly clinicId: FieldRef<"MetricValue", "String">;
    readonly providerId: FieldRef<"MetricValue", "String">;
    readonly dataSourceId: FieldRef<"MetricValue", "String">;
  }

  // Custom InputTypes
  /**
   * MetricValue findUnique
   */
  export type MetricValueFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    /**
     * Filter, which MetricValue to fetch.
     */
    where: MetricValueWhereUniqueInput;
  };

  /**
   * MetricValue findUniqueOrThrow
   */
  export type MetricValueFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    /**
     * Filter, which MetricValue to fetch.
     */
    where: MetricValueWhereUniqueInput;
  };

  /**
   * MetricValue findFirst
   */
  export type MetricValueFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    /**
     * Filter, which MetricValue to fetch.
     */
    where?: MetricValueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MetricValues to fetch.
     */
    orderBy?: MetricValueOrderByWithRelationInput | MetricValueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MetricValues.
     */
    cursor?: MetricValueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` MetricValues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MetricValues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MetricValues.
     */
    distinct?: MetricValueScalarFieldEnum | MetricValueScalarFieldEnum[];
  };

  /**
   * MetricValue findFirstOrThrow
   */
  export type MetricValueFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    /**
     * Filter, which MetricValue to fetch.
     */
    where?: MetricValueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MetricValues to fetch.
     */
    orderBy?: MetricValueOrderByWithRelationInput | MetricValueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MetricValues.
     */
    cursor?: MetricValueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` MetricValues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MetricValues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MetricValues.
     */
    distinct?: MetricValueScalarFieldEnum | MetricValueScalarFieldEnum[];
  };

  /**
   * MetricValue findMany
   */
  export type MetricValueFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    /**
     * Filter, which MetricValues to fetch.
     */
    where?: MetricValueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MetricValues to fetch.
     */
    orderBy?: MetricValueOrderByWithRelationInput | MetricValueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing MetricValues.
     */
    cursor?: MetricValueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` MetricValues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MetricValues.
     */
    skip?: number;
    distinct?: MetricValueScalarFieldEnum | MetricValueScalarFieldEnum[];
  };

  /**
   * MetricValue create
   */
  export type MetricValueCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    /**
     * The data needed to create a MetricValue.
     */
    data: XOR<MetricValueCreateInput, MetricValueUncheckedCreateInput>;
  };

  /**
   * MetricValue createMany
   */
  export type MetricValueCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many MetricValues.
     */
    data: MetricValueCreateManyInput | MetricValueCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * MetricValue createManyAndReturn
   */
  export type MetricValueCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * The data used to create many MetricValues.
     */
    data: MetricValueCreateManyInput | MetricValueCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MetricValue update
   */
  export type MetricValueUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    /**
     * The data needed to update a MetricValue.
     */
    data: XOR<MetricValueUpdateInput, MetricValueUncheckedUpdateInput>;
    /**
     * Choose, which MetricValue to update.
     */
    where: MetricValueWhereUniqueInput;
  };

  /**
   * MetricValue updateMany
   */
  export type MetricValueUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update MetricValues.
     */
    data: XOR<MetricValueUpdateManyMutationInput, MetricValueUncheckedUpdateManyInput>;
    /**
     * Filter which MetricValues to update
     */
    where?: MetricValueWhereInput;
    /**
     * Limit how many MetricValues to update.
     */
    limit?: number;
  };

  /**
   * MetricValue updateManyAndReturn
   */
  export type MetricValueUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * The data used to update MetricValues.
     */
    data: XOR<MetricValueUpdateManyMutationInput, MetricValueUncheckedUpdateManyInput>;
    /**
     * Filter which MetricValues to update
     */
    where?: MetricValueWhereInput;
    /**
     * Limit how many MetricValues to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MetricValue upsert
   */
  export type MetricValueUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    /**
     * The filter to search for the MetricValue to update in case it exists.
     */
    where: MetricValueWhereUniqueInput;
    /**
     * In case the MetricValue found by the `where` argument doesn't exist, create a new MetricValue with this data.
     */
    create: XOR<MetricValueCreateInput, MetricValueUncheckedCreateInput>;
    /**
     * In case the MetricValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetricValueUpdateInput, MetricValueUncheckedUpdateInput>;
  };

  /**
   * MetricValue delete
   */
  export type MetricValueDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
    /**
     * Filter which MetricValue to delete.
     */
    where: MetricValueWhereUniqueInput;
  };

  /**
   * MetricValue deleteMany
   */
  export type MetricValueDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MetricValues to delete
     */
    where?: MetricValueWhereInput;
    /**
     * Limit how many MetricValues to delete.
     */
    limit?: number;
  };

  /**
   * MetricValue.clinic
   */
  export type MetricValue$clinicArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null;
    where?: ClinicWhereInput;
  };

  /**
   * MetricValue.provider
   */
  export type MetricValue$providerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    where?: ProviderWhereInput;
  };

  /**
   * MetricValue.dataSource
   */
  export type MetricValue$dataSourceArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DataSource
     */
    select?: DataSourceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DataSource
     */
    omit?: DataSourceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataSourceInclude<ExtArgs> | null;
    where?: DataSourceWhereInput;
  };

  /**
   * MetricValue without action
   */
  export type MetricValueDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricValue
     */
    select?: MetricValueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricValue
     */
    omit?: MetricValueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricValueInclude<ExtArgs> | null;
  };

  /**
   * Model Goal
   */

  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null;
    _min: GoalMinAggregateOutputType | null;
    _max: GoalMaxAggregateOutputType | null;
  };

  export type GoalMinAggregateOutputType = {
    id: string | null;
    timePeriod: string | null;
    startDate: Date | null;
    endDate: Date | null;
    targetValue: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    metricDefinitionId: string | null;
    clinicId: string | null;
    providerId: string | null;
  };

  export type GoalMaxAggregateOutputType = {
    id: string | null;
    timePeriod: string | null;
    startDate: Date | null;
    endDate: Date | null;
    targetValue: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    metricDefinitionId: string | null;
    clinicId: string | null;
    providerId: string | null;
  };

  export type GoalCountAggregateOutputType = {
    id: number;
    timePeriod: number;
    startDate: number;
    endDate: number;
    targetValue: number;
    createdAt: number;
    updatedAt: number;
    metricDefinitionId: number;
    clinicId: number;
    providerId: number;
    _all: number;
  };

  export type GoalMinAggregateInputType = {
    id?: true;
    timePeriod?: true;
    startDate?: true;
    endDate?: true;
    targetValue?: true;
    createdAt?: true;
    updatedAt?: true;
    metricDefinitionId?: true;
    clinicId?: true;
    providerId?: true;
  };

  export type GoalMaxAggregateInputType = {
    id?: true;
    timePeriod?: true;
    startDate?: true;
    endDate?: true;
    targetValue?: true;
    createdAt?: true;
    updatedAt?: true;
    metricDefinitionId?: true;
    clinicId?: true;
    providerId?: true;
  };

  export type GoalCountAggregateInputType = {
    id?: true;
    timePeriod?: true;
    startDate?: true;
    endDate?: true;
    targetValue?: true;
    createdAt?: true;
    updatedAt?: true;
    metricDefinitionId?: true;
    clinicId?: true;
    providerId?: true;
    _all?: true;
  };

  export type GoalAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Goal to aggregate.
     */
    where?: GoalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: GoalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Goals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Goals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Goals
     **/
    _count?: true | GoalCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: GoalMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: GoalMaxAggregateInputType;
  };

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
    [P in keyof T & keyof AggregateGoal]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>;
  };

  export type GoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: GoalWhereInput;
      orderBy?: GoalOrderByWithAggregationInput | GoalOrderByWithAggregationInput[];
      by: GoalScalarFieldEnum[] | GoalScalarFieldEnum;
      having?: GoalScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: GoalCountAggregateInputType | true;
      _min?: GoalMinAggregateInputType;
      _max?: GoalMaxAggregateInputType;
    };

  export type GoalGroupByOutputType = {
    id: string;
    timePeriod: string;
    startDate: Date;
    endDate: Date;
    targetValue: string;
    createdAt: Date;
    updatedAt: Date;
    metricDefinitionId: string;
    clinicId: string | null;
    providerId: string | null;
    _count: GoalCountAggregateOutputType | null;
    _min: GoalMinAggregateOutputType | null;
    _max: GoalMaxAggregateOutputType | null;
  };

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof GoalGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
          : GetScalarType<T[P], GoalGroupByOutputType[P]>;
      }
    >
  >;

  export type GoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        timePeriod?: boolean;
        startDate?: boolean;
        endDate?: boolean;
        targetValue?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        metricDefinitionId?: boolean;
        clinicId?: boolean;
        providerId?: boolean;
        metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
        clinic?: boolean | Goal$clinicArgs<ExtArgs>;
        provider?: boolean | Goal$providerArgs<ExtArgs>;
      },
      ExtArgs["result"]["goal"]
    >;

  export type GoalSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      timePeriod?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      targetValue?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      metricDefinitionId?: boolean;
      clinicId?: boolean;
      providerId?: boolean;
      metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
      clinic?: boolean | Goal$clinicArgs<ExtArgs>;
      provider?: boolean | Goal$providerArgs<ExtArgs>;
    },
    ExtArgs["result"]["goal"]
  >;

  export type GoalSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      timePeriod?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      targetValue?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      metricDefinitionId?: boolean;
      clinicId?: boolean;
      providerId?: boolean;
      metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
      clinic?: boolean | Goal$clinicArgs<ExtArgs>;
      provider?: boolean | Goal$providerArgs<ExtArgs>;
    },
    ExtArgs["result"]["goal"]
  >;

  export type GoalSelectScalar = {
    id?: boolean;
    timePeriod?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    targetValue?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    metricDefinitionId?: boolean;
    clinicId?: boolean;
    providerId?: boolean;
  };

  export type GoalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "timePeriod"
      | "startDate"
      | "endDate"
      | "targetValue"
      | "createdAt"
      | "updatedAt"
      | "metricDefinitionId"
      | "clinicId"
      | "providerId",
      ExtArgs["result"]["goal"]
    >;
  export type GoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
    clinic?: boolean | Goal$clinicArgs<ExtArgs>;
    provider?: boolean | Goal$providerArgs<ExtArgs>;
  };
  export type GoalIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
    clinic?: boolean | Goal$clinicArgs<ExtArgs>;
    provider?: boolean | Goal$providerArgs<ExtArgs>;
  };
  export type GoalIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    metricDefinition?: boolean | MetricDefinitionDefaultArgs<ExtArgs>;
    clinic?: boolean | Goal$clinicArgs<ExtArgs>;
    provider?: boolean | Goal$providerArgs<ExtArgs>;
  };

  export type $GoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goal";
    objects: {
      metricDefinition: Prisma.$MetricDefinitionPayload<ExtArgs>;
      clinic: Prisma.$ClinicPayload<ExtArgs> | null;
      provider: Prisma.$ProviderPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        timePeriod: string;
        startDate: Date;
        endDate: Date;
        targetValue: string;
        createdAt: Date;
        updatedAt: Date;
        metricDefinitionId: string;
        clinicId: string | null;
        providerId: string | null;
      },
      ExtArgs["result"]["goal"]
    >;
    composites: {};
  };

  type GoalGetPayload<S extends boolean | null | undefined | GoalDefaultArgs> = $Result.GetResult<
    Prisma.$GoalPayload,
    S
  >;

  type GoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    GoalFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: GoalCountAggregateInputType | true;
  };

  export interface GoalDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Goal"]; meta: { name: "Goal" } };
    /**
     * Find zero or one Goal that matches the filter.
     * @param {GoalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalFindUniqueArgs>(
      args: SelectSubset<T, GoalFindUniqueArgs<ExtArgs>>
    ): Prisma__GoalClient<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Goal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalFindUniqueOrThrowArgs>(
      args: SelectSubset<T, GoalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GoalClient<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalFindFirstArgs>(
      args?: SelectSubset<T, GoalFindFirstArgs<ExtArgs>>
    ): Prisma__GoalClient<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Goal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GoalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GoalClient<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     *
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     *
     */
    findMany<T extends GoalFindManyArgs>(
      args?: SelectSubset<T, GoalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Goal.
     * @param {GoalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     *
     */
    create<T extends GoalCreateArgs>(
      args: SelectSubset<T, GoalCreateArgs<ExtArgs>>
    ): Prisma__GoalClient<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Goals.
     * @param {GoalCreateManyArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends GoalCreateManyArgs>(
      args?: SelectSubset<T, GoalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Goals and returns the data saved in the database.
     * @param {GoalCreateManyAndReturnArgs} args - Arguments to create many Goals.
     * @example
     * // Create many Goals
     * const goal = await prisma.goal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends GoalCreateManyAndReturnArgs>(
      args?: SelectSubset<T, GoalCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Goal.
     * @param {GoalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     *
     */
    delete<T extends GoalDeleteArgs>(
      args: SelectSubset<T, GoalDeleteArgs<ExtArgs>>
    ): Prisma__GoalClient<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Goal.
     * @param {GoalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends GoalUpdateArgs>(
      args: SelectSubset<T, GoalUpdateArgs<ExtArgs>>
    ): Prisma__GoalClient<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Goals.
     * @param {GoalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends GoalDeleteManyArgs>(
      args?: SelectSubset<T, GoalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends GoalUpdateManyArgs>(
      args: SelectSubset<T, GoalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Goals and returns the data updated in the database.
     * @param {GoalUpdateManyAndReturnArgs} args - Arguments to update many Goals.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Goals and only return the `id`
     * const goalWithIdOnly = await prisma.goal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends GoalUpdateManyAndReturnArgs>(
      args: SelectSubset<T, GoalUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Goal.
     * @param {GoalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
     */
    upsert<T extends GoalUpsertArgs>(
      args: SelectSubset<T, GoalUpsertArgs<ExtArgs>>
    ): Prisma__GoalClient<
      $Result.GetResult<Prisma.$GoalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
     **/
    count<T extends GoalCountArgs>(
      args?: Subset<T, GoalCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], GoalCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends GoalAggregateArgs>(
      args: Subset<T, GoalAggregateArgs>
    ): Prisma.PrismaPromise<GetGoalAggregateType<T>>;

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs["orderBy"] }
        : { orderBy?: GoalGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Goal model
     */
    readonly fields: GoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    metricDefinition<T extends MetricDefinitionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MetricDefinitionDefaultArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      | $Result.GetResult<
          Prisma.$MetricDefinitionPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    clinic<T extends Goal$clinicArgs<ExtArgs> = {}>(
      args?: Subset<T, Goal$clinicArgs<ExtArgs>>
    ): Prisma__ClinicClient<
      $Result.GetResult<
        Prisma.$ClinicPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    provider<T extends Goal$providerArgs<ExtArgs> = {}>(
      args?: Subset<T, Goal$providerArgs<ExtArgs>>
    ): Prisma__ProviderClient<
      $Result.GetResult<
        Prisma.$ProviderPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Goal model
   */
  interface GoalFieldRefs {
    readonly id: FieldRef<"Goal", "String">;
    readonly timePeriod: FieldRef<"Goal", "String">;
    readonly startDate: FieldRef<"Goal", "DateTime">;
    readonly endDate: FieldRef<"Goal", "DateTime">;
    readonly targetValue: FieldRef<"Goal", "String">;
    readonly createdAt: FieldRef<"Goal", "DateTime">;
    readonly updatedAt: FieldRef<"Goal", "DateTime">;
    readonly metricDefinitionId: FieldRef<"Goal", "String">;
    readonly clinicId: FieldRef<"Goal", "String">;
    readonly providerId: FieldRef<"Goal", "String">;
  }

  // Custom InputTypes
  /**
   * Goal findUnique
   */
  export type GoalFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput;
  };

  /**
   * Goal findUniqueOrThrow
   */
  export type GoalFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    /**
     * Filter, which Goal to fetch.
     */
    where: GoalWhereUniqueInput;
  };

  /**
   * Goal findFirst
   */
  export type GoalFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Goals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Goals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[];
  };

  /**
   * Goal findFirstOrThrow
   */
  export type GoalFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    /**
     * Filter, which Goal to fetch.
     */
    where?: GoalWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Goals to fetch.
     */
    orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Goals.
     */
    cursor?: GoalWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Goals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Goals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Goals.
     */
    distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[];
  };

  /**
   * Goal findMany
   */
  export type GoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Goal
       */
      select?: GoalSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Goal
       */
      omit?: GoalOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: GoalInclude<ExtArgs> | null;
      /**
       * Filter, which Goals to fetch.
       */
      where?: GoalWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Goals to fetch.
       */
      orderBy?: GoalOrderByWithRelationInput | GoalOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Goals.
       */
      cursor?: GoalWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `¬±n` Goals from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Goals.
       */
      skip?: number;
      distinct?: GoalScalarFieldEnum | GoalScalarFieldEnum[];
    };

  /**
   * Goal create
   */
  export type GoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    /**
     * The data needed to create a Goal.
     */
    data: XOR<GoalCreateInput, GoalUncheckedCreateInput>;
  };

  /**
   * Goal createMany
   */
  export type GoalCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Goal createManyAndReturn
   */
  export type GoalCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * The data used to create many Goals.
     */
    data: GoalCreateManyInput | GoalCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Goal update
   */
  export type GoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    /**
     * The data needed to update a Goal.
     */
    data: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>;
    /**
     * Choose, which Goal to update.
     */
    where: GoalWhereUniqueInput;
  };

  /**
   * Goal updateMany
   */
  export type GoalUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>;
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput;
    /**
     * Limit how many Goals to update.
     */
    limit?: number;
  };

  /**
   * Goal updateManyAndReturn
   */
  export type GoalUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * The data used to update Goals.
     */
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyInput>;
    /**
     * Filter which Goals to update
     */
    where?: GoalWhereInput;
    /**
     * Limit how many Goals to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Goal upsert
   */
  export type GoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    /**
     * The filter to search for the Goal to update in case it exists.
     */
    where: GoalWhereUniqueInput;
    /**
     * In case the Goal found by the `where` argument doesn't exist, create a new Goal with this data.
     */
    create: XOR<GoalCreateInput, GoalUncheckedCreateInput>;
    /**
     * In case the Goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalUpdateInput, GoalUncheckedUpdateInput>;
  };

  /**
   * Goal delete
   */
  export type GoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goal
     */
    select?: GoalSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Goal
     */
    omit?: GoalOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalInclude<ExtArgs> | null;
    /**
     * Filter which Goal to delete.
     */
    where: GoalWhereUniqueInput;
  };

  /**
   * Goal deleteMany
   */
  export type GoalDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Goals to delete
     */
    where?: GoalWhereInput;
    /**
     * Limit how many Goals to delete.
     */
    limit?: number;
  };

  /**
   * Goal.clinic
   */
  export type Goal$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Clinic
       */
      select?: ClinicSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Clinic
       */
      omit?: ClinicOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ClinicInclude<ExtArgs> | null;
      where?: ClinicWhereInput;
    };

  /**
   * Goal.provider
   */
  export type Goal$providerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null;
    where?: ProviderWhereInput;
  };

  /**
   * Goal without action
   */
  export type GoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Goal
       */
      select?: GoalSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Goal
       */
      omit?: GoalOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: GoalInclude<ExtArgs> | null;
    };

  /**
   * Model Dashboard
   */

  export type AggregateDashboard = {
    _count: DashboardCountAggregateOutputType | null;
    _min: DashboardMinAggregateOutputType | null;
    _max: DashboardMaxAggregateOutputType | null;
  };

  export type DashboardMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    isDefault: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    userId: string | null;
  };

  export type DashboardMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    isDefault: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    userId: string | null;
  };

  export type DashboardCountAggregateOutputType = {
    id: number;
    name: number;
    isDefault: number;
    layoutConfig: number;
    createdAt: number;
    updatedAt: number;
    userId: number;
    _all: number;
  };

  export type DashboardMinAggregateInputType = {
    id?: true;
    name?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
    userId?: true;
  };

  export type DashboardMaxAggregateInputType = {
    id?: true;
    name?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
    userId?: true;
  };

  export type DashboardCountAggregateInputType = {
    id?: true;
    name?: true;
    isDefault?: true;
    layoutConfig?: true;
    createdAt?: true;
    updatedAt?: true;
    userId?: true;
    _all?: true;
  };

  export type DashboardAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Dashboard to aggregate.
     */
    where?: DashboardWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DashboardWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Dashboards from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Dashboards.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Dashboards
     **/
    _count?: true | DashboardCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DashboardMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DashboardMaxAggregateInputType;
  };

  export type GetDashboardAggregateType<T extends DashboardAggregateArgs> = {
    [P in keyof T & keyof AggregateDashboard]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboard[P]>
      : GetScalarType<T[P], AggregateDashboard[P]>;
  };

  export type DashboardGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DashboardWhereInput;
    orderBy?: DashboardOrderByWithAggregationInput | DashboardOrderByWithAggregationInput[];
    by: DashboardScalarFieldEnum[] | DashboardScalarFieldEnum;
    having?: DashboardScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DashboardCountAggregateInputType | true;
    _min?: DashboardMinAggregateInputType;
    _max?: DashboardMaxAggregateInputType;
  };

  export type DashboardGroupByOutputType = {
    id: string;
    name: string;
    isDefault: boolean;
    layoutConfig: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    userId: string;
    _count: DashboardCountAggregateOutputType | null;
    _min: DashboardMinAggregateOutputType | null;
    _max: DashboardMaxAggregateOutputType | null;
  };

  type GetDashboardGroupByPayload<T extends DashboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof DashboardGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], DashboardGroupByOutputType[P]>
          : GetScalarType<T[P], DashboardGroupByOutputType[P]>;
      }
    >
  >;

  export type DashboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        isDefault?: boolean;
        layoutConfig?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        userId?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
        widgets?: boolean | Dashboard$widgetsArgs<ExtArgs>;
        _count?: boolean | DashboardCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["dashboard"]
    >;

  export type DashboardSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      isDefault?: boolean;
      layoutConfig?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["dashboard"]
  >;

  export type DashboardSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      isDefault?: boolean;
      layoutConfig?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["dashboard"]
  >;

  export type DashboardSelectScalar = {
    id?: boolean;
    name?: boolean;
    isDefault?: boolean;
    layoutConfig?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    userId?: boolean;
  };

  export type DashboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      "id" | "name" | "isDefault" | "layoutConfig" | "createdAt" | "updatedAt" | "userId",
      ExtArgs["result"]["dashboard"]
    >;
  export type DashboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      user?: boolean | UserDefaultArgs<ExtArgs>;
      widgets?: boolean | Dashboard$widgetsArgs<ExtArgs>;
      _count?: boolean | DashboardCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type DashboardIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type DashboardIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $DashboardPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "Dashboard";
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      widgets: Prisma.$WidgetPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        isDefault: boolean;
        layoutConfig: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
        userId: string;
      },
      ExtArgs["result"]["dashboard"]
    >;
    composites: {};
  };

  type DashboardGetPayload<S extends boolean | null | undefined | DashboardDefaultArgs> =
    $Result.GetResult<Prisma.$DashboardPayload, S>;

  type DashboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
      select?: DashboardCountAggregateInputType | true;
    };

  export interface DashboardDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["Dashboard"];
      meta: { name: "Dashboard" };
    };
    /**
     * Find zero or one Dashboard that matches the filter.
     * @param {DashboardFindUniqueArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardFindUniqueArgs>(
      args: SelectSubset<T, DashboardFindUniqueArgs<ExtArgs>>
    ): Prisma__DashboardClient<
      $Result.GetResult<
        Prisma.$DashboardPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Dashboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardFindUniqueOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DashboardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DashboardClient<
      $Result.GetResult<
        Prisma.$DashboardPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Dashboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardFindFirstArgs>(
      args?: SelectSubset<T, DashboardFindFirstArgs<ExtArgs>>
    ): Prisma__DashboardClient<
      $Result.GetResult<
        Prisma.$DashboardPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Dashboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindFirstOrThrowArgs} args - Arguments to find a Dashboard
     * @example
     * // Get one Dashboard
     * const dashboard = await prisma.dashboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DashboardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DashboardClient<
      $Result.GetResult<
        Prisma.$DashboardPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Dashboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dashboards
     * const dashboards = await prisma.dashboard.findMany()
     *
     * // Get first 10 Dashboards
     * const dashboards = await prisma.dashboard.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DashboardFindManyArgs>(
      args?: SelectSubset<T, DashboardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Dashboard.
     * @param {DashboardCreateArgs} args - Arguments to create a Dashboard.
     * @example
     * // Create one Dashboard
     * const Dashboard = await prisma.dashboard.create({
     *   data: {
     *     // ... data to create a Dashboard
     *   }
     * })
     *
     */
    create<T extends DashboardCreateArgs>(
      args: SelectSubset<T, DashboardCreateArgs<ExtArgs>>
    ): Prisma__DashboardClient<
      $Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Dashboards.
     * @param {DashboardCreateManyArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DashboardCreateManyArgs>(
      args?: SelectSubset<T, DashboardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Dashboards and returns the data saved in the database.
     * @param {DashboardCreateManyAndReturnArgs} args - Arguments to create many Dashboards.
     * @example
     * // Create many Dashboards
     * const dashboard = await prisma.dashboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DashboardCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DashboardCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DashboardPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Dashboard.
     * @param {DashboardDeleteArgs} args - Arguments to delete one Dashboard.
     * @example
     * // Delete one Dashboard
     * const Dashboard = await prisma.dashboard.delete({
     *   where: {
     *     // ... filter to delete one Dashboard
     *   }
     * })
     *
     */
    delete<T extends DashboardDeleteArgs>(
      args: SelectSubset<T, DashboardDeleteArgs<ExtArgs>>
    ): Prisma__DashboardClient<
      $Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Dashboard.
     * @param {DashboardUpdateArgs} args - Arguments to update one Dashboard.
     * @example
     * // Update one Dashboard
     * const dashboard = await prisma.dashboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DashboardUpdateArgs>(
      args: SelectSubset<T, DashboardUpdateArgs<ExtArgs>>
    ): Prisma__DashboardClient<
      $Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Dashboards.
     * @param {DashboardDeleteManyArgs} args - Arguments to filter Dashboards to delete.
     * @example
     * // Delete a few Dashboards
     * const { count } = await prisma.dashboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DashboardDeleteManyArgs>(
      args?: SelectSubset<T, DashboardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DashboardUpdateManyArgs>(
      args: SelectSubset<T, DashboardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Dashboards and returns the data updated in the database.
     * @param {DashboardUpdateManyAndReturnArgs} args - Arguments to update many Dashboards.
     * @example
     * // Update many Dashboards
     * const dashboard = await prisma.dashboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Dashboards and only return the `id`
     * const dashboardWithIdOnly = await prisma.dashboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DashboardUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DashboardUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DashboardPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Dashboard.
     * @param {DashboardUpsertArgs} args - Arguments to update or create a Dashboard.
     * @example
     * // Update or create a Dashboard
     * const dashboard = await prisma.dashboard.upsert({
     *   create: {
     *     // ... data to create a Dashboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dashboard we want to update
     *   }
     * })
     */
    upsert<T extends DashboardUpsertArgs>(
      args: SelectSubset<T, DashboardUpsertArgs<ExtArgs>>
    ): Prisma__DashboardClient<
      $Result.GetResult<Prisma.$DashboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Dashboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardCountArgs} args - Arguments to filter Dashboards to count.
     * @example
     * // Count the number of Dashboards
     * const count = await prisma.dashboard.count({
     *   where: {
     *     // ... the filter for the Dashboards we want to count
     *   }
     * })
     **/
    count<T extends DashboardCountArgs>(
      args?: Subset<T, DashboardCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], DashboardCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DashboardAggregateArgs>(
      args: Subset<T, DashboardAggregateArgs>
    ): Prisma.PrismaPromise<GetDashboardAggregateType<T>>;

    /**
     * Group by Dashboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DashboardGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardGroupByArgs["orderBy"] }
        : { orderBy?: DashboardGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DashboardGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetDashboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Dashboard model
     */
    readonly fields: DashboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dashboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    widgets<T extends Dashboard$widgetsArgs<ExtArgs> = {}>(
      args?: Subset<T, Dashboard$widgetsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Dashboard model
   */
  interface DashboardFieldRefs {
    readonly id: FieldRef<"Dashboard", "String">;
    readonly name: FieldRef<"Dashboard", "String">;
    readonly isDefault: FieldRef<"Dashboard", "Boolean">;
    readonly layoutConfig: FieldRef<"Dashboard", "Json">;
    readonly createdAt: FieldRef<"Dashboard", "DateTime">;
    readonly updatedAt: FieldRef<"Dashboard", "DateTime">;
    readonly userId: FieldRef<"Dashboard", "String">;
  }

  // Custom InputTypes
  /**
   * Dashboard findUnique
   */
  export type DashboardFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput;
  };

  /**
   * Dashboard findUniqueOrThrow
   */
  export type DashboardFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    /**
     * Filter, which Dashboard to fetch.
     */
    where: DashboardWhereUniqueInput;
  };

  /**
   * Dashboard findFirst
   */
  export type DashboardFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Dashboards from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Dashboards.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[];
  };

  /**
   * Dashboard findFirstOrThrow
   */
  export type DashboardFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    /**
     * Filter, which Dashboard to fetch.
     */
    where?: DashboardWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Dashboards.
     */
    cursor?: DashboardWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Dashboards from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Dashboards.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Dashboards.
     */
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[];
  };

  /**
   * Dashboard findMany
   */
  export type DashboardFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    /**
     * Filter, which Dashboards to fetch.
     */
    where?: DashboardWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Dashboards to fetch.
     */
    orderBy?: DashboardOrderByWithRelationInput | DashboardOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Dashboards.
     */
    cursor?: DashboardWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Dashboards from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Dashboards.
     */
    skip?: number;
    distinct?: DashboardScalarFieldEnum | DashboardScalarFieldEnum[];
  };

  /**
   * Dashboard create
   */
  export type DashboardCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    /**
     * The data needed to create a Dashboard.
     */
    data: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>;
  };

  /**
   * Dashboard createMany
   */
  export type DashboardCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Dashboard createManyAndReturn
   */
  export type DashboardCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * The data used to create many Dashboards.
     */
    data: DashboardCreateManyInput | DashboardCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Dashboard update
   */
  export type DashboardUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    /**
     * The data needed to update a Dashboard.
     */
    data: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>;
    /**
     * Choose, which Dashboard to update.
     */
    where: DashboardWhereUniqueInput;
  };

  /**
   * Dashboard updateMany
   */
  export type DashboardUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>;
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput;
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number;
  };

  /**
   * Dashboard updateManyAndReturn
   */
  export type DashboardUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * The data used to update Dashboards.
     */
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyInput>;
    /**
     * Filter which Dashboards to update
     */
    where?: DashboardWhereInput;
    /**
     * Limit how many Dashboards to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Dashboard upsert
   */
  export type DashboardUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    /**
     * The filter to search for the Dashboard to update in case it exists.
     */
    where: DashboardWhereUniqueInput;
    /**
     * In case the Dashboard found by the `where` argument doesn't exist, create a new Dashboard with this data.
     */
    create: XOR<DashboardCreateInput, DashboardUncheckedCreateInput>;
    /**
     * In case the Dashboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardUpdateInput, DashboardUncheckedUpdateInput>;
  };

  /**
   * Dashboard delete
   */
  export type DashboardDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
    /**
     * Filter which Dashboard to delete.
     */
    where: DashboardWhereUniqueInput;
  };

  /**
   * Dashboard deleteMany
   */
  export type DashboardDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Dashboards to delete
     */
    where?: DashboardWhereInput;
    /**
     * Limit how many Dashboards to delete.
     */
    limit?: number;
  };

  /**
   * Dashboard.widgets
   */
  export type Dashboard$widgetsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null;
    where?: WidgetWhereInput;
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[];
    cursor?: WidgetWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[];
  };

  /**
   * Dashboard without action
   */
  export type DashboardDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dashboard
     */
    select?: DashboardSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Dashboard
     */
    omit?: DashboardOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DashboardInclude<ExtArgs> | null;
  };

  /**
   * Model Widget
   */

  export type AggregateWidget = {
    _count: WidgetCountAggregateOutputType | null;
    _avg: WidgetAvgAggregateOutputType | null;
    _sum: WidgetSumAggregateOutputType | null;
    _min: WidgetMinAggregateOutputType | null;
    _max: WidgetMaxAggregateOutputType | null;
  };

  export type WidgetAvgAggregateOutputType = {
    positionX: number | null;
    positionY: number | null;
    width: number | null;
    height: number | null;
  };

  export type WidgetSumAggregateOutputType = {
    positionX: number | null;
    positionY: number | null;
    width: number | null;
    height: number | null;
  };

  export type WidgetMinAggregateOutputType = {
    id: string | null;
    widgetType: string | null;
    chartType: string | null;
    positionX: number | null;
    positionY: number | null;
    width: number | null;
    height: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    dashboardId: string | null;
    metricDefinitionId: string | null;
  };

  export type WidgetMaxAggregateOutputType = {
    id: string | null;
    widgetType: string | null;
    chartType: string | null;
    positionX: number | null;
    positionY: number | null;
    width: number | null;
    height: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    dashboardId: string | null;
    metricDefinitionId: string | null;
  };

  export type WidgetCountAggregateOutputType = {
    id: number;
    widgetType: number;
    chartType: number;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config: number;
    createdAt: number;
    updatedAt: number;
    dashboardId: number;
    metricDefinitionId: number;
    _all: number;
  };

  export type WidgetAvgAggregateInputType = {
    positionX?: true;
    positionY?: true;
    width?: true;
    height?: true;
  };

  export type WidgetSumAggregateInputType = {
    positionX?: true;
    positionY?: true;
    width?: true;
    height?: true;
  };

  export type WidgetMinAggregateInputType = {
    id?: true;
    widgetType?: true;
    chartType?: true;
    positionX?: true;
    positionY?: true;
    width?: true;
    height?: true;
    createdAt?: true;
    updatedAt?: true;
    dashboardId?: true;
    metricDefinitionId?: true;
  };

  export type WidgetMaxAggregateInputType = {
    id?: true;
    widgetType?: true;
    chartType?: true;
    positionX?: true;
    positionY?: true;
    width?: true;
    height?: true;
    createdAt?: true;
    updatedAt?: true;
    dashboardId?: true;
    metricDefinitionId?: true;
  };

  export type WidgetCountAggregateInputType = {
    id?: true;
    widgetType?: true;
    chartType?: true;
    positionX?: true;
    positionY?: true;
    width?: true;
    height?: true;
    config?: true;
    createdAt?: true;
    updatedAt?: true;
    dashboardId?: true;
    metricDefinitionId?: true;
    _all?: true;
  };

  export type WidgetAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Widget to aggregate.
     */
    where?: WidgetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WidgetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Widgets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Widgets.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Widgets
     **/
    _count?: true | WidgetCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: WidgetAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: WidgetSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WidgetMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WidgetMaxAggregateInputType;
  };

  export type GetWidgetAggregateType<T extends WidgetAggregateArgs> = {
    [P in keyof T & keyof AggregateWidget]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWidget[P]>
      : GetScalarType<T[P], AggregateWidget[P]>;
  };

  export type WidgetGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WidgetWhereInput;
    orderBy?: WidgetOrderByWithAggregationInput | WidgetOrderByWithAggregationInput[];
    by: WidgetScalarFieldEnum[] | WidgetScalarFieldEnum;
    having?: WidgetScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WidgetCountAggregateInputType | true;
    _avg?: WidgetAvgAggregateInputType;
    _sum?: WidgetSumAggregateInputType;
    _min?: WidgetMinAggregateInputType;
    _max?: WidgetMaxAggregateInputType;
  };

  export type WidgetGroupByOutputType = {
    id: string;
    widgetType: string;
    chartType: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    dashboardId: string;
    metricDefinitionId: string | null;
    _count: WidgetCountAggregateOutputType | null;
    _avg: WidgetAvgAggregateOutputType | null;
    _sum: WidgetSumAggregateOutputType | null;
    _min: WidgetMinAggregateOutputType | null;
    _max: WidgetMaxAggregateOutputType | null;
  };

  type GetWidgetGroupByPayload<T extends WidgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WidgetGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof WidgetGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], WidgetGroupByOutputType[P]>
          : GetScalarType<T[P], WidgetGroupByOutputType[P]>;
      }
    >
  >;

  export type WidgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        widgetType?: boolean;
        chartType?: boolean;
        positionX?: boolean;
        positionY?: boolean;
        width?: boolean;
        height?: boolean;
        config?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        dashboardId?: boolean;
        metricDefinitionId?: boolean;
        dashboard?: boolean | DashboardDefaultArgs<ExtArgs>;
        metricDefinition?: boolean | Widget$metricDefinitionArgs<ExtArgs>;
      },
      ExtArgs["result"]["widget"]
    >;

  export type WidgetSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      widgetType?: boolean;
      chartType?: boolean;
      positionX?: boolean;
      positionY?: boolean;
      width?: boolean;
      height?: boolean;
      config?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      dashboardId?: boolean;
      metricDefinitionId?: boolean;
      dashboard?: boolean | DashboardDefaultArgs<ExtArgs>;
      metricDefinition?: boolean | Widget$metricDefinitionArgs<ExtArgs>;
    },
    ExtArgs["result"]["widget"]
  >;

  export type WidgetSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      widgetType?: boolean;
      chartType?: boolean;
      positionX?: boolean;
      positionY?: boolean;
      width?: boolean;
      height?: boolean;
      config?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      dashboardId?: boolean;
      metricDefinitionId?: boolean;
      dashboard?: boolean | DashboardDefaultArgs<ExtArgs>;
      metricDefinition?: boolean | Widget$metricDefinitionArgs<ExtArgs>;
    },
    ExtArgs["result"]["widget"]
  >;

  export type WidgetSelectScalar = {
    id?: boolean;
    widgetType?: boolean;
    chartType?: boolean;
    positionX?: boolean;
    positionY?: boolean;
    width?: boolean;
    height?: boolean;
    config?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    dashboardId?: boolean;
    metricDefinitionId?: boolean;
  };

  export type WidgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "widgetType"
      | "chartType"
      | "positionX"
      | "positionY"
      | "width"
      | "height"
      | "config"
      | "createdAt"
      | "updatedAt"
      | "dashboardId"
      | "metricDefinitionId",
      ExtArgs["result"]["widget"]
    >;
  export type WidgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>;
    metricDefinition?: boolean | Widget$metricDefinitionArgs<ExtArgs>;
  };
  export type WidgetIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>;
    metricDefinition?: boolean | Widget$metricDefinitionArgs<ExtArgs>;
  };
  export type WidgetIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    dashboard?: boolean | DashboardDefaultArgs<ExtArgs>;
    metricDefinition?: boolean | Widget$metricDefinitionArgs<ExtArgs>;
  };

  export type $WidgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Widget";
    objects: {
      dashboard: Prisma.$DashboardPayload<ExtArgs>;
      metricDefinition: Prisma.$MetricDefinitionPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        widgetType: string;
        chartType: string | null;
        positionX: number;
        positionY: number;
        width: number;
        height: number;
        config: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
        dashboardId: string;
        metricDefinitionId: string | null;
      },
      ExtArgs["result"]["widget"]
    >;
    composites: {};
  };

  type WidgetGetPayload<S extends boolean | null | undefined | WidgetDefaultArgs> =
    $Result.GetResult<Prisma.$WidgetPayload, S>;

  type WidgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    WidgetFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: WidgetCountAggregateInputType | true;
  };

  export interface WidgetDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Widget"]; meta: { name: "Widget" } };
    /**
     * Find zero or one Widget that matches the filter.
     * @param {WidgetFindUniqueArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WidgetFindUniqueArgs>(
      args: SelectSubset<T, WidgetFindUniqueArgs<ExtArgs>>
    ): Prisma__WidgetClient<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Widget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WidgetFindUniqueOrThrowArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WidgetFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WidgetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WidgetClient<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Widget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetFindFirstArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WidgetFindFirstArgs>(
      args?: SelectSubset<T, WidgetFindFirstArgs<ExtArgs>>
    ): Prisma__WidgetClient<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Widget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetFindFirstOrThrowArgs} args - Arguments to find a Widget
     * @example
     * // Get one Widget
     * const widget = await prisma.widget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WidgetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WidgetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WidgetClient<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Widgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Widgets
     * const widgets = await prisma.widget.findMany()
     *
     * // Get first 10 Widgets
     * const widgets = await prisma.widget.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const widgetWithIdOnly = await prisma.widget.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WidgetFindManyArgs>(
      args?: SelectSubset<T, WidgetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Widget.
     * @param {WidgetCreateArgs} args - Arguments to create a Widget.
     * @example
     * // Create one Widget
     * const Widget = await prisma.widget.create({
     *   data: {
     *     // ... data to create a Widget
     *   }
     * })
     *
     */
    create<T extends WidgetCreateArgs>(
      args: SelectSubset<T, WidgetCreateArgs<ExtArgs>>
    ): Prisma__WidgetClient<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Widgets.
     * @param {WidgetCreateManyArgs} args - Arguments to create many Widgets.
     * @example
     * // Create many Widgets
     * const widget = await prisma.widget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WidgetCreateManyArgs>(
      args?: SelectSubset<T, WidgetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Widgets and returns the data saved in the database.
     * @param {WidgetCreateManyAndReturnArgs} args - Arguments to create many Widgets.
     * @example
     * // Create many Widgets
     * const widget = await prisma.widget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Widgets and only return the `id`
     * const widgetWithIdOnly = await prisma.widget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WidgetCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WidgetCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Widget.
     * @param {WidgetDeleteArgs} args - Arguments to delete one Widget.
     * @example
     * // Delete one Widget
     * const Widget = await prisma.widget.delete({
     *   where: {
     *     // ... filter to delete one Widget
     *   }
     * })
     *
     */
    delete<T extends WidgetDeleteArgs>(
      args: SelectSubset<T, WidgetDeleteArgs<ExtArgs>>
    ): Prisma__WidgetClient<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Widget.
     * @param {WidgetUpdateArgs} args - Arguments to update one Widget.
     * @example
     * // Update one Widget
     * const widget = await prisma.widget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WidgetUpdateArgs>(
      args: SelectSubset<T, WidgetUpdateArgs<ExtArgs>>
    ): Prisma__WidgetClient<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Widgets.
     * @param {WidgetDeleteManyArgs} args - Arguments to filter Widgets to delete.
     * @example
     * // Delete a few Widgets
     * const { count } = await prisma.widget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WidgetDeleteManyArgs>(
      args?: SelectSubset<T, WidgetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Widgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Widgets
     * const widget = await prisma.widget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WidgetUpdateManyArgs>(
      args: SelectSubset<T, WidgetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Widgets and returns the data updated in the database.
     * @param {WidgetUpdateManyAndReturnArgs} args - Arguments to update many Widgets.
     * @example
     * // Update many Widgets
     * const widget = await prisma.widget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Widgets and only return the `id`
     * const widgetWithIdOnly = await prisma.widget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WidgetUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WidgetUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Widget.
     * @param {WidgetUpsertArgs} args - Arguments to update or create a Widget.
     * @example
     * // Update or create a Widget
     * const widget = await prisma.widget.upsert({
     *   create: {
     *     // ... data to create a Widget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Widget we want to update
     *   }
     * })
     */
    upsert<T extends WidgetUpsertArgs>(
      args: SelectSubset<T, WidgetUpsertArgs<ExtArgs>>
    ): Prisma__WidgetClient<
      $Result.GetResult<Prisma.$WidgetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Widgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetCountArgs} args - Arguments to filter Widgets to count.
     * @example
     * // Count the number of Widgets
     * const count = await prisma.widget.count({
     *   where: {
     *     // ... the filter for the Widgets we want to count
     *   }
     * })
     **/
    count<T extends WidgetCountArgs>(
      args?: Subset<T, WidgetCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], WidgetCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Widget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WidgetAggregateArgs>(
      args: Subset<T, WidgetAggregateArgs>
    ): Prisma.PrismaPromise<GetWidgetAggregateType<T>>;

    /**
     * Group by Widget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WidgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WidgetGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WidgetGroupByArgs["orderBy"] }
        : { orderBy?: WidgetGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WidgetGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetWidgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Widget model
     */
    readonly fields: WidgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Widget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WidgetClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    dashboard<T extends DashboardDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, DashboardDefaultArgs<ExtArgs>>
    ): Prisma__DashboardClient<
      | $Result.GetResult<
          Prisma.$DashboardPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    metricDefinition<T extends Widget$metricDefinitionArgs<ExtArgs> = {}>(
      args?: Subset<T, Widget$metricDefinitionArgs<ExtArgs>>
    ): Prisma__MetricDefinitionClient<
      $Result.GetResult<
        Prisma.$MetricDefinitionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Widget model
   */
  interface WidgetFieldRefs {
    readonly id: FieldRef<"Widget", "String">;
    readonly widgetType: FieldRef<"Widget", "String">;
    readonly chartType: FieldRef<"Widget", "String">;
    readonly positionX: FieldRef<"Widget", "Int">;
    readonly positionY: FieldRef<"Widget", "Int">;
    readonly width: FieldRef<"Widget", "Int">;
    readonly height: FieldRef<"Widget", "Int">;
    readonly config: FieldRef<"Widget", "Json">;
    readonly createdAt: FieldRef<"Widget", "DateTime">;
    readonly updatedAt: FieldRef<"Widget", "DateTime">;
    readonly dashboardId: FieldRef<"Widget", "String">;
    readonly metricDefinitionId: FieldRef<"Widget", "String">;
  }

  // Custom InputTypes
  /**
   * Widget findUnique
   */
  export type WidgetFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null;
    /**
     * Filter, which Widget to fetch.
     */
    where: WidgetWhereUniqueInput;
  };

  /**
   * Widget findUniqueOrThrow
   */
  export type WidgetFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null;
    /**
     * Filter, which Widget to fetch.
     */
    where: WidgetWhereUniqueInput;
  };

  /**
   * Widget findFirst
   */
  export type WidgetFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null;
    /**
     * Filter, which Widget to fetch.
     */
    where?: WidgetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Widgets.
     */
    cursor?: WidgetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Widgets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Widgets.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Widgets.
     */
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[];
  };

  /**
   * Widget findFirstOrThrow
   */
  export type WidgetFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null;
    /**
     * Filter, which Widget to fetch.
     */
    where?: WidgetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Widgets.
     */
    cursor?: WidgetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Widgets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Widgets.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Widgets.
     */
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[];
  };

  /**
   * Widget findMany
   */
  export type WidgetFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null;
    /**
     * Filter, which Widgets to fetch.
     */
    where?: WidgetWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Widgets to fetch.
     */
    orderBy?: WidgetOrderByWithRelationInput | WidgetOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Widgets.
     */
    cursor?: WidgetWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `¬±n` Widgets from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Widgets.
     */
    skip?: number;
    distinct?: WidgetScalarFieldEnum | WidgetScalarFieldEnum[];
  };

  /**
   * Widget create
   */
  export type WidgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Widget
       */
      select?: WidgetSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Widget
       */
      omit?: WidgetOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: WidgetInclude<ExtArgs> | null;
      /**
       * The data needed to create a Widget.
       */
      data: XOR<WidgetCreateInput, WidgetUncheckedCreateInput>;
    };

  /**
   * Widget createMany
   */
  export type WidgetCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Widgets.
     */
    data: WidgetCreateManyInput | WidgetCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Widget createManyAndReturn
   */
  export type WidgetCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * The data used to create many Widgets.
     */
    data: WidgetCreateManyInput | WidgetCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Widget update
   */
  export type WidgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Widget
       */
      select?: WidgetSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Widget
       */
      omit?: WidgetOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: WidgetInclude<ExtArgs> | null;
      /**
       * The data needed to update a Widget.
       */
      data: XOR<WidgetUpdateInput, WidgetUncheckedUpdateInput>;
      /**
       * Choose, which Widget to update.
       */
      where: WidgetWhereUniqueInput;
    };

  /**
   * Widget updateMany
   */
  export type WidgetUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Widgets.
     */
    data: XOR<WidgetUpdateManyMutationInput, WidgetUncheckedUpdateManyInput>;
    /**
     * Filter which Widgets to update
     */
    where?: WidgetWhereInput;
    /**
     * Limit how many Widgets to update.
     */
    limit?: number;
  };

  /**
   * Widget updateManyAndReturn
   */
  export type WidgetUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * The data used to update Widgets.
     */
    data: XOR<WidgetUpdateManyMutationInput, WidgetUncheckedUpdateManyInput>;
    /**
     * Filter which Widgets to update
     */
    where?: WidgetWhereInput;
    /**
     * Limit how many Widgets to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Widget upsert
   */
  export type WidgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Widget
       */
      select?: WidgetSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Widget
       */
      omit?: WidgetOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: WidgetInclude<ExtArgs> | null;
      /**
       * The filter to search for the Widget to update in case it exists.
       */
      where: WidgetWhereUniqueInput;
      /**
       * In case the Widget found by the `where` argument doesn't exist, create a new Widget with this data.
       */
      create: XOR<WidgetCreateInput, WidgetUncheckedCreateInput>;
      /**
       * In case the Widget was found with the provided `where` argument, update it with this data.
       */
      update: XOR<WidgetUpdateInput, WidgetUncheckedUpdateInput>;
    };

  /**
   * Widget delete
   */
  export type WidgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Widget
       */
      select?: WidgetSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Widget
       */
      omit?: WidgetOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: WidgetInclude<ExtArgs> | null;
      /**
       * Filter which Widget to delete.
       */
      where: WidgetWhereUniqueInput;
    };

  /**
   * Widget deleteMany
   */
  export type WidgetDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Widgets to delete
     */
    where?: WidgetWhereInput;
    /**
     * Limit how many Widgets to delete.
     */
    limit?: number;
  };

  /**
   * Widget.metricDefinition
   */
  export type Widget$metricDefinitionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MetricDefinition
     */
    select?: MetricDefinitionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the MetricDefinition
     */
    omit?: MetricDefinitionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricDefinitionInclude<ExtArgs> | null;
    where?: MetricDefinitionWhereInput;
  };

  /**
   * Widget without action
   */
  export type WidgetDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Widget
     */
    select?: WidgetSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Widget
     */
    omit?: WidgetOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WidgetInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const ClinicScalarFieldEnum: {
    id: "id";
    name: "name";
    location: "location";
    status: "status";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type ClinicScalarFieldEnum =
    (typeof ClinicScalarFieldEnum)[keyof typeof ClinicScalarFieldEnum];

  export const UserScalarFieldEnum: {
    id: "id";
    email: "email";
    name: "name";
    role: "role";
    lastLogin: "lastLogin";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    clinicId: "clinicId";
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const ProviderScalarFieldEnum: {
    id: "id";
    name: "name";
    providerType: "providerType";
    status: "status";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    clinicId: "clinicId";
  };

  export type ProviderScalarFieldEnum =
    (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum];

  export const MetricDefinitionScalarFieldEnum: {
    id: "id";
    name: "name";
    description: "description";
    dataType: "dataType";
    calculationFormula: "calculationFormula";
    category: "category";
    isComposite: "isComposite";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type MetricDefinitionScalarFieldEnum =
    (typeof MetricDefinitionScalarFieldEnum)[keyof typeof MetricDefinitionScalarFieldEnum];

  export const DataSourceScalarFieldEnum: {
    id: "id";
    name: "name";
    spreadsheetId: "spreadsheetId";
    sheetName: "sheetName";
    lastSyncedAt: "lastSyncedAt";
    syncFrequency: "syncFrequency";
    connectionStatus: "connectionStatus";
    appScriptId: "appScriptId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
  };

  export type DataSourceScalarFieldEnum =
    (typeof DataSourceScalarFieldEnum)[keyof typeof DataSourceScalarFieldEnum];

  export const ColumnMappingScalarFieldEnum: {
    id: "id";
    columnName: "columnName";
    transformationRule: "transformationRule";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    dataSourceId: "dataSourceId";
    metricDefinitionId: "metricDefinitionId";
  };

  export type ColumnMappingScalarFieldEnum =
    (typeof ColumnMappingScalarFieldEnum)[keyof typeof ColumnMappingScalarFieldEnum];

  export const MetricValueScalarFieldEnum: {
    id: "id";
    date: "date";
    value: "value";
    sourceType: "sourceType";
    sourceSheet: "sourceSheet";
    externalId: "externalId";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    metricDefinitionId: "metricDefinitionId";
    clinicId: "clinicId";
    providerId: "providerId";
    dataSourceId: "dataSourceId";
  };

  export type MetricValueScalarFieldEnum =
    (typeof MetricValueScalarFieldEnum)[keyof typeof MetricValueScalarFieldEnum];

  export const GoalScalarFieldEnum: {
    id: "id";
    timePeriod: "timePeriod";
    startDate: "startDate";
    endDate: "endDate";
    targetValue: "targetValue";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    metricDefinitionId: "metricDefinitionId";
    clinicId: "clinicId";
    providerId: "providerId";
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum];

  export const DashboardScalarFieldEnum: {
    id: "id";
    name: "name";
    isDefault: "isDefault";
    layoutConfig: "layoutConfig";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    userId: "userId";
  };

  export type DashboardScalarFieldEnum =
    (typeof DashboardScalarFieldEnum)[keyof typeof DashboardScalarFieldEnum];

  export const WidgetScalarFieldEnum: {
    id: "id";
    widgetType: "widgetType";
    chartType: "chartType";
    positionX: "positionX";
    positionY: "positionY";
    width: "width";
    height: "height";
    config: "config";
    createdAt: "createdAt";
    updatedAt: "updatedAt";
    dashboardId: "dashboardId";
    metricDefinitionId: "metricDefinitionId";
  };

  export type WidgetScalarFieldEnum =
    (typeof WidgetScalarFieldEnum)[keyof typeof WidgetScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String">;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String[]">;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DateTime">;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Boolean">;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Json">;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "QueryMode"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int">;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int[]">;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float">;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float[]">;

  /**
   * Deep Input Types
   */

  export type ClinicWhereInput = {
    AND?: ClinicWhereInput | ClinicWhereInput[];
    OR?: ClinicWhereInput[];
    NOT?: ClinicWhereInput | ClinicWhereInput[];
    id?: StringFilter<"Clinic"> | string;
    name?: StringFilter<"Clinic"> | string;
    location?: StringFilter<"Clinic"> | string;
    status?: StringFilter<"Clinic"> | string;
    createdAt?: DateTimeFilter<"Clinic"> | Date | string;
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string;
    users?: UserListRelationFilter;
    providers?: ProviderListRelationFilter;
    metrics?: MetricValueListRelationFilter;
    goals?: GoalListRelationFilter;
  };

  export type ClinicOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    location?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    users?: UserOrderByRelationAggregateInput;
    providers?: ProviderOrderByRelationAggregateInput;
    metrics?: MetricValueOrderByRelationAggregateInput;
    goals?: GoalOrderByRelationAggregateInput;
  };

  export type ClinicWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ClinicWhereInput | ClinicWhereInput[];
      OR?: ClinicWhereInput[];
      NOT?: ClinicWhereInput | ClinicWhereInput[];
      name?: StringFilter<"Clinic"> | string;
      location?: StringFilter<"Clinic"> | string;
      status?: StringFilter<"Clinic"> | string;
      createdAt?: DateTimeFilter<"Clinic"> | Date | string;
      updatedAt?: DateTimeFilter<"Clinic"> | Date | string;
      users?: UserListRelationFilter;
      providers?: ProviderListRelationFilter;
      metrics?: MetricValueListRelationFilter;
      goals?: GoalListRelationFilter;
    },
    "id"
  >;

  export type ClinicOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    location?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ClinicCountOrderByAggregateInput;
    _max?: ClinicMaxOrderByAggregateInput;
    _min?: ClinicMinOrderByAggregateInput;
  };

  export type ClinicScalarWhereWithAggregatesInput = {
    AND?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[];
    OR?: ClinicScalarWhereWithAggregatesInput[];
    NOT?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Clinic"> | string;
    name?: StringWithAggregatesFilter<"Clinic"> | string;
    location?: StringWithAggregatesFilter<"Clinic"> | string;
    status?: StringWithAggregatesFilter<"Clinic"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string;
  };

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<"User"> | string;
    email?: StringFilter<"User"> | string;
    name?: StringFilter<"User"> | string;
    role?: StringFilter<"User"> | string;
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    clinicId?: StringFilter<"User"> | string;
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>;
    dashboards?: DashboardListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    lastLogin?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
    clinic?: ClinicOrderByWithRelationInput;
    dashboards?: DashboardOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringFilter<"User"> | string;
      role?: StringFilter<"User"> | string;
      lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null;
      createdAt?: DateTimeFilter<"User"> | Date | string;
      updatedAt?: DateTimeFilter<"User"> | Date | string;
      clinicId?: StringFilter<"User"> | string;
      clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>;
      dashboards?: DashboardListRelationFilter;
    },
    "id" | "email"
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    lastLogin?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"User"> | string;
    email?: StringWithAggregatesFilter<"User"> | string;
    name?: StringWithAggregatesFilter<"User"> | string;
    role?: StringWithAggregatesFilter<"User"> | string;
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string;
    clinicId?: StringWithAggregatesFilter<"User"> | string;
  };

  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[];
    OR?: ProviderWhereInput[];
    NOT?: ProviderWhereInput | ProviderWhereInput[];
    id?: StringFilter<"Provider"> | string;
    name?: StringFilter<"Provider"> | string;
    providerType?: StringFilter<"Provider"> | string;
    status?: StringFilter<"Provider"> | string;
    createdAt?: DateTimeFilter<"Provider"> | Date | string;
    updatedAt?: DateTimeFilter<"Provider"> | Date | string;
    clinicId?: StringFilter<"Provider"> | string;
    clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>;
    metrics?: MetricValueListRelationFilter;
    goals?: GoalListRelationFilter;
  };

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    providerType?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
    clinic?: ClinicOrderByWithRelationInput;
    metrics?: MetricValueOrderByRelationAggregateInput;
    goals?: GoalOrderByRelationAggregateInput;
  };

  export type ProviderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ProviderWhereInput | ProviderWhereInput[];
      OR?: ProviderWhereInput[];
      NOT?: ProviderWhereInput | ProviderWhereInput[];
      name?: StringFilter<"Provider"> | string;
      providerType?: StringFilter<"Provider"> | string;
      status?: StringFilter<"Provider"> | string;
      createdAt?: DateTimeFilter<"Provider"> | Date | string;
      updatedAt?: DateTimeFilter<"Provider"> | Date | string;
      clinicId?: StringFilter<"Provider"> | string;
      clinic?: XOR<ClinicScalarRelationFilter, ClinicWhereInput>;
      metrics?: MetricValueListRelationFilter;
      goals?: GoalListRelationFilter;
    },
    "id"
  >;

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    providerType?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
    _count?: ProviderCountOrderByAggregateInput;
    _max?: ProviderMaxOrderByAggregateInput;
    _min?: ProviderMinOrderByAggregateInput;
  };

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[];
    OR?: ProviderScalarWhereWithAggregatesInput[];
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Provider"> | string;
    name?: StringWithAggregatesFilter<"Provider"> | string;
    providerType?: StringWithAggregatesFilter<"Provider"> | string;
    status?: StringWithAggregatesFilter<"Provider"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Provider"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Provider"> | Date | string;
    clinicId?: StringWithAggregatesFilter<"Provider"> | string;
  };

  export type MetricDefinitionWhereInput = {
    AND?: MetricDefinitionWhereInput | MetricDefinitionWhereInput[];
    OR?: MetricDefinitionWhereInput[];
    NOT?: MetricDefinitionWhereInput | MetricDefinitionWhereInput[];
    id?: StringFilter<"MetricDefinition"> | string;
    name?: StringFilter<"MetricDefinition"> | string;
    description?: StringFilter<"MetricDefinition"> | string;
    dataType?: StringFilter<"MetricDefinition"> | string;
    calculationFormula?: StringNullableFilter<"MetricDefinition"> | string | null;
    category?: StringFilter<"MetricDefinition"> | string;
    isComposite?: BoolFilter<"MetricDefinition"> | boolean;
    createdAt?: DateTimeFilter<"MetricDefinition"> | Date | string;
    updatedAt?: DateTimeFilter<"MetricDefinition"> | Date | string;
    metrics?: MetricValueListRelationFilter;
    columnMappings?: ColumnMappingListRelationFilter;
    goals?: GoalListRelationFilter;
    widgets?: WidgetListRelationFilter;
  };

  export type MetricDefinitionOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    dataType?: SortOrder;
    calculationFormula?: SortOrderInput | SortOrder;
    category?: SortOrder;
    isComposite?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metrics?: MetricValueOrderByRelationAggregateInput;
    columnMappings?: ColumnMappingOrderByRelationAggregateInput;
    goals?: GoalOrderByRelationAggregateInput;
    widgets?: WidgetOrderByRelationAggregateInput;
  };

  export type MetricDefinitionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MetricDefinitionWhereInput | MetricDefinitionWhereInput[];
      OR?: MetricDefinitionWhereInput[];
      NOT?: MetricDefinitionWhereInput | MetricDefinitionWhereInput[];
      name?: StringFilter<"MetricDefinition"> | string;
      description?: StringFilter<"MetricDefinition"> | string;
      dataType?: StringFilter<"MetricDefinition"> | string;
      calculationFormula?: StringNullableFilter<"MetricDefinition"> | string | null;
      category?: StringFilter<"MetricDefinition"> | string;
      isComposite?: BoolFilter<"MetricDefinition"> | boolean;
      createdAt?: DateTimeFilter<"MetricDefinition"> | Date | string;
      updatedAt?: DateTimeFilter<"MetricDefinition"> | Date | string;
      metrics?: MetricValueListRelationFilter;
      columnMappings?: ColumnMappingListRelationFilter;
      goals?: GoalListRelationFilter;
      widgets?: WidgetListRelationFilter;
    },
    "id"
  >;

  export type MetricDefinitionOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    dataType?: SortOrder;
    calculationFormula?: SortOrderInput | SortOrder;
    category?: SortOrder;
    isComposite?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: MetricDefinitionCountOrderByAggregateInput;
    _max?: MetricDefinitionMaxOrderByAggregateInput;
    _min?: MetricDefinitionMinOrderByAggregateInput;
  };

  export type MetricDefinitionScalarWhereWithAggregatesInput = {
    AND?:
      | MetricDefinitionScalarWhereWithAggregatesInput
      | MetricDefinitionScalarWhereWithAggregatesInput[];
    OR?: MetricDefinitionScalarWhereWithAggregatesInput[];
    NOT?:
      | MetricDefinitionScalarWhereWithAggregatesInput
      | MetricDefinitionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"MetricDefinition"> | string;
    name?: StringWithAggregatesFilter<"MetricDefinition"> | string;
    description?: StringWithAggregatesFilter<"MetricDefinition"> | string;
    dataType?: StringWithAggregatesFilter<"MetricDefinition"> | string;
    calculationFormula?: StringNullableWithAggregatesFilter<"MetricDefinition"> | string | null;
    category?: StringWithAggregatesFilter<"MetricDefinition"> | string;
    isComposite?: BoolWithAggregatesFilter<"MetricDefinition"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"MetricDefinition"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"MetricDefinition"> | Date | string;
  };

  export type DataSourceWhereInput = {
    AND?: DataSourceWhereInput | DataSourceWhereInput[];
    OR?: DataSourceWhereInput[];
    NOT?: DataSourceWhereInput | DataSourceWhereInput[];
    id?: StringFilter<"DataSource"> | string;
    name?: StringFilter<"DataSource"> | string;
    spreadsheetId?: StringFilter<"DataSource"> | string;
    sheetName?: StringFilter<"DataSource"> | string;
    lastSyncedAt?: DateTimeNullableFilter<"DataSource"> | Date | string | null;
    syncFrequency?: StringFilter<"DataSource"> | string;
    connectionStatus?: StringFilter<"DataSource"> | string;
    appScriptId?: StringNullableFilter<"DataSource"> | string | null;
    createdAt?: DateTimeFilter<"DataSource"> | Date | string;
    updatedAt?: DateTimeFilter<"DataSource"> | Date | string;
    columnMappings?: ColumnMappingListRelationFilter;
    metrics?: MetricValueListRelationFilter;
  };

  export type DataSourceOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    spreadsheetId?: SortOrder;
    sheetName?: SortOrder;
    lastSyncedAt?: SortOrderInput | SortOrder;
    syncFrequency?: SortOrder;
    connectionStatus?: SortOrder;
    appScriptId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    columnMappings?: ColumnMappingOrderByRelationAggregateInput;
    metrics?: MetricValueOrderByRelationAggregateInput;
  };

  export type DataSourceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DataSourceWhereInput | DataSourceWhereInput[];
      OR?: DataSourceWhereInput[];
      NOT?: DataSourceWhereInput | DataSourceWhereInput[];
      name?: StringFilter<"DataSource"> | string;
      spreadsheetId?: StringFilter<"DataSource"> | string;
      sheetName?: StringFilter<"DataSource"> | string;
      lastSyncedAt?: DateTimeNullableFilter<"DataSource"> | Date | string | null;
      syncFrequency?: StringFilter<"DataSource"> | string;
      connectionStatus?: StringFilter<"DataSource"> | string;
      appScriptId?: StringNullableFilter<"DataSource"> | string | null;
      createdAt?: DateTimeFilter<"DataSource"> | Date | string;
      updatedAt?: DateTimeFilter<"DataSource"> | Date | string;
      columnMappings?: ColumnMappingListRelationFilter;
      metrics?: MetricValueListRelationFilter;
    },
    "id"
  >;

  export type DataSourceOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    spreadsheetId?: SortOrder;
    sheetName?: SortOrder;
    lastSyncedAt?: SortOrderInput | SortOrder;
    syncFrequency?: SortOrder;
    connectionStatus?: SortOrder;
    appScriptId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: DataSourceCountOrderByAggregateInput;
    _max?: DataSourceMaxOrderByAggregateInput;
    _min?: DataSourceMinOrderByAggregateInput;
  };

  export type DataSourceScalarWhereWithAggregatesInput = {
    AND?: DataSourceScalarWhereWithAggregatesInput | DataSourceScalarWhereWithAggregatesInput[];
    OR?: DataSourceScalarWhereWithAggregatesInput[];
    NOT?: DataSourceScalarWhereWithAggregatesInput | DataSourceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"DataSource"> | string;
    name?: StringWithAggregatesFilter<"DataSource"> | string;
    spreadsheetId?: StringWithAggregatesFilter<"DataSource"> | string;
    sheetName?: StringWithAggregatesFilter<"DataSource"> | string;
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"DataSource"> | Date | string | null;
    syncFrequency?: StringWithAggregatesFilter<"DataSource"> | string;
    connectionStatus?: StringWithAggregatesFilter<"DataSource"> | string;
    appScriptId?: StringNullableWithAggregatesFilter<"DataSource"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"DataSource"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"DataSource"> | Date | string;
  };

  export type ColumnMappingWhereInput = {
    AND?: ColumnMappingWhereInput | ColumnMappingWhereInput[];
    OR?: ColumnMappingWhereInput[];
    NOT?: ColumnMappingWhereInput | ColumnMappingWhereInput[];
    id?: StringFilter<"ColumnMapping"> | string;
    columnName?: StringFilter<"ColumnMapping"> | string;
    transformationRule?: StringNullableFilter<"ColumnMapping"> | string | null;
    createdAt?: DateTimeFilter<"ColumnMapping"> | Date | string;
    updatedAt?: DateTimeFilter<"ColumnMapping"> | Date | string;
    dataSourceId?: StringFilter<"ColumnMapping"> | string;
    metricDefinitionId?: StringFilter<"ColumnMapping"> | string;
    dataSource?: XOR<DataSourceScalarRelationFilter, DataSourceWhereInput>;
    metricDefinition?: XOR<MetricDefinitionScalarRelationFilter, MetricDefinitionWhereInput>;
  };

  export type ColumnMappingOrderByWithRelationInput = {
    id?: SortOrder;
    columnName?: SortOrder;
    transformationRule?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dataSourceId?: SortOrder;
    metricDefinitionId?: SortOrder;
    dataSource?: DataSourceOrderByWithRelationInput;
    metricDefinition?: MetricDefinitionOrderByWithRelationInput;
  };

  export type ColumnMappingWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ColumnMappingWhereInput | ColumnMappingWhereInput[];
      OR?: ColumnMappingWhereInput[];
      NOT?: ColumnMappingWhereInput | ColumnMappingWhereInput[];
      columnName?: StringFilter<"ColumnMapping"> | string;
      transformationRule?: StringNullableFilter<"ColumnMapping"> | string | null;
      createdAt?: DateTimeFilter<"ColumnMapping"> | Date | string;
      updatedAt?: DateTimeFilter<"ColumnMapping"> | Date | string;
      dataSourceId?: StringFilter<"ColumnMapping"> | string;
      metricDefinitionId?: StringFilter<"ColumnMapping"> | string;
      dataSource?: XOR<DataSourceScalarRelationFilter, DataSourceWhereInput>;
      metricDefinition?: XOR<MetricDefinitionScalarRelationFilter, MetricDefinitionWhereInput>;
    },
    "id"
  >;

  export type ColumnMappingOrderByWithAggregationInput = {
    id?: SortOrder;
    columnName?: SortOrder;
    transformationRule?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dataSourceId?: SortOrder;
    metricDefinitionId?: SortOrder;
    _count?: ColumnMappingCountOrderByAggregateInput;
    _max?: ColumnMappingMaxOrderByAggregateInput;
    _min?: ColumnMappingMinOrderByAggregateInput;
  };

  export type ColumnMappingScalarWhereWithAggregatesInput = {
    AND?:
      | ColumnMappingScalarWhereWithAggregatesInput
      | ColumnMappingScalarWhereWithAggregatesInput[];
    OR?: ColumnMappingScalarWhereWithAggregatesInput[];
    NOT?:
      | ColumnMappingScalarWhereWithAggregatesInput
      | ColumnMappingScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"ColumnMapping"> | string;
    columnName?: StringWithAggregatesFilter<"ColumnMapping"> | string;
    transformationRule?: StringNullableWithAggregatesFilter<"ColumnMapping"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"ColumnMapping"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"ColumnMapping"> | Date | string;
    dataSourceId?: StringWithAggregatesFilter<"ColumnMapping"> | string;
    metricDefinitionId?: StringWithAggregatesFilter<"ColumnMapping"> | string;
  };

  export type MetricValueWhereInput = {
    AND?: MetricValueWhereInput | MetricValueWhereInput[];
    OR?: MetricValueWhereInput[];
    NOT?: MetricValueWhereInput | MetricValueWhereInput[];
    id?: StringFilter<"MetricValue"> | string;
    date?: DateTimeFilter<"MetricValue"> | Date | string;
    value?: StringFilter<"MetricValue"> | string;
    sourceType?: StringFilter<"MetricValue"> | string;
    sourceSheet?: StringNullableFilter<"MetricValue"> | string | null;
    externalId?: StringNullableFilter<"MetricValue"> | string | null;
    createdAt?: DateTimeFilter<"MetricValue"> | Date | string;
    updatedAt?: DateTimeFilter<"MetricValue"> | Date | string;
    metricDefinitionId?: StringFilter<"MetricValue"> | string;
    clinicId?: StringNullableFilter<"MetricValue"> | string | null;
    providerId?: StringNullableFilter<"MetricValue"> | string | null;
    dataSourceId?: StringNullableFilter<"MetricValue"> | string | null;
    metricDefinition?: XOR<MetricDefinitionScalarRelationFilter, MetricDefinitionWhereInput>;
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null;
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null;
    dataSource?: XOR<DataSourceNullableScalarRelationFilter, DataSourceWhereInput> | null;
  };

  export type MetricValueOrderByWithRelationInput = {
    id?: SortOrder;
    date?: SortOrder;
    value?: SortOrder;
    sourceType?: SortOrder;
    sourceSheet?: SortOrderInput | SortOrder;
    externalId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrderInput | SortOrder;
    providerId?: SortOrderInput | SortOrder;
    dataSourceId?: SortOrderInput | SortOrder;
    metricDefinition?: MetricDefinitionOrderByWithRelationInput;
    clinic?: ClinicOrderByWithRelationInput;
    provider?: ProviderOrderByWithRelationInput;
    dataSource?: DataSourceOrderByWithRelationInput;
  };

  export type MetricValueWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MetricValueWhereInput | MetricValueWhereInput[];
      OR?: MetricValueWhereInput[];
      NOT?: MetricValueWhereInput | MetricValueWhereInput[];
      date?: DateTimeFilter<"MetricValue"> | Date | string;
      value?: StringFilter<"MetricValue"> | string;
      sourceType?: StringFilter<"MetricValue"> | string;
      sourceSheet?: StringNullableFilter<"MetricValue"> | string | null;
      externalId?: StringNullableFilter<"MetricValue"> | string | null;
      createdAt?: DateTimeFilter<"MetricValue"> | Date | string;
      updatedAt?: DateTimeFilter<"MetricValue"> | Date | string;
      metricDefinitionId?: StringFilter<"MetricValue"> | string;
      clinicId?: StringNullableFilter<"MetricValue"> | string | null;
      providerId?: StringNullableFilter<"MetricValue"> | string | null;
      dataSourceId?: StringNullableFilter<"MetricValue"> | string | null;
      metricDefinition?: XOR<MetricDefinitionScalarRelationFilter, MetricDefinitionWhereInput>;
      clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null;
      provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null;
      dataSource?: XOR<DataSourceNullableScalarRelationFilter, DataSourceWhereInput> | null;
    },
    "id"
  >;

  export type MetricValueOrderByWithAggregationInput = {
    id?: SortOrder;
    date?: SortOrder;
    value?: SortOrder;
    sourceType?: SortOrder;
    sourceSheet?: SortOrderInput | SortOrder;
    externalId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrderInput | SortOrder;
    providerId?: SortOrderInput | SortOrder;
    dataSourceId?: SortOrderInput | SortOrder;
    _count?: MetricValueCountOrderByAggregateInput;
    _max?: MetricValueMaxOrderByAggregateInput;
    _min?: MetricValueMinOrderByAggregateInput;
  };

  export type MetricValueScalarWhereWithAggregatesInput = {
    AND?: MetricValueScalarWhereWithAggregatesInput | MetricValueScalarWhereWithAggregatesInput[];
    OR?: MetricValueScalarWhereWithAggregatesInput[];
    NOT?: MetricValueScalarWhereWithAggregatesInput | MetricValueScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"MetricValue"> | string;
    date?: DateTimeWithAggregatesFilter<"MetricValue"> | Date | string;
    value?: StringWithAggregatesFilter<"MetricValue"> | string;
    sourceType?: StringWithAggregatesFilter<"MetricValue"> | string;
    sourceSheet?: StringNullableWithAggregatesFilter<"MetricValue"> | string | null;
    externalId?: StringNullableWithAggregatesFilter<"MetricValue"> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<"MetricValue"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"MetricValue"> | Date | string;
    metricDefinitionId?: StringWithAggregatesFilter<"MetricValue"> | string;
    clinicId?: StringNullableWithAggregatesFilter<"MetricValue"> | string | null;
    providerId?: StringNullableWithAggregatesFilter<"MetricValue"> | string | null;
    dataSourceId?: StringNullableWithAggregatesFilter<"MetricValue"> | string | null;
  };

  export type GoalWhereInput = {
    AND?: GoalWhereInput | GoalWhereInput[];
    OR?: GoalWhereInput[];
    NOT?: GoalWhereInput | GoalWhereInput[];
    id?: StringFilter<"Goal"> | string;
    timePeriod?: StringFilter<"Goal"> | string;
    startDate?: DateTimeFilter<"Goal"> | Date | string;
    endDate?: DateTimeFilter<"Goal"> | Date | string;
    targetValue?: StringFilter<"Goal"> | string;
    createdAt?: DateTimeFilter<"Goal"> | Date | string;
    updatedAt?: DateTimeFilter<"Goal"> | Date | string;
    metricDefinitionId?: StringFilter<"Goal"> | string;
    clinicId?: StringNullableFilter<"Goal"> | string | null;
    providerId?: StringNullableFilter<"Goal"> | string | null;
    metricDefinition?: XOR<MetricDefinitionScalarRelationFilter, MetricDefinitionWhereInput>;
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null;
    provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null;
  };

  export type GoalOrderByWithRelationInput = {
    id?: SortOrder;
    timePeriod?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    targetValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrderInput | SortOrder;
    providerId?: SortOrderInput | SortOrder;
    metricDefinition?: MetricDefinitionOrderByWithRelationInput;
    clinic?: ClinicOrderByWithRelationInput;
    provider?: ProviderOrderByWithRelationInput;
  };

  export type GoalWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: GoalWhereInput | GoalWhereInput[];
      OR?: GoalWhereInput[];
      NOT?: GoalWhereInput | GoalWhereInput[];
      timePeriod?: StringFilter<"Goal"> | string;
      startDate?: DateTimeFilter<"Goal"> | Date | string;
      endDate?: DateTimeFilter<"Goal"> | Date | string;
      targetValue?: StringFilter<"Goal"> | string;
      createdAt?: DateTimeFilter<"Goal"> | Date | string;
      updatedAt?: DateTimeFilter<"Goal"> | Date | string;
      metricDefinitionId?: StringFilter<"Goal"> | string;
      clinicId?: StringNullableFilter<"Goal"> | string | null;
      providerId?: StringNullableFilter<"Goal"> | string | null;
      metricDefinition?: XOR<MetricDefinitionScalarRelationFilter, MetricDefinitionWhereInput>;
      clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null;
      provider?: XOR<ProviderNullableScalarRelationFilter, ProviderWhereInput> | null;
    },
    "id"
  >;

  export type GoalOrderByWithAggregationInput = {
    id?: SortOrder;
    timePeriod?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    targetValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrderInput | SortOrder;
    providerId?: SortOrderInput | SortOrder;
    _count?: GoalCountOrderByAggregateInput;
    _max?: GoalMaxOrderByAggregateInput;
    _min?: GoalMinOrderByAggregateInput;
  };

  export type GoalScalarWhereWithAggregatesInput = {
    AND?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[];
    OR?: GoalScalarWhereWithAggregatesInput[];
    NOT?: GoalScalarWhereWithAggregatesInput | GoalScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Goal"> | string;
    timePeriod?: StringWithAggregatesFilter<"Goal"> | string;
    startDate?: DateTimeWithAggregatesFilter<"Goal"> | Date | string;
    endDate?: DateTimeWithAggregatesFilter<"Goal"> | Date | string;
    targetValue?: StringWithAggregatesFilter<"Goal"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Goal"> | Date | string;
    metricDefinitionId?: StringWithAggregatesFilter<"Goal"> | string;
    clinicId?: StringNullableWithAggregatesFilter<"Goal"> | string | null;
    providerId?: StringNullableWithAggregatesFilter<"Goal"> | string | null;
  };

  export type DashboardWhereInput = {
    AND?: DashboardWhereInput | DashboardWhereInput[];
    OR?: DashboardWhereInput[];
    NOT?: DashboardWhereInput | DashboardWhereInput[];
    id?: StringFilter<"Dashboard"> | string;
    name?: StringFilter<"Dashboard"> | string;
    isDefault?: BoolFilter<"Dashboard"> | boolean;
    layoutConfig?: JsonNullableFilter<"Dashboard">;
    createdAt?: DateTimeFilter<"Dashboard"> | Date | string;
    updatedAt?: DateTimeFilter<"Dashboard"> | Date | string;
    userId?: StringFilter<"Dashboard"> | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    widgets?: WidgetListRelationFilter;
  };

  export type DashboardOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    isDefault?: SortOrder;
    layoutConfig?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
    user?: UserOrderByWithRelationInput;
    widgets?: WidgetOrderByRelationAggregateInput;
  };

  export type DashboardWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DashboardWhereInput | DashboardWhereInput[];
      OR?: DashboardWhereInput[];
      NOT?: DashboardWhereInput | DashboardWhereInput[];
      name?: StringFilter<"Dashboard"> | string;
      isDefault?: BoolFilter<"Dashboard"> | boolean;
      layoutConfig?: JsonNullableFilter<"Dashboard">;
      createdAt?: DateTimeFilter<"Dashboard"> | Date | string;
      updatedAt?: DateTimeFilter<"Dashboard"> | Date | string;
      userId?: StringFilter<"Dashboard"> | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      widgets?: WidgetListRelationFilter;
    },
    "id"
  >;

  export type DashboardOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    isDefault?: SortOrder;
    layoutConfig?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
    _count?: DashboardCountOrderByAggregateInput;
    _max?: DashboardMaxOrderByAggregateInput;
    _min?: DashboardMinOrderByAggregateInput;
  };

  export type DashboardScalarWhereWithAggregatesInput = {
    AND?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[];
    OR?: DashboardScalarWhereWithAggregatesInput[];
    NOT?: DashboardScalarWhereWithAggregatesInput | DashboardScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Dashboard"> | string;
    name?: StringWithAggregatesFilter<"Dashboard"> | string;
    isDefault?: BoolWithAggregatesFilter<"Dashboard"> | boolean;
    layoutConfig?: JsonNullableWithAggregatesFilter<"Dashboard">;
    createdAt?: DateTimeWithAggregatesFilter<"Dashboard"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Dashboard"> | Date | string;
    userId?: StringWithAggregatesFilter<"Dashboard"> | string;
  };

  export type WidgetWhereInput = {
    AND?: WidgetWhereInput | WidgetWhereInput[];
    OR?: WidgetWhereInput[];
    NOT?: WidgetWhereInput | WidgetWhereInput[];
    id?: StringFilter<"Widget"> | string;
    widgetType?: StringFilter<"Widget"> | string;
    chartType?: StringNullableFilter<"Widget"> | string | null;
    positionX?: IntFilter<"Widget"> | number;
    positionY?: IntFilter<"Widget"> | number;
    width?: IntFilter<"Widget"> | number;
    height?: IntFilter<"Widget"> | number;
    config?: JsonNullableFilter<"Widget">;
    createdAt?: DateTimeFilter<"Widget"> | Date | string;
    updatedAt?: DateTimeFilter<"Widget"> | Date | string;
    dashboardId?: StringFilter<"Widget"> | string;
    metricDefinitionId?: StringNullableFilter<"Widget"> | string | null;
    dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>;
    metricDefinition?: XOR<
      MetricDefinitionNullableScalarRelationFilter,
      MetricDefinitionWhereInput
    > | null;
  };

  export type WidgetOrderByWithRelationInput = {
    id?: SortOrder;
    widgetType?: SortOrder;
    chartType?: SortOrderInput | SortOrder;
    positionX?: SortOrder;
    positionY?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
    config?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dashboardId?: SortOrder;
    metricDefinitionId?: SortOrderInput | SortOrder;
    dashboard?: DashboardOrderByWithRelationInput;
    metricDefinition?: MetricDefinitionOrderByWithRelationInput;
  };

  export type WidgetWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: WidgetWhereInput | WidgetWhereInput[];
      OR?: WidgetWhereInput[];
      NOT?: WidgetWhereInput | WidgetWhereInput[];
      widgetType?: StringFilter<"Widget"> | string;
      chartType?: StringNullableFilter<"Widget"> | string | null;
      positionX?: IntFilter<"Widget"> | number;
      positionY?: IntFilter<"Widget"> | number;
      width?: IntFilter<"Widget"> | number;
      height?: IntFilter<"Widget"> | number;
      config?: JsonNullableFilter<"Widget">;
      createdAt?: DateTimeFilter<"Widget"> | Date | string;
      updatedAt?: DateTimeFilter<"Widget"> | Date | string;
      dashboardId?: StringFilter<"Widget"> | string;
      metricDefinitionId?: StringNullableFilter<"Widget"> | string | null;
      dashboard?: XOR<DashboardScalarRelationFilter, DashboardWhereInput>;
      metricDefinition?: XOR<
        MetricDefinitionNullableScalarRelationFilter,
        MetricDefinitionWhereInput
      > | null;
    },
    "id"
  >;

  export type WidgetOrderByWithAggregationInput = {
    id?: SortOrder;
    widgetType?: SortOrder;
    chartType?: SortOrderInput | SortOrder;
    positionX?: SortOrder;
    positionY?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
    config?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dashboardId?: SortOrder;
    metricDefinitionId?: SortOrderInput | SortOrder;
    _count?: WidgetCountOrderByAggregateInput;
    _avg?: WidgetAvgOrderByAggregateInput;
    _max?: WidgetMaxOrderByAggregateInput;
    _min?: WidgetMinOrderByAggregateInput;
    _sum?: WidgetSumOrderByAggregateInput;
  };

  export type WidgetScalarWhereWithAggregatesInput = {
    AND?: WidgetScalarWhereWithAggregatesInput | WidgetScalarWhereWithAggregatesInput[];
    OR?: WidgetScalarWhereWithAggregatesInput[];
    NOT?: WidgetScalarWhereWithAggregatesInput | WidgetScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"Widget"> | string;
    widgetType?: StringWithAggregatesFilter<"Widget"> | string;
    chartType?: StringNullableWithAggregatesFilter<"Widget"> | string | null;
    positionX?: IntWithAggregatesFilter<"Widget"> | number;
    positionY?: IntWithAggregatesFilter<"Widget"> | number;
    width?: IntWithAggregatesFilter<"Widget"> | number;
    height?: IntWithAggregatesFilter<"Widget"> | number;
    config?: JsonNullableWithAggregatesFilter<"Widget">;
    createdAt?: DateTimeWithAggregatesFilter<"Widget"> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<"Widget"> | Date | string;
    dashboardId?: StringWithAggregatesFilter<"Widget"> | string;
    metricDefinitionId?: StringNullableWithAggregatesFilter<"Widget"> | string | null;
  };

  export type ClinicCreateInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserCreateNestedManyWithoutClinicInput;
    providers?: ProviderCreateNestedManyWithoutClinicInput;
    metrics?: MetricValueCreateNestedManyWithoutClinicInput;
    goals?: GoalCreateNestedManyWithoutClinicInput;
  };

  export type ClinicUncheckedCreateInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserUncheckedCreateNestedManyWithoutClinicInput;
    providers?: ProviderUncheckedCreateNestedManyWithoutClinicInput;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutClinicInput;
    goals?: GoalUncheckedCreateNestedManyWithoutClinicInput;
  };

  export type ClinicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUpdateManyWithoutClinicNestedInput;
    providers?: ProviderUpdateManyWithoutClinicNestedInput;
    metrics?: MetricValueUpdateManyWithoutClinicNestedInput;
    goals?: GoalUpdateManyWithoutClinicNestedInput;
  };

  export type ClinicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput;
    providers?: ProviderUncheckedUpdateManyWithoutClinicNestedInput;
    metrics?: MetricValueUncheckedUpdateManyWithoutClinicNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutClinicNestedInput;
  };

  export type ClinicCreateManyInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ClinicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ClinicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    name: string;
    role: string;
    lastLogin?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinic: ClinicCreateNestedOneWithoutUsersInput;
    dashboards?: DashboardCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    name: string;
    role: string;
    lastLogin?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId: string;
    dashboards?: DashboardUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinic?: ClinicUpdateOneRequiredWithoutUsersNestedInput;
    dashboards?: DashboardUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: StringFieldUpdateOperationsInput | string;
    dashboards?: DashboardUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    name: string;
    role: string;
    lastLogin?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId: string;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: StringFieldUpdateOperationsInput | string;
  };

  export type ProviderCreateInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinic: ClinicCreateNestedOneWithoutProvidersInput;
    metrics?: MetricValueCreateNestedManyWithoutProviderInput;
    goals?: GoalCreateNestedManyWithoutProviderInput;
  };

  export type ProviderUncheckedCreateInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId: string;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutProviderInput;
    goals?: GoalUncheckedCreateNestedManyWithoutProviderInput;
  };

  export type ProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinic?: ClinicUpdateOneRequiredWithoutProvidersNestedInput;
    metrics?: MetricValueUpdateManyWithoutProviderNestedInput;
    goals?: GoalUpdateManyWithoutProviderNestedInput;
  };

  export type ProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: StringFieldUpdateOperationsInput | string;
    metrics?: MetricValueUncheckedUpdateManyWithoutProviderNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutProviderNestedInput;
  };

  export type ProviderCreateManyInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId: string;
  };

  export type ProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: StringFieldUpdateOperationsInput | string;
  };

  export type MetricDefinitionCreateInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueCreateNestedManyWithoutMetricDefinitionInput;
    columnMappings?: ColumnMappingCreateNestedManyWithoutMetricDefinitionInput;
    goals?: GoalCreateNestedManyWithoutMetricDefinitionInput;
    widgets?: WidgetCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionUncheckedCreateInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    columnMappings?: ColumnMappingUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    goals?: GoalUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    widgets?: WidgetUncheckedCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUpdateManyWithoutMetricDefinitionNestedInput;
    columnMappings?: ColumnMappingUpdateManyWithoutMetricDefinitionNestedInput;
    goals?: GoalUpdateManyWithoutMetricDefinitionNestedInput;
    widgets?: WidgetUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type MetricDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    columnMappings?: ColumnMappingUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    widgets?: WidgetUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type MetricDefinitionCreateManyInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MetricDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MetricDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DataSourceCreateInput = {
    id?: string;
    name: string;
    spreadsheetId: string;
    sheetName: string;
    lastSyncedAt?: Date | string | null;
    syncFrequency: string;
    connectionStatus: string;
    appScriptId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    columnMappings?: ColumnMappingCreateNestedManyWithoutDataSourceInput;
    metrics?: MetricValueCreateNestedManyWithoutDataSourceInput;
  };

  export type DataSourceUncheckedCreateInput = {
    id?: string;
    name: string;
    spreadsheetId: string;
    sheetName: string;
    lastSyncedAt?: Date | string | null;
    syncFrequency: string;
    connectionStatus: string;
    appScriptId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    columnMappings?: ColumnMappingUncheckedCreateNestedManyWithoutDataSourceInput;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutDataSourceInput;
  };

  export type DataSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    spreadsheetId?: StringFieldUpdateOperationsInput | string;
    sheetName?: StringFieldUpdateOperationsInput | string;
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    syncFrequency?: StringFieldUpdateOperationsInput | string;
    connectionStatus?: StringFieldUpdateOperationsInput | string;
    appScriptId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    columnMappings?: ColumnMappingUpdateManyWithoutDataSourceNestedInput;
    metrics?: MetricValueUpdateManyWithoutDataSourceNestedInput;
  };

  export type DataSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    spreadsheetId?: StringFieldUpdateOperationsInput | string;
    sheetName?: StringFieldUpdateOperationsInput | string;
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    syncFrequency?: StringFieldUpdateOperationsInput | string;
    connectionStatus?: StringFieldUpdateOperationsInput | string;
    appScriptId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    columnMappings?: ColumnMappingUncheckedUpdateManyWithoutDataSourceNestedInput;
    metrics?: MetricValueUncheckedUpdateManyWithoutDataSourceNestedInput;
  };

  export type DataSourceCreateManyInput = {
    id?: string;
    name: string;
    spreadsheetId: string;
    sheetName: string;
    lastSyncedAt?: Date | string | null;
    syncFrequency: string;
    connectionStatus: string;
    appScriptId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DataSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    spreadsheetId?: StringFieldUpdateOperationsInput | string;
    sheetName?: StringFieldUpdateOperationsInput | string;
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    syncFrequency?: StringFieldUpdateOperationsInput | string;
    connectionStatus?: StringFieldUpdateOperationsInput | string;
    appScriptId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DataSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    spreadsheetId?: StringFieldUpdateOperationsInput | string;
    sheetName?: StringFieldUpdateOperationsInput | string;
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    syncFrequency?: StringFieldUpdateOperationsInput | string;
    connectionStatus?: StringFieldUpdateOperationsInput | string;
    appScriptId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ColumnMappingCreateInput = {
    id?: string;
    columnName: string;
    transformationRule?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dataSource: DataSourceCreateNestedOneWithoutColumnMappingsInput;
    metricDefinition: MetricDefinitionCreateNestedOneWithoutColumnMappingsInput;
  };

  export type ColumnMappingUncheckedCreateInput = {
    id?: string;
    columnName: string;
    transformationRule?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dataSourceId: string;
    metricDefinitionId: string;
  };

  export type ColumnMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dataSource?: DataSourceUpdateOneRequiredWithoutColumnMappingsNestedInput;
    metricDefinition?: MetricDefinitionUpdateOneRequiredWithoutColumnMappingsNestedInput;
  };

  export type ColumnMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dataSourceId?: StringFieldUpdateOperationsInput | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
  };

  export type ColumnMappingCreateManyInput = {
    id?: string;
    columnName: string;
    transformationRule?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dataSourceId: string;
    metricDefinitionId: string;
  };

  export type ColumnMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ColumnMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dataSourceId?: StringFieldUpdateOperationsInput | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
  };

  export type MetricValueCreateInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinition: MetricDefinitionCreateNestedOneWithoutMetricsInput;
    clinic?: ClinicCreateNestedOneWithoutMetricsInput;
    provider?: ProviderCreateNestedOneWithoutMetricsInput;
    dataSource?: DataSourceCreateNestedOneWithoutMetricsInput;
  };

  export type MetricValueUncheckedCreateInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
    providerId?: string | null;
    dataSourceId?: string | null;
  };

  export type MetricValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinition?: MetricDefinitionUpdateOneRequiredWithoutMetricsNestedInput;
    clinic?: ClinicUpdateOneWithoutMetricsNestedInput;
    provider?: ProviderUpdateOneWithoutMetricsNestedInput;
    dataSource?: DataSourceUpdateOneWithoutMetricsNestedInput;
  };

  export type MetricValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
    dataSourceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type MetricValueCreateManyInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
    providerId?: string | null;
    dataSourceId?: string | null;
  };

  export type MetricValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MetricValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
    dataSourceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type GoalCreateInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinition: MetricDefinitionCreateNestedOneWithoutGoalsInput;
    clinic?: ClinicCreateNestedOneWithoutGoalsInput;
    provider?: ProviderCreateNestedOneWithoutGoalsInput;
  };

  export type GoalUncheckedCreateInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
    providerId?: string | null;
  };

  export type GoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinition?: MetricDefinitionUpdateOneRequiredWithoutGoalsNestedInput;
    clinic?: ClinicUpdateOneWithoutGoalsNestedInput;
    provider?: ProviderUpdateOneWithoutGoalsNestedInput;
  };

  export type GoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type GoalCreateManyInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
    providerId?: string | null;
  };

  export type GoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DashboardCreateInput = {
    id?: string;
    name: string;
    isDefault?: boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutDashboardsInput;
    widgets?: WidgetCreateNestedManyWithoutDashboardInput;
  };

  export type DashboardUncheckedCreateInput = {
    id?: string;
    name: string;
    isDefault?: boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
    widgets?: WidgetUncheckedCreateNestedManyWithoutDashboardInput;
  };

  export type DashboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutDashboardsNestedInput;
    widgets?: WidgetUpdateManyWithoutDashboardNestedInput;
  };

  export type DashboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    widgets?: WidgetUncheckedUpdateManyWithoutDashboardNestedInput;
  };

  export type DashboardCreateManyInput = {
    id?: string;
    name: string;
    isDefault?: boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
  };

  export type DashboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DashboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type WidgetCreateInput = {
    id?: string;
    widgetType: string;
    chartType?: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dashboard: DashboardCreateNestedOneWithoutWidgetsInput;
    metricDefinition?: MetricDefinitionCreateNestedOneWithoutWidgetsInput;
  };

  export type WidgetUncheckedCreateInput = {
    id?: string;
    widgetType: string;
    chartType?: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dashboardId: string;
    metricDefinitionId?: string | null;
  };

  export type WidgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dashboard?: DashboardUpdateOneRequiredWithoutWidgetsNestedInput;
    metricDefinition?: MetricDefinitionUpdateOneWithoutWidgetsNestedInput;
  };

  export type WidgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dashboardId?: StringFieldUpdateOperationsInput | string;
    metricDefinitionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WidgetCreateManyInput = {
    id?: string;
    widgetType: string;
    chartType?: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dashboardId: string;
    metricDefinitionId?: string | null;
  };

  export type WidgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WidgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dashboardId?: StringFieldUpdateOperationsInput | string;
    metricDefinitionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type UserListRelationFilter = {
    every?: UserWhereInput;
    some?: UserWhereInput;
    none?: UserWhereInput;
  };

  export type ProviderListRelationFilter = {
    every?: ProviderWhereInput;
    some?: ProviderWhereInput;
    none?: ProviderWhereInput;
  };

  export type MetricValueListRelationFilter = {
    every?: MetricValueWhereInput;
    some?: MetricValueWhereInput;
    none?: MetricValueWhereInput;
  };

  export type GoalListRelationFilter = {
    every?: GoalWhereInput;
    some?: GoalWhereInput;
    none?: GoalWhereInput;
  };

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProviderOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MetricValueOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type GoalOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ClinicCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    location?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ClinicMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    location?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ClinicMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    location?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type ClinicScalarRelationFilter = {
    is?: ClinicWhereInput;
    isNot?: ClinicWhereInput;
  };

  export type DashboardListRelationFilter = {
    every?: DashboardWhereInput;
    some?: DashboardWhereInput;
    none?: DashboardWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type DashboardOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    lastLogin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    lastLogin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    name?: SortOrder;
    role?: SortOrder;
    lastLogin?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    providerType?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
  };

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    providerType?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
  };

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    providerType?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    clinicId?: SortOrder;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type ColumnMappingListRelationFilter = {
    every?: ColumnMappingWhereInput;
    some?: ColumnMappingWhereInput;
    none?: ColumnMappingWhereInput;
  };

  export type WidgetListRelationFilter = {
    every?: WidgetWhereInput;
    some?: WidgetWhereInput;
    none?: WidgetWhereInput;
  };

  export type ColumnMappingOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type WidgetOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MetricDefinitionCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    dataType?: SortOrder;
    calculationFormula?: SortOrder;
    category?: SortOrder;
    isComposite?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MetricDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    dataType?: SortOrder;
    calculationFormula?: SortOrder;
    category?: SortOrder;
    isComposite?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MetricDefinitionMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    dataType?: SortOrder;
    calculationFormula?: SortOrder;
    category?: SortOrder;
    isComposite?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type DataSourceCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    spreadsheetId?: SortOrder;
    sheetName?: SortOrder;
    lastSyncedAt?: SortOrder;
    syncFrequency?: SortOrder;
    connectionStatus?: SortOrder;
    appScriptId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DataSourceMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    spreadsheetId?: SortOrder;
    sheetName?: SortOrder;
    lastSyncedAt?: SortOrder;
    syncFrequency?: SortOrder;
    connectionStatus?: SortOrder;
    appScriptId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DataSourceMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    spreadsheetId?: SortOrder;
    sheetName?: SortOrder;
    lastSyncedAt?: SortOrder;
    syncFrequency?: SortOrder;
    connectionStatus?: SortOrder;
    appScriptId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DataSourceScalarRelationFilter = {
    is?: DataSourceWhereInput;
    isNot?: DataSourceWhereInput;
  };

  export type MetricDefinitionScalarRelationFilter = {
    is?: MetricDefinitionWhereInput;
    isNot?: MetricDefinitionWhereInput;
  };

  export type ColumnMappingCountOrderByAggregateInput = {
    id?: SortOrder;
    columnName?: SortOrder;
    transformationRule?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dataSourceId?: SortOrder;
    metricDefinitionId?: SortOrder;
  };

  export type ColumnMappingMaxOrderByAggregateInput = {
    id?: SortOrder;
    columnName?: SortOrder;
    transformationRule?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dataSourceId?: SortOrder;
    metricDefinitionId?: SortOrder;
  };

  export type ColumnMappingMinOrderByAggregateInput = {
    id?: SortOrder;
    columnName?: SortOrder;
    transformationRule?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dataSourceId?: SortOrder;
    metricDefinitionId?: SortOrder;
  };

  export type ClinicNullableScalarRelationFilter = {
    is?: ClinicWhereInput | null;
    isNot?: ClinicWhereInput | null;
  };

  export type ProviderNullableScalarRelationFilter = {
    is?: ProviderWhereInput | null;
    isNot?: ProviderWhereInput | null;
  };

  export type DataSourceNullableScalarRelationFilter = {
    is?: DataSourceWhereInput | null;
    isNot?: DataSourceWhereInput | null;
  };

  export type MetricValueCountOrderByAggregateInput = {
    id?: SortOrder;
    date?: SortOrder;
    value?: SortOrder;
    sourceType?: SortOrder;
    sourceSheet?: SortOrder;
    externalId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrder;
    providerId?: SortOrder;
    dataSourceId?: SortOrder;
  };

  export type MetricValueMaxOrderByAggregateInput = {
    id?: SortOrder;
    date?: SortOrder;
    value?: SortOrder;
    sourceType?: SortOrder;
    sourceSheet?: SortOrder;
    externalId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrder;
    providerId?: SortOrder;
    dataSourceId?: SortOrder;
  };

  export type MetricValueMinOrderByAggregateInput = {
    id?: SortOrder;
    date?: SortOrder;
    value?: SortOrder;
    sourceType?: SortOrder;
    sourceSheet?: SortOrder;
    externalId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrder;
    providerId?: SortOrder;
    dataSourceId?: SortOrder;
  };

  export type GoalCountOrderByAggregateInput = {
    id?: SortOrder;
    timePeriod?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    targetValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrder;
    providerId?: SortOrder;
  };

  export type GoalMaxOrderByAggregateInput = {
    id?: SortOrder;
    timePeriod?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    targetValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrder;
    providerId?: SortOrder;
  };

  export type GoalMinOrderByAggregateInput = {
    id?: SortOrder;
    timePeriod?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    targetValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    metricDefinitionId?: SortOrder;
    clinicId?: SortOrder;
    providerId?: SortOrder;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, "path">>;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type DashboardCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    isDefault?: SortOrder;
    layoutConfig?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
  };

  export type DashboardMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
  };

  export type DashboardMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    userId?: SortOrder;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, "path">>;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type DashboardScalarRelationFilter = {
    is?: DashboardWhereInput;
    isNot?: DashboardWhereInput;
  };

  export type MetricDefinitionNullableScalarRelationFilter = {
    is?: MetricDefinitionWhereInput | null;
    isNot?: MetricDefinitionWhereInput | null;
  };

  export type WidgetCountOrderByAggregateInput = {
    id?: SortOrder;
    widgetType?: SortOrder;
    chartType?: SortOrder;
    positionX?: SortOrder;
    positionY?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
    config?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dashboardId?: SortOrder;
    metricDefinitionId?: SortOrder;
  };

  export type WidgetAvgOrderByAggregateInput = {
    positionX?: SortOrder;
    positionY?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
  };

  export type WidgetMaxOrderByAggregateInput = {
    id?: SortOrder;
    widgetType?: SortOrder;
    chartType?: SortOrder;
    positionX?: SortOrder;
    positionY?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dashboardId?: SortOrder;
    metricDefinitionId?: SortOrder;
  };

  export type WidgetMinOrderByAggregateInput = {
    id?: SortOrder;
    widgetType?: SortOrder;
    chartType?: SortOrder;
    positionX?: SortOrder;
    positionY?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    dashboardId?: SortOrder;
    metricDefinitionId?: SortOrder;
  };

  export type WidgetSumOrderByAggregateInput = {
    positionX?: SortOrder;
    positionY?: SortOrder;
    width?: SortOrder;
    height?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type UserCreateNestedManyWithoutClinicInput = {
    create?:
      | XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>
      | UserCreateWithoutClinicInput[]
      | UserUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutClinicInput
      | UserCreateOrConnectWithoutClinicInput[];
    createMany?: UserCreateManyClinicInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type ProviderCreateNestedManyWithoutClinicInput = {
    create?:
      | XOR<ProviderCreateWithoutClinicInput, ProviderUncheckedCreateWithoutClinicInput>
      | ProviderCreateWithoutClinicInput[]
      | ProviderUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | ProviderCreateOrConnectWithoutClinicInput
      | ProviderCreateOrConnectWithoutClinicInput[];
    createMany?: ProviderCreateManyClinicInputEnvelope;
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
  };

  export type MetricValueCreateNestedManyWithoutClinicInput = {
    create?:
      | XOR<MetricValueCreateWithoutClinicInput, MetricValueUncheckedCreateWithoutClinicInput>
      | MetricValueCreateWithoutClinicInput[]
      | MetricValueUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutClinicInput
      | MetricValueCreateOrConnectWithoutClinicInput[];
    createMany?: MetricValueCreateManyClinicInputEnvelope;
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
  };

  export type GoalCreateNestedManyWithoutClinicInput = {
    create?:
      | XOR<GoalCreateWithoutClinicInput, GoalUncheckedCreateWithoutClinicInput>
      | GoalCreateWithoutClinicInput[]
      | GoalUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutClinicInput
      | GoalCreateOrConnectWithoutClinicInput[];
    createMany?: GoalCreateManyClinicInputEnvelope;
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
  };

  export type UserUncheckedCreateNestedManyWithoutClinicInput = {
    create?:
      | XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>
      | UserCreateWithoutClinicInput[]
      | UserUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutClinicInput
      | UserCreateOrConnectWithoutClinicInput[];
    createMany?: UserCreateManyClinicInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type ProviderUncheckedCreateNestedManyWithoutClinicInput = {
    create?:
      | XOR<ProviderCreateWithoutClinicInput, ProviderUncheckedCreateWithoutClinicInput>
      | ProviderCreateWithoutClinicInput[]
      | ProviderUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | ProviderCreateOrConnectWithoutClinicInput
      | ProviderCreateOrConnectWithoutClinicInput[];
    createMany?: ProviderCreateManyClinicInputEnvelope;
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
  };

  export type MetricValueUncheckedCreateNestedManyWithoutClinicInput = {
    create?:
      | XOR<MetricValueCreateWithoutClinicInput, MetricValueUncheckedCreateWithoutClinicInput>
      | MetricValueCreateWithoutClinicInput[]
      | MetricValueUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutClinicInput
      | MetricValueCreateOrConnectWithoutClinicInput[];
    createMany?: MetricValueCreateManyClinicInputEnvelope;
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
  };

  export type GoalUncheckedCreateNestedManyWithoutClinicInput = {
    create?:
      | XOR<GoalCreateWithoutClinicInput, GoalUncheckedCreateWithoutClinicInput>
      | GoalCreateWithoutClinicInput[]
      | GoalUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutClinicInput
      | GoalCreateOrConnectWithoutClinicInput[];
    createMany?: GoalCreateManyClinicInputEnvelope;
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type UserUpdateManyWithoutClinicNestedInput = {
    create?:
      | XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>
      | UserCreateWithoutClinicInput[]
      | UserUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutClinicInput
      | UserCreateOrConnectWithoutClinicInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutClinicInput
      | UserUpsertWithWhereUniqueWithoutClinicInput[];
    createMany?: UserCreateManyClinicInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutClinicInput
      | UserUpdateWithWhereUniqueWithoutClinicInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutClinicInput
      | UserUpdateManyWithWhereWithoutClinicInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type ProviderUpdateManyWithoutClinicNestedInput = {
    create?:
      | XOR<ProviderCreateWithoutClinicInput, ProviderUncheckedCreateWithoutClinicInput>
      | ProviderCreateWithoutClinicInput[]
      | ProviderUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | ProviderCreateOrConnectWithoutClinicInput
      | ProviderCreateOrConnectWithoutClinicInput[];
    upsert?:
      | ProviderUpsertWithWhereUniqueWithoutClinicInput
      | ProviderUpsertWithWhereUniqueWithoutClinicInput[];
    createMany?: ProviderCreateManyClinicInputEnvelope;
    set?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
    disconnect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
    delete?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
    update?:
      | ProviderUpdateWithWhereUniqueWithoutClinicInput
      | ProviderUpdateWithWhereUniqueWithoutClinicInput[];
    updateMany?:
      | ProviderUpdateManyWithWhereWithoutClinicInput
      | ProviderUpdateManyWithWhereWithoutClinicInput[];
    deleteMany?: ProviderScalarWhereInput | ProviderScalarWhereInput[];
  };

  export type MetricValueUpdateManyWithoutClinicNestedInput = {
    create?:
      | XOR<MetricValueCreateWithoutClinicInput, MetricValueUncheckedCreateWithoutClinicInput>
      | MetricValueCreateWithoutClinicInput[]
      | MetricValueUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutClinicInput
      | MetricValueCreateOrConnectWithoutClinicInput[];
    upsert?:
      | MetricValueUpsertWithWhereUniqueWithoutClinicInput
      | MetricValueUpsertWithWhereUniqueWithoutClinicInput[];
    createMany?: MetricValueCreateManyClinicInputEnvelope;
    set?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    disconnect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    delete?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    update?:
      | MetricValueUpdateWithWhereUniqueWithoutClinicInput
      | MetricValueUpdateWithWhereUniqueWithoutClinicInput[];
    updateMany?:
      | MetricValueUpdateManyWithWhereWithoutClinicInput
      | MetricValueUpdateManyWithWhereWithoutClinicInput[];
    deleteMany?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
  };

  export type GoalUpdateManyWithoutClinicNestedInput = {
    create?:
      | XOR<GoalCreateWithoutClinicInput, GoalUncheckedCreateWithoutClinicInput>
      | GoalCreateWithoutClinicInput[]
      | GoalUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutClinicInput
      | GoalCreateOrConnectWithoutClinicInput[];
    upsert?:
      | GoalUpsertWithWhereUniqueWithoutClinicInput
      | GoalUpsertWithWhereUniqueWithoutClinicInput[];
    createMany?: GoalCreateManyClinicInputEnvelope;
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    update?:
      | GoalUpdateWithWhereUniqueWithoutClinicInput
      | GoalUpdateWithWhereUniqueWithoutClinicInput[];
    updateMany?:
      | GoalUpdateManyWithWhereWithoutClinicInput
      | GoalUpdateManyWithWhereWithoutClinicInput[];
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[];
  };

  export type UserUncheckedUpdateManyWithoutClinicNestedInput = {
    create?:
      | XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>
      | UserCreateWithoutClinicInput[]
      | UserUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutClinicInput
      | UserCreateOrConnectWithoutClinicInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutClinicInput
      | UserUpsertWithWhereUniqueWithoutClinicInput[];
    createMany?: UserCreateManyClinicInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutClinicInput
      | UserUpdateWithWhereUniqueWithoutClinicInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutClinicInput
      | UserUpdateManyWithWhereWithoutClinicInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type ProviderUncheckedUpdateManyWithoutClinicNestedInput = {
    create?:
      | XOR<ProviderCreateWithoutClinicInput, ProviderUncheckedCreateWithoutClinicInput>
      | ProviderCreateWithoutClinicInput[]
      | ProviderUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | ProviderCreateOrConnectWithoutClinicInput
      | ProviderCreateOrConnectWithoutClinicInput[];
    upsert?:
      | ProviderUpsertWithWhereUniqueWithoutClinicInput
      | ProviderUpsertWithWhereUniqueWithoutClinicInput[];
    createMany?: ProviderCreateManyClinicInputEnvelope;
    set?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
    disconnect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
    delete?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
    connect?: ProviderWhereUniqueInput | ProviderWhereUniqueInput[];
    update?:
      | ProviderUpdateWithWhereUniqueWithoutClinicInput
      | ProviderUpdateWithWhereUniqueWithoutClinicInput[];
    updateMany?:
      | ProviderUpdateManyWithWhereWithoutClinicInput
      | ProviderUpdateManyWithWhereWithoutClinicInput[];
    deleteMany?: ProviderScalarWhereInput | ProviderScalarWhereInput[];
  };

  export type MetricValueUncheckedUpdateManyWithoutClinicNestedInput = {
    create?:
      | XOR<MetricValueCreateWithoutClinicInput, MetricValueUncheckedCreateWithoutClinicInput>
      | MetricValueCreateWithoutClinicInput[]
      | MetricValueUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutClinicInput
      | MetricValueCreateOrConnectWithoutClinicInput[];
    upsert?:
      | MetricValueUpsertWithWhereUniqueWithoutClinicInput
      | MetricValueUpsertWithWhereUniqueWithoutClinicInput[];
    createMany?: MetricValueCreateManyClinicInputEnvelope;
    set?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    disconnect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    delete?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    update?:
      | MetricValueUpdateWithWhereUniqueWithoutClinicInput
      | MetricValueUpdateWithWhereUniqueWithoutClinicInput[];
    updateMany?:
      | MetricValueUpdateManyWithWhereWithoutClinicInput
      | MetricValueUpdateManyWithWhereWithoutClinicInput[];
    deleteMany?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
  };

  export type GoalUncheckedUpdateManyWithoutClinicNestedInput = {
    create?:
      | XOR<GoalCreateWithoutClinicInput, GoalUncheckedCreateWithoutClinicInput>
      | GoalCreateWithoutClinicInput[]
      | GoalUncheckedCreateWithoutClinicInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutClinicInput
      | GoalCreateOrConnectWithoutClinicInput[];
    upsert?:
      | GoalUpsertWithWhereUniqueWithoutClinicInput
      | GoalUpsertWithWhereUniqueWithoutClinicInput[];
    createMany?: GoalCreateManyClinicInputEnvelope;
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    update?:
      | GoalUpdateWithWhereUniqueWithoutClinicInput
      | GoalUpdateWithWhereUniqueWithoutClinicInput[];
    updateMany?:
      | GoalUpdateManyWithWhereWithoutClinicInput
      | GoalUpdateManyWithWhereWithoutClinicInput[];
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[];
  };

  export type ClinicCreateNestedOneWithoutUsersInput = {
    create?: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>;
    connectOrCreate?: ClinicCreateOrConnectWithoutUsersInput;
    connect?: ClinicWhereUniqueInput;
  };

  export type DashboardCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput>
      | DashboardCreateWithoutUserInput[]
      | DashboardUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DashboardCreateOrConnectWithoutUserInput
      | DashboardCreateOrConnectWithoutUserInput[];
    createMany?: DashboardCreateManyUserInputEnvelope;
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
  };

  export type DashboardUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput>
      | DashboardCreateWithoutUserInput[]
      | DashboardUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DashboardCreateOrConnectWithoutUserInput
      | DashboardCreateOrConnectWithoutUserInput[];
    createMany?: DashboardCreateManyUserInputEnvelope;
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type ClinicUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>;
    connectOrCreate?: ClinicCreateOrConnectWithoutUsersInput;
    upsert?: ClinicUpsertWithoutUsersInput;
    connect?: ClinicWhereUniqueInput;
    update?: XOR<
      XOR<ClinicUpdateToOneWithWhereWithoutUsersInput, ClinicUpdateWithoutUsersInput>,
      ClinicUncheckedUpdateWithoutUsersInput
    >;
  };

  export type DashboardUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput>
      | DashboardCreateWithoutUserInput[]
      | DashboardUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DashboardCreateOrConnectWithoutUserInput
      | DashboardCreateOrConnectWithoutUserInput[];
    upsert?:
      | DashboardUpsertWithWhereUniqueWithoutUserInput
      | DashboardUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: DashboardCreateManyUserInputEnvelope;
    set?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
    disconnect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
    delete?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
    update?:
      | DashboardUpdateWithWhereUniqueWithoutUserInput
      | DashboardUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | DashboardUpdateManyWithWhereWithoutUserInput
      | DashboardUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: DashboardScalarWhereInput | DashboardScalarWhereInput[];
  };

  export type DashboardUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput>
      | DashboardCreateWithoutUserInput[]
      | DashboardUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | DashboardCreateOrConnectWithoutUserInput
      | DashboardCreateOrConnectWithoutUserInput[];
    upsert?:
      | DashboardUpsertWithWhereUniqueWithoutUserInput
      | DashboardUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: DashboardCreateManyUserInputEnvelope;
    set?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
    disconnect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
    delete?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
    connect?: DashboardWhereUniqueInput | DashboardWhereUniqueInput[];
    update?:
      | DashboardUpdateWithWhereUniqueWithoutUserInput
      | DashboardUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | DashboardUpdateManyWithWhereWithoutUserInput
      | DashboardUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: DashboardScalarWhereInput | DashboardScalarWhereInput[];
  };

  export type ClinicCreateNestedOneWithoutProvidersInput = {
    create?: XOR<ClinicCreateWithoutProvidersInput, ClinicUncheckedCreateWithoutProvidersInput>;
    connectOrCreate?: ClinicCreateOrConnectWithoutProvidersInput;
    connect?: ClinicWhereUniqueInput;
  };

  export type MetricValueCreateNestedManyWithoutProviderInput = {
    create?:
      | XOR<MetricValueCreateWithoutProviderInput, MetricValueUncheckedCreateWithoutProviderInput>
      | MetricValueCreateWithoutProviderInput[]
      | MetricValueUncheckedCreateWithoutProviderInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutProviderInput
      | MetricValueCreateOrConnectWithoutProviderInput[];
    createMany?: MetricValueCreateManyProviderInputEnvelope;
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
  };

  export type GoalCreateNestedManyWithoutProviderInput = {
    create?:
      | XOR<GoalCreateWithoutProviderInput, GoalUncheckedCreateWithoutProviderInput>
      | GoalCreateWithoutProviderInput[]
      | GoalUncheckedCreateWithoutProviderInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutProviderInput
      | GoalCreateOrConnectWithoutProviderInput[];
    createMany?: GoalCreateManyProviderInputEnvelope;
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
  };

  export type MetricValueUncheckedCreateNestedManyWithoutProviderInput = {
    create?:
      | XOR<MetricValueCreateWithoutProviderInput, MetricValueUncheckedCreateWithoutProviderInput>
      | MetricValueCreateWithoutProviderInput[]
      | MetricValueUncheckedCreateWithoutProviderInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutProviderInput
      | MetricValueCreateOrConnectWithoutProviderInput[];
    createMany?: MetricValueCreateManyProviderInputEnvelope;
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
  };

  export type GoalUncheckedCreateNestedManyWithoutProviderInput = {
    create?:
      | XOR<GoalCreateWithoutProviderInput, GoalUncheckedCreateWithoutProviderInput>
      | GoalCreateWithoutProviderInput[]
      | GoalUncheckedCreateWithoutProviderInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutProviderInput
      | GoalCreateOrConnectWithoutProviderInput[];
    createMany?: GoalCreateManyProviderInputEnvelope;
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
  };

  export type ClinicUpdateOneRequiredWithoutProvidersNestedInput = {
    create?: XOR<ClinicCreateWithoutProvidersInput, ClinicUncheckedCreateWithoutProvidersInput>;
    connectOrCreate?: ClinicCreateOrConnectWithoutProvidersInput;
    upsert?: ClinicUpsertWithoutProvidersInput;
    connect?: ClinicWhereUniqueInput;
    update?: XOR<
      XOR<ClinicUpdateToOneWithWhereWithoutProvidersInput, ClinicUpdateWithoutProvidersInput>,
      ClinicUncheckedUpdateWithoutProvidersInput
    >;
  };

  export type MetricValueUpdateManyWithoutProviderNestedInput = {
    create?:
      | XOR<MetricValueCreateWithoutProviderInput, MetricValueUncheckedCreateWithoutProviderInput>
      | MetricValueCreateWithoutProviderInput[]
      | MetricValueUncheckedCreateWithoutProviderInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutProviderInput
      | MetricValueCreateOrConnectWithoutProviderInput[];
    upsert?:
      | MetricValueUpsertWithWhereUniqueWithoutProviderInput
      | MetricValueUpsertWithWhereUniqueWithoutProviderInput[];
    createMany?: MetricValueCreateManyProviderInputEnvelope;
    set?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    disconnect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    delete?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    update?:
      | MetricValueUpdateWithWhereUniqueWithoutProviderInput
      | MetricValueUpdateWithWhereUniqueWithoutProviderInput[];
    updateMany?:
      | MetricValueUpdateManyWithWhereWithoutProviderInput
      | MetricValueUpdateManyWithWhereWithoutProviderInput[];
    deleteMany?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
  };

  export type GoalUpdateManyWithoutProviderNestedInput = {
    create?:
      | XOR<GoalCreateWithoutProviderInput, GoalUncheckedCreateWithoutProviderInput>
      | GoalCreateWithoutProviderInput[]
      | GoalUncheckedCreateWithoutProviderInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutProviderInput
      | GoalCreateOrConnectWithoutProviderInput[];
    upsert?:
      | GoalUpsertWithWhereUniqueWithoutProviderInput
      | GoalUpsertWithWhereUniqueWithoutProviderInput[];
    createMany?: GoalCreateManyProviderInputEnvelope;
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    update?:
      | GoalUpdateWithWhereUniqueWithoutProviderInput
      | GoalUpdateWithWhereUniqueWithoutProviderInput[];
    updateMany?:
      | GoalUpdateManyWithWhereWithoutProviderInput
      | GoalUpdateManyWithWhereWithoutProviderInput[];
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[];
  };

  export type MetricValueUncheckedUpdateManyWithoutProviderNestedInput = {
    create?:
      | XOR<MetricValueCreateWithoutProviderInput, MetricValueUncheckedCreateWithoutProviderInput>
      | MetricValueCreateWithoutProviderInput[]
      | MetricValueUncheckedCreateWithoutProviderInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutProviderInput
      | MetricValueCreateOrConnectWithoutProviderInput[];
    upsert?:
      | MetricValueUpsertWithWhereUniqueWithoutProviderInput
      | MetricValueUpsertWithWhereUniqueWithoutProviderInput[];
    createMany?: MetricValueCreateManyProviderInputEnvelope;
    set?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    disconnect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    delete?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    update?:
      | MetricValueUpdateWithWhereUniqueWithoutProviderInput
      | MetricValueUpdateWithWhereUniqueWithoutProviderInput[];
    updateMany?:
      | MetricValueUpdateManyWithWhereWithoutProviderInput
      | MetricValueUpdateManyWithWhereWithoutProviderInput[];
    deleteMany?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
  };

  export type GoalUncheckedUpdateManyWithoutProviderNestedInput = {
    create?:
      | XOR<GoalCreateWithoutProviderInput, GoalUncheckedCreateWithoutProviderInput>
      | GoalCreateWithoutProviderInput[]
      | GoalUncheckedCreateWithoutProviderInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutProviderInput
      | GoalCreateOrConnectWithoutProviderInput[];
    upsert?:
      | GoalUpsertWithWhereUniqueWithoutProviderInput
      | GoalUpsertWithWhereUniqueWithoutProviderInput[];
    createMany?: GoalCreateManyProviderInputEnvelope;
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    update?:
      | GoalUpdateWithWhereUniqueWithoutProviderInput
      | GoalUpdateWithWhereUniqueWithoutProviderInput[];
    updateMany?:
      | GoalUpdateManyWithWhereWithoutProviderInput
      | GoalUpdateManyWithWhereWithoutProviderInput[];
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[];
  };

  export type MetricValueCreateNestedManyWithoutMetricDefinitionInput = {
    create?:
      | XOR<
          MetricValueCreateWithoutMetricDefinitionInput,
          MetricValueUncheckedCreateWithoutMetricDefinitionInput
        >
      | MetricValueCreateWithoutMetricDefinitionInput[]
      | MetricValueUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutMetricDefinitionInput
      | MetricValueCreateOrConnectWithoutMetricDefinitionInput[];
    createMany?: MetricValueCreateManyMetricDefinitionInputEnvelope;
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
  };

  export type ColumnMappingCreateNestedManyWithoutMetricDefinitionInput = {
    create?:
      | XOR<
          ColumnMappingCreateWithoutMetricDefinitionInput,
          ColumnMappingUncheckedCreateWithoutMetricDefinitionInput
        >
      | ColumnMappingCreateWithoutMetricDefinitionInput[]
      | ColumnMappingUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | ColumnMappingCreateOrConnectWithoutMetricDefinitionInput
      | ColumnMappingCreateOrConnectWithoutMetricDefinitionInput[];
    createMany?: ColumnMappingCreateManyMetricDefinitionInputEnvelope;
    connect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
  };

  export type GoalCreateNestedManyWithoutMetricDefinitionInput = {
    create?:
      | XOR<GoalCreateWithoutMetricDefinitionInput, GoalUncheckedCreateWithoutMetricDefinitionInput>
      | GoalCreateWithoutMetricDefinitionInput[]
      | GoalUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutMetricDefinitionInput
      | GoalCreateOrConnectWithoutMetricDefinitionInput[];
    createMany?: GoalCreateManyMetricDefinitionInputEnvelope;
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
  };

  export type WidgetCreateNestedManyWithoutMetricDefinitionInput = {
    create?:
      | XOR<
          WidgetCreateWithoutMetricDefinitionInput,
          WidgetUncheckedCreateWithoutMetricDefinitionInput
        >
      | WidgetCreateWithoutMetricDefinitionInput[]
      | WidgetUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | WidgetCreateOrConnectWithoutMetricDefinitionInput
      | WidgetCreateOrConnectWithoutMetricDefinitionInput[];
    createMany?: WidgetCreateManyMetricDefinitionInputEnvelope;
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
  };

  export type MetricValueUncheckedCreateNestedManyWithoutMetricDefinitionInput = {
    create?:
      | XOR<
          MetricValueCreateWithoutMetricDefinitionInput,
          MetricValueUncheckedCreateWithoutMetricDefinitionInput
        >
      | MetricValueCreateWithoutMetricDefinitionInput[]
      | MetricValueUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutMetricDefinitionInput
      | MetricValueCreateOrConnectWithoutMetricDefinitionInput[];
    createMany?: MetricValueCreateManyMetricDefinitionInputEnvelope;
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
  };

  export type ColumnMappingUncheckedCreateNestedManyWithoutMetricDefinitionInput = {
    create?:
      | XOR<
          ColumnMappingCreateWithoutMetricDefinitionInput,
          ColumnMappingUncheckedCreateWithoutMetricDefinitionInput
        >
      | ColumnMappingCreateWithoutMetricDefinitionInput[]
      | ColumnMappingUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | ColumnMappingCreateOrConnectWithoutMetricDefinitionInput
      | ColumnMappingCreateOrConnectWithoutMetricDefinitionInput[];
    createMany?: ColumnMappingCreateManyMetricDefinitionInputEnvelope;
    connect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
  };

  export type GoalUncheckedCreateNestedManyWithoutMetricDefinitionInput = {
    create?:
      | XOR<GoalCreateWithoutMetricDefinitionInput, GoalUncheckedCreateWithoutMetricDefinitionInput>
      | GoalCreateWithoutMetricDefinitionInput[]
      | GoalUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutMetricDefinitionInput
      | GoalCreateOrConnectWithoutMetricDefinitionInput[];
    createMany?: GoalCreateManyMetricDefinitionInputEnvelope;
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
  };

  export type WidgetUncheckedCreateNestedManyWithoutMetricDefinitionInput = {
    create?:
      | XOR<
          WidgetCreateWithoutMetricDefinitionInput,
          WidgetUncheckedCreateWithoutMetricDefinitionInput
        >
      | WidgetCreateWithoutMetricDefinitionInput[]
      | WidgetUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | WidgetCreateOrConnectWithoutMetricDefinitionInput
      | WidgetCreateOrConnectWithoutMetricDefinitionInput[];
    createMany?: WidgetCreateManyMetricDefinitionInputEnvelope;
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type MetricValueUpdateManyWithoutMetricDefinitionNestedInput = {
    create?:
      | XOR<
          MetricValueCreateWithoutMetricDefinitionInput,
          MetricValueUncheckedCreateWithoutMetricDefinitionInput
        >
      | MetricValueCreateWithoutMetricDefinitionInput[]
      | MetricValueUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutMetricDefinitionInput
      | MetricValueCreateOrConnectWithoutMetricDefinitionInput[];
    upsert?:
      | MetricValueUpsertWithWhereUniqueWithoutMetricDefinitionInput
      | MetricValueUpsertWithWhereUniqueWithoutMetricDefinitionInput[];
    createMany?: MetricValueCreateManyMetricDefinitionInputEnvelope;
    set?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    disconnect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    delete?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    update?:
      | MetricValueUpdateWithWhereUniqueWithoutMetricDefinitionInput
      | MetricValueUpdateWithWhereUniqueWithoutMetricDefinitionInput[];
    updateMany?:
      | MetricValueUpdateManyWithWhereWithoutMetricDefinitionInput
      | MetricValueUpdateManyWithWhereWithoutMetricDefinitionInput[];
    deleteMany?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
  };

  export type ColumnMappingUpdateManyWithoutMetricDefinitionNestedInput = {
    create?:
      | XOR<
          ColumnMappingCreateWithoutMetricDefinitionInput,
          ColumnMappingUncheckedCreateWithoutMetricDefinitionInput
        >
      | ColumnMappingCreateWithoutMetricDefinitionInput[]
      | ColumnMappingUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | ColumnMappingCreateOrConnectWithoutMetricDefinitionInput
      | ColumnMappingCreateOrConnectWithoutMetricDefinitionInput[];
    upsert?:
      | ColumnMappingUpsertWithWhereUniqueWithoutMetricDefinitionInput
      | ColumnMappingUpsertWithWhereUniqueWithoutMetricDefinitionInput[];
    createMany?: ColumnMappingCreateManyMetricDefinitionInputEnvelope;
    set?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    disconnect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    delete?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    connect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    update?:
      | ColumnMappingUpdateWithWhereUniqueWithoutMetricDefinitionInput
      | ColumnMappingUpdateWithWhereUniqueWithoutMetricDefinitionInput[];
    updateMany?:
      | ColumnMappingUpdateManyWithWhereWithoutMetricDefinitionInput
      | ColumnMappingUpdateManyWithWhereWithoutMetricDefinitionInput[];
    deleteMany?: ColumnMappingScalarWhereInput | ColumnMappingScalarWhereInput[];
  };

  export type GoalUpdateManyWithoutMetricDefinitionNestedInput = {
    create?:
      | XOR<GoalCreateWithoutMetricDefinitionInput, GoalUncheckedCreateWithoutMetricDefinitionInput>
      | GoalCreateWithoutMetricDefinitionInput[]
      | GoalUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutMetricDefinitionInput
      | GoalCreateOrConnectWithoutMetricDefinitionInput[];
    upsert?:
      | GoalUpsertWithWhereUniqueWithoutMetricDefinitionInput
      | GoalUpsertWithWhereUniqueWithoutMetricDefinitionInput[];
    createMany?: GoalCreateManyMetricDefinitionInputEnvelope;
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    update?:
      | GoalUpdateWithWhereUniqueWithoutMetricDefinitionInput
      | GoalUpdateWithWhereUniqueWithoutMetricDefinitionInput[];
    updateMany?:
      | GoalUpdateManyWithWhereWithoutMetricDefinitionInput
      | GoalUpdateManyWithWhereWithoutMetricDefinitionInput[];
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[];
  };

  export type WidgetUpdateManyWithoutMetricDefinitionNestedInput = {
    create?:
      | XOR<
          WidgetCreateWithoutMetricDefinitionInput,
          WidgetUncheckedCreateWithoutMetricDefinitionInput
        >
      | WidgetCreateWithoutMetricDefinitionInput[]
      | WidgetUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | WidgetCreateOrConnectWithoutMetricDefinitionInput
      | WidgetCreateOrConnectWithoutMetricDefinitionInput[];
    upsert?:
      | WidgetUpsertWithWhereUniqueWithoutMetricDefinitionInput
      | WidgetUpsertWithWhereUniqueWithoutMetricDefinitionInput[];
    createMany?: WidgetCreateManyMetricDefinitionInputEnvelope;
    set?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    disconnect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    delete?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    update?:
      | WidgetUpdateWithWhereUniqueWithoutMetricDefinitionInput
      | WidgetUpdateWithWhereUniqueWithoutMetricDefinitionInput[];
    updateMany?:
      | WidgetUpdateManyWithWhereWithoutMetricDefinitionInput
      | WidgetUpdateManyWithWhereWithoutMetricDefinitionInput[];
    deleteMany?: WidgetScalarWhereInput | WidgetScalarWhereInput[];
  };

  export type MetricValueUncheckedUpdateManyWithoutMetricDefinitionNestedInput = {
    create?:
      | XOR<
          MetricValueCreateWithoutMetricDefinitionInput,
          MetricValueUncheckedCreateWithoutMetricDefinitionInput
        >
      | MetricValueCreateWithoutMetricDefinitionInput[]
      | MetricValueUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutMetricDefinitionInput
      | MetricValueCreateOrConnectWithoutMetricDefinitionInput[];
    upsert?:
      | MetricValueUpsertWithWhereUniqueWithoutMetricDefinitionInput
      | MetricValueUpsertWithWhereUniqueWithoutMetricDefinitionInput[];
    createMany?: MetricValueCreateManyMetricDefinitionInputEnvelope;
    set?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    disconnect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    delete?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    update?:
      | MetricValueUpdateWithWhereUniqueWithoutMetricDefinitionInput
      | MetricValueUpdateWithWhereUniqueWithoutMetricDefinitionInput[];
    updateMany?:
      | MetricValueUpdateManyWithWhereWithoutMetricDefinitionInput
      | MetricValueUpdateManyWithWhereWithoutMetricDefinitionInput[];
    deleteMany?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
  };

  export type ColumnMappingUncheckedUpdateManyWithoutMetricDefinitionNestedInput = {
    create?:
      | XOR<
          ColumnMappingCreateWithoutMetricDefinitionInput,
          ColumnMappingUncheckedCreateWithoutMetricDefinitionInput
        >
      | ColumnMappingCreateWithoutMetricDefinitionInput[]
      | ColumnMappingUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | ColumnMappingCreateOrConnectWithoutMetricDefinitionInput
      | ColumnMappingCreateOrConnectWithoutMetricDefinitionInput[];
    upsert?:
      | ColumnMappingUpsertWithWhereUniqueWithoutMetricDefinitionInput
      | ColumnMappingUpsertWithWhereUniqueWithoutMetricDefinitionInput[];
    createMany?: ColumnMappingCreateManyMetricDefinitionInputEnvelope;
    set?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    disconnect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    delete?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    connect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    update?:
      | ColumnMappingUpdateWithWhereUniqueWithoutMetricDefinitionInput
      | ColumnMappingUpdateWithWhereUniqueWithoutMetricDefinitionInput[];
    updateMany?:
      | ColumnMappingUpdateManyWithWhereWithoutMetricDefinitionInput
      | ColumnMappingUpdateManyWithWhereWithoutMetricDefinitionInput[];
    deleteMany?: ColumnMappingScalarWhereInput | ColumnMappingScalarWhereInput[];
  };

  export type GoalUncheckedUpdateManyWithoutMetricDefinitionNestedInput = {
    create?:
      | XOR<GoalCreateWithoutMetricDefinitionInput, GoalUncheckedCreateWithoutMetricDefinitionInput>
      | GoalCreateWithoutMetricDefinitionInput[]
      | GoalUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | GoalCreateOrConnectWithoutMetricDefinitionInput
      | GoalCreateOrConnectWithoutMetricDefinitionInput[];
    upsert?:
      | GoalUpsertWithWhereUniqueWithoutMetricDefinitionInput
      | GoalUpsertWithWhereUniqueWithoutMetricDefinitionInput[];
    createMany?: GoalCreateManyMetricDefinitionInputEnvelope;
    set?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    disconnect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    delete?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    connect?: GoalWhereUniqueInput | GoalWhereUniqueInput[];
    update?:
      | GoalUpdateWithWhereUniqueWithoutMetricDefinitionInput
      | GoalUpdateWithWhereUniqueWithoutMetricDefinitionInput[];
    updateMany?:
      | GoalUpdateManyWithWhereWithoutMetricDefinitionInput
      | GoalUpdateManyWithWhereWithoutMetricDefinitionInput[];
    deleteMany?: GoalScalarWhereInput | GoalScalarWhereInput[];
  };

  export type WidgetUncheckedUpdateManyWithoutMetricDefinitionNestedInput = {
    create?:
      | XOR<
          WidgetCreateWithoutMetricDefinitionInput,
          WidgetUncheckedCreateWithoutMetricDefinitionInput
        >
      | WidgetCreateWithoutMetricDefinitionInput[]
      | WidgetUncheckedCreateWithoutMetricDefinitionInput[];
    connectOrCreate?:
      | WidgetCreateOrConnectWithoutMetricDefinitionInput
      | WidgetCreateOrConnectWithoutMetricDefinitionInput[];
    upsert?:
      | WidgetUpsertWithWhereUniqueWithoutMetricDefinitionInput
      | WidgetUpsertWithWhereUniqueWithoutMetricDefinitionInput[];
    createMany?: WidgetCreateManyMetricDefinitionInputEnvelope;
    set?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    disconnect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    delete?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    update?:
      | WidgetUpdateWithWhereUniqueWithoutMetricDefinitionInput
      | WidgetUpdateWithWhereUniqueWithoutMetricDefinitionInput[];
    updateMany?:
      | WidgetUpdateManyWithWhereWithoutMetricDefinitionInput
      | WidgetUpdateManyWithWhereWithoutMetricDefinitionInput[];
    deleteMany?: WidgetScalarWhereInput | WidgetScalarWhereInput[];
  };

  export type ColumnMappingCreateNestedManyWithoutDataSourceInput = {
    create?:
      | XOR<
          ColumnMappingCreateWithoutDataSourceInput,
          ColumnMappingUncheckedCreateWithoutDataSourceInput
        >
      | ColumnMappingCreateWithoutDataSourceInput[]
      | ColumnMappingUncheckedCreateWithoutDataSourceInput[];
    connectOrCreate?:
      | ColumnMappingCreateOrConnectWithoutDataSourceInput
      | ColumnMappingCreateOrConnectWithoutDataSourceInput[];
    createMany?: ColumnMappingCreateManyDataSourceInputEnvelope;
    connect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
  };

  export type MetricValueCreateNestedManyWithoutDataSourceInput = {
    create?:
      | XOR<
          MetricValueCreateWithoutDataSourceInput,
          MetricValueUncheckedCreateWithoutDataSourceInput
        >
      | MetricValueCreateWithoutDataSourceInput[]
      | MetricValueUncheckedCreateWithoutDataSourceInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutDataSourceInput
      | MetricValueCreateOrConnectWithoutDataSourceInput[];
    createMany?: MetricValueCreateManyDataSourceInputEnvelope;
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
  };

  export type ColumnMappingUncheckedCreateNestedManyWithoutDataSourceInput = {
    create?:
      | XOR<
          ColumnMappingCreateWithoutDataSourceInput,
          ColumnMappingUncheckedCreateWithoutDataSourceInput
        >
      | ColumnMappingCreateWithoutDataSourceInput[]
      | ColumnMappingUncheckedCreateWithoutDataSourceInput[];
    connectOrCreate?:
      | ColumnMappingCreateOrConnectWithoutDataSourceInput
      | ColumnMappingCreateOrConnectWithoutDataSourceInput[];
    createMany?: ColumnMappingCreateManyDataSourceInputEnvelope;
    connect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
  };

  export type MetricValueUncheckedCreateNestedManyWithoutDataSourceInput = {
    create?:
      | XOR<
          MetricValueCreateWithoutDataSourceInput,
          MetricValueUncheckedCreateWithoutDataSourceInput
        >
      | MetricValueCreateWithoutDataSourceInput[]
      | MetricValueUncheckedCreateWithoutDataSourceInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutDataSourceInput
      | MetricValueCreateOrConnectWithoutDataSourceInput[];
    createMany?: MetricValueCreateManyDataSourceInputEnvelope;
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
  };

  export type ColumnMappingUpdateManyWithoutDataSourceNestedInput = {
    create?:
      | XOR<
          ColumnMappingCreateWithoutDataSourceInput,
          ColumnMappingUncheckedCreateWithoutDataSourceInput
        >
      | ColumnMappingCreateWithoutDataSourceInput[]
      | ColumnMappingUncheckedCreateWithoutDataSourceInput[];
    connectOrCreate?:
      | ColumnMappingCreateOrConnectWithoutDataSourceInput
      | ColumnMappingCreateOrConnectWithoutDataSourceInput[];
    upsert?:
      | ColumnMappingUpsertWithWhereUniqueWithoutDataSourceInput
      | ColumnMappingUpsertWithWhereUniqueWithoutDataSourceInput[];
    createMany?: ColumnMappingCreateManyDataSourceInputEnvelope;
    set?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    disconnect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    delete?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    connect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    update?:
      | ColumnMappingUpdateWithWhereUniqueWithoutDataSourceInput
      | ColumnMappingUpdateWithWhereUniqueWithoutDataSourceInput[];
    updateMany?:
      | ColumnMappingUpdateManyWithWhereWithoutDataSourceInput
      | ColumnMappingUpdateManyWithWhereWithoutDataSourceInput[];
    deleteMany?: ColumnMappingScalarWhereInput | ColumnMappingScalarWhereInput[];
  };

  export type MetricValueUpdateManyWithoutDataSourceNestedInput = {
    create?:
      | XOR<
          MetricValueCreateWithoutDataSourceInput,
          MetricValueUncheckedCreateWithoutDataSourceInput
        >
      | MetricValueCreateWithoutDataSourceInput[]
      | MetricValueUncheckedCreateWithoutDataSourceInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutDataSourceInput
      | MetricValueCreateOrConnectWithoutDataSourceInput[];
    upsert?:
      | MetricValueUpsertWithWhereUniqueWithoutDataSourceInput
      | MetricValueUpsertWithWhereUniqueWithoutDataSourceInput[];
    createMany?: MetricValueCreateManyDataSourceInputEnvelope;
    set?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    disconnect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    delete?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    update?:
      | MetricValueUpdateWithWhereUniqueWithoutDataSourceInput
      | MetricValueUpdateWithWhereUniqueWithoutDataSourceInput[];
    updateMany?:
      | MetricValueUpdateManyWithWhereWithoutDataSourceInput
      | MetricValueUpdateManyWithWhereWithoutDataSourceInput[];
    deleteMany?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
  };

  export type ColumnMappingUncheckedUpdateManyWithoutDataSourceNestedInput = {
    create?:
      | XOR<
          ColumnMappingCreateWithoutDataSourceInput,
          ColumnMappingUncheckedCreateWithoutDataSourceInput
        >
      | ColumnMappingCreateWithoutDataSourceInput[]
      | ColumnMappingUncheckedCreateWithoutDataSourceInput[];
    connectOrCreate?:
      | ColumnMappingCreateOrConnectWithoutDataSourceInput
      | ColumnMappingCreateOrConnectWithoutDataSourceInput[];
    upsert?:
      | ColumnMappingUpsertWithWhereUniqueWithoutDataSourceInput
      | ColumnMappingUpsertWithWhereUniqueWithoutDataSourceInput[];
    createMany?: ColumnMappingCreateManyDataSourceInputEnvelope;
    set?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    disconnect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    delete?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    connect?: ColumnMappingWhereUniqueInput | ColumnMappingWhereUniqueInput[];
    update?:
      | ColumnMappingUpdateWithWhereUniqueWithoutDataSourceInput
      | ColumnMappingUpdateWithWhereUniqueWithoutDataSourceInput[];
    updateMany?:
      | ColumnMappingUpdateManyWithWhereWithoutDataSourceInput
      | ColumnMappingUpdateManyWithWhereWithoutDataSourceInput[];
    deleteMany?: ColumnMappingScalarWhereInput | ColumnMappingScalarWhereInput[];
  };

  export type MetricValueUncheckedUpdateManyWithoutDataSourceNestedInput = {
    create?:
      | XOR<
          MetricValueCreateWithoutDataSourceInput,
          MetricValueUncheckedCreateWithoutDataSourceInput
        >
      | MetricValueCreateWithoutDataSourceInput[]
      | MetricValueUncheckedCreateWithoutDataSourceInput[];
    connectOrCreate?:
      | MetricValueCreateOrConnectWithoutDataSourceInput
      | MetricValueCreateOrConnectWithoutDataSourceInput[];
    upsert?:
      | MetricValueUpsertWithWhereUniqueWithoutDataSourceInput
      | MetricValueUpsertWithWhereUniqueWithoutDataSourceInput[];
    createMany?: MetricValueCreateManyDataSourceInputEnvelope;
    set?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    disconnect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    delete?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    connect?: MetricValueWhereUniqueInput | MetricValueWhereUniqueInput[];
    update?:
      | MetricValueUpdateWithWhereUniqueWithoutDataSourceInput
      | MetricValueUpdateWithWhereUniqueWithoutDataSourceInput[];
    updateMany?:
      | MetricValueUpdateManyWithWhereWithoutDataSourceInput
      | MetricValueUpdateManyWithWhereWithoutDataSourceInput[];
    deleteMany?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
  };

  export type DataSourceCreateNestedOneWithoutColumnMappingsInput = {
    create?: XOR<
      DataSourceCreateWithoutColumnMappingsInput,
      DataSourceUncheckedCreateWithoutColumnMappingsInput
    >;
    connectOrCreate?: DataSourceCreateOrConnectWithoutColumnMappingsInput;
    connect?: DataSourceWhereUniqueInput;
  };

  export type MetricDefinitionCreateNestedOneWithoutColumnMappingsInput = {
    create?: XOR<
      MetricDefinitionCreateWithoutColumnMappingsInput,
      MetricDefinitionUncheckedCreateWithoutColumnMappingsInput
    >;
    connectOrCreate?: MetricDefinitionCreateOrConnectWithoutColumnMappingsInput;
    connect?: MetricDefinitionWhereUniqueInput;
  };

  export type DataSourceUpdateOneRequiredWithoutColumnMappingsNestedInput = {
    create?: XOR<
      DataSourceCreateWithoutColumnMappingsInput,
      DataSourceUncheckedCreateWithoutColumnMappingsInput
    >;
    connectOrCreate?: DataSourceCreateOrConnectWithoutColumnMappingsInput;
    upsert?: DataSourceUpsertWithoutColumnMappingsInput;
    connect?: DataSourceWhereUniqueInput;
    update?: XOR<
      XOR<
        DataSourceUpdateToOneWithWhereWithoutColumnMappingsInput,
        DataSourceUpdateWithoutColumnMappingsInput
      >,
      DataSourceUncheckedUpdateWithoutColumnMappingsInput
    >;
  };

  export type MetricDefinitionUpdateOneRequiredWithoutColumnMappingsNestedInput = {
    create?: XOR<
      MetricDefinitionCreateWithoutColumnMappingsInput,
      MetricDefinitionUncheckedCreateWithoutColumnMappingsInput
    >;
    connectOrCreate?: MetricDefinitionCreateOrConnectWithoutColumnMappingsInput;
    upsert?: MetricDefinitionUpsertWithoutColumnMappingsInput;
    connect?: MetricDefinitionWhereUniqueInput;
    update?: XOR<
      XOR<
        MetricDefinitionUpdateToOneWithWhereWithoutColumnMappingsInput,
        MetricDefinitionUpdateWithoutColumnMappingsInput
      >,
      MetricDefinitionUncheckedUpdateWithoutColumnMappingsInput
    >;
  };

  export type MetricDefinitionCreateNestedOneWithoutMetricsInput = {
    create?: XOR<
      MetricDefinitionCreateWithoutMetricsInput,
      MetricDefinitionUncheckedCreateWithoutMetricsInput
    >;
    connectOrCreate?: MetricDefinitionCreateOrConnectWithoutMetricsInput;
    connect?: MetricDefinitionWhereUniqueInput;
  };

  export type ClinicCreateNestedOneWithoutMetricsInput = {
    create?: XOR<ClinicCreateWithoutMetricsInput, ClinicUncheckedCreateWithoutMetricsInput>;
    connectOrCreate?: ClinicCreateOrConnectWithoutMetricsInput;
    connect?: ClinicWhereUniqueInput;
  };

  export type ProviderCreateNestedOneWithoutMetricsInput = {
    create?: XOR<ProviderCreateWithoutMetricsInput, ProviderUncheckedCreateWithoutMetricsInput>;
    connectOrCreate?: ProviderCreateOrConnectWithoutMetricsInput;
    connect?: ProviderWhereUniqueInput;
  };

  export type DataSourceCreateNestedOneWithoutMetricsInput = {
    create?: XOR<DataSourceCreateWithoutMetricsInput, DataSourceUncheckedCreateWithoutMetricsInput>;
    connectOrCreate?: DataSourceCreateOrConnectWithoutMetricsInput;
    connect?: DataSourceWhereUniqueInput;
  };

  export type MetricDefinitionUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<
      MetricDefinitionCreateWithoutMetricsInput,
      MetricDefinitionUncheckedCreateWithoutMetricsInput
    >;
    connectOrCreate?: MetricDefinitionCreateOrConnectWithoutMetricsInput;
    upsert?: MetricDefinitionUpsertWithoutMetricsInput;
    connect?: MetricDefinitionWhereUniqueInput;
    update?: XOR<
      XOR<
        MetricDefinitionUpdateToOneWithWhereWithoutMetricsInput,
        MetricDefinitionUpdateWithoutMetricsInput
      >,
      MetricDefinitionUncheckedUpdateWithoutMetricsInput
    >;
  };

  export type ClinicUpdateOneWithoutMetricsNestedInput = {
    create?: XOR<ClinicCreateWithoutMetricsInput, ClinicUncheckedCreateWithoutMetricsInput>;
    connectOrCreate?: ClinicCreateOrConnectWithoutMetricsInput;
    upsert?: ClinicUpsertWithoutMetricsInput;
    disconnect?: ClinicWhereInput | boolean;
    delete?: ClinicWhereInput | boolean;
    connect?: ClinicWhereUniqueInput;
    update?: XOR<
      XOR<ClinicUpdateToOneWithWhereWithoutMetricsInput, ClinicUpdateWithoutMetricsInput>,
      ClinicUncheckedUpdateWithoutMetricsInput
    >;
  };

  export type ProviderUpdateOneWithoutMetricsNestedInput = {
    create?: XOR<ProviderCreateWithoutMetricsInput, ProviderUncheckedCreateWithoutMetricsInput>;
    connectOrCreate?: ProviderCreateOrConnectWithoutMetricsInput;
    upsert?: ProviderUpsertWithoutMetricsInput;
    disconnect?: ProviderWhereInput | boolean;
    delete?: ProviderWhereInput | boolean;
    connect?: ProviderWhereUniqueInput;
    update?: XOR<
      XOR<ProviderUpdateToOneWithWhereWithoutMetricsInput, ProviderUpdateWithoutMetricsInput>,
      ProviderUncheckedUpdateWithoutMetricsInput
    >;
  };

  export type DataSourceUpdateOneWithoutMetricsNestedInput = {
    create?: XOR<DataSourceCreateWithoutMetricsInput, DataSourceUncheckedCreateWithoutMetricsInput>;
    connectOrCreate?: DataSourceCreateOrConnectWithoutMetricsInput;
    upsert?: DataSourceUpsertWithoutMetricsInput;
    disconnect?: DataSourceWhereInput | boolean;
    delete?: DataSourceWhereInput | boolean;
    connect?: DataSourceWhereUniqueInput;
    update?: XOR<
      XOR<DataSourceUpdateToOneWithWhereWithoutMetricsInput, DataSourceUpdateWithoutMetricsInput>,
      DataSourceUncheckedUpdateWithoutMetricsInput
    >;
  };

  export type MetricDefinitionCreateNestedOneWithoutGoalsInput = {
    create?: XOR<
      MetricDefinitionCreateWithoutGoalsInput,
      MetricDefinitionUncheckedCreateWithoutGoalsInput
    >;
    connectOrCreate?: MetricDefinitionCreateOrConnectWithoutGoalsInput;
    connect?: MetricDefinitionWhereUniqueInput;
  };

  export type ClinicCreateNestedOneWithoutGoalsInput = {
    create?: XOR<ClinicCreateWithoutGoalsInput, ClinicUncheckedCreateWithoutGoalsInput>;
    connectOrCreate?: ClinicCreateOrConnectWithoutGoalsInput;
    connect?: ClinicWhereUniqueInput;
  };

  export type ProviderCreateNestedOneWithoutGoalsInput = {
    create?: XOR<ProviderCreateWithoutGoalsInput, ProviderUncheckedCreateWithoutGoalsInput>;
    connectOrCreate?: ProviderCreateOrConnectWithoutGoalsInput;
    connect?: ProviderWhereUniqueInput;
  };

  export type MetricDefinitionUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<
      MetricDefinitionCreateWithoutGoalsInput,
      MetricDefinitionUncheckedCreateWithoutGoalsInput
    >;
    connectOrCreate?: MetricDefinitionCreateOrConnectWithoutGoalsInput;
    upsert?: MetricDefinitionUpsertWithoutGoalsInput;
    connect?: MetricDefinitionWhereUniqueInput;
    update?: XOR<
      XOR<
        MetricDefinitionUpdateToOneWithWhereWithoutGoalsInput,
        MetricDefinitionUpdateWithoutGoalsInput
      >,
      MetricDefinitionUncheckedUpdateWithoutGoalsInput
    >;
  };

  export type ClinicUpdateOneWithoutGoalsNestedInput = {
    create?: XOR<ClinicCreateWithoutGoalsInput, ClinicUncheckedCreateWithoutGoalsInput>;
    connectOrCreate?: ClinicCreateOrConnectWithoutGoalsInput;
    upsert?: ClinicUpsertWithoutGoalsInput;
    disconnect?: ClinicWhereInput | boolean;
    delete?: ClinicWhereInput | boolean;
    connect?: ClinicWhereUniqueInput;
    update?: XOR<
      XOR<ClinicUpdateToOneWithWhereWithoutGoalsInput, ClinicUpdateWithoutGoalsInput>,
      ClinicUncheckedUpdateWithoutGoalsInput
    >;
  };

  export type ProviderUpdateOneWithoutGoalsNestedInput = {
    create?: XOR<ProviderCreateWithoutGoalsInput, ProviderUncheckedCreateWithoutGoalsInput>;
    connectOrCreate?: ProviderCreateOrConnectWithoutGoalsInput;
    upsert?: ProviderUpsertWithoutGoalsInput;
    disconnect?: ProviderWhereInput | boolean;
    delete?: ProviderWhereInput | boolean;
    connect?: ProviderWhereUniqueInput;
    update?: XOR<
      XOR<ProviderUpdateToOneWithWhereWithoutGoalsInput, ProviderUpdateWithoutGoalsInput>,
      ProviderUncheckedUpdateWithoutGoalsInput
    >;
  };

  export type UserCreateNestedOneWithoutDashboardsInput = {
    create?: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutDashboardsInput;
    connect?: UserWhereUniqueInput;
  };

  export type WidgetCreateNestedManyWithoutDashboardInput = {
    create?:
      | XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput>
      | WidgetCreateWithoutDashboardInput[]
      | WidgetUncheckedCreateWithoutDashboardInput[];
    connectOrCreate?:
      | WidgetCreateOrConnectWithoutDashboardInput
      | WidgetCreateOrConnectWithoutDashboardInput[];
    createMany?: WidgetCreateManyDashboardInputEnvelope;
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
  };

  export type WidgetUncheckedCreateNestedManyWithoutDashboardInput = {
    create?:
      | XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput>
      | WidgetCreateWithoutDashboardInput[]
      | WidgetUncheckedCreateWithoutDashboardInput[];
    connectOrCreate?:
      | WidgetCreateOrConnectWithoutDashboardInput
      | WidgetCreateOrConnectWithoutDashboardInput[];
    createMany?: WidgetCreateManyDashboardInputEnvelope;
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutDashboardsNestedInput = {
    create?: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutDashboardsInput;
    upsert?: UserUpsertWithoutDashboardsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutDashboardsInput, UserUpdateWithoutDashboardsInput>,
      UserUncheckedUpdateWithoutDashboardsInput
    >;
  };

  export type WidgetUpdateManyWithoutDashboardNestedInput = {
    create?:
      | XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput>
      | WidgetCreateWithoutDashboardInput[]
      | WidgetUncheckedCreateWithoutDashboardInput[];
    connectOrCreate?:
      | WidgetCreateOrConnectWithoutDashboardInput
      | WidgetCreateOrConnectWithoutDashboardInput[];
    upsert?:
      | WidgetUpsertWithWhereUniqueWithoutDashboardInput
      | WidgetUpsertWithWhereUniqueWithoutDashboardInput[];
    createMany?: WidgetCreateManyDashboardInputEnvelope;
    set?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    disconnect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    delete?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    update?:
      | WidgetUpdateWithWhereUniqueWithoutDashboardInput
      | WidgetUpdateWithWhereUniqueWithoutDashboardInput[];
    updateMany?:
      | WidgetUpdateManyWithWhereWithoutDashboardInput
      | WidgetUpdateManyWithWhereWithoutDashboardInput[];
    deleteMany?: WidgetScalarWhereInput | WidgetScalarWhereInput[];
  };

  export type WidgetUncheckedUpdateManyWithoutDashboardNestedInput = {
    create?:
      | XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput>
      | WidgetCreateWithoutDashboardInput[]
      | WidgetUncheckedCreateWithoutDashboardInput[];
    connectOrCreate?:
      | WidgetCreateOrConnectWithoutDashboardInput
      | WidgetCreateOrConnectWithoutDashboardInput[];
    upsert?:
      | WidgetUpsertWithWhereUniqueWithoutDashboardInput
      | WidgetUpsertWithWhereUniqueWithoutDashboardInput[];
    createMany?: WidgetCreateManyDashboardInputEnvelope;
    set?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    disconnect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    delete?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    connect?: WidgetWhereUniqueInput | WidgetWhereUniqueInput[];
    update?:
      | WidgetUpdateWithWhereUniqueWithoutDashboardInput
      | WidgetUpdateWithWhereUniqueWithoutDashboardInput[];
    updateMany?:
      | WidgetUpdateManyWithWhereWithoutDashboardInput
      | WidgetUpdateManyWithWhereWithoutDashboardInput[];
    deleteMany?: WidgetScalarWhereInput | WidgetScalarWhereInput[];
  };

  export type DashboardCreateNestedOneWithoutWidgetsInput = {
    create?: XOR<DashboardCreateWithoutWidgetsInput, DashboardUncheckedCreateWithoutWidgetsInput>;
    connectOrCreate?: DashboardCreateOrConnectWithoutWidgetsInput;
    connect?: DashboardWhereUniqueInput;
  };

  export type MetricDefinitionCreateNestedOneWithoutWidgetsInput = {
    create?: XOR<
      MetricDefinitionCreateWithoutWidgetsInput,
      MetricDefinitionUncheckedCreateWithoutWidgetsInput
    >;
    connectOrCreate?: MetricDefinitionCreateOrConnectWithoutWidgetsInput;
    connect?: MetricDefinitionWhereUniqueInput;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type DashboardUpdateOneRequiredWithoutWidgetsNestedInput = {
    create?: XOR<DashboardCreateWithoutWidgetsInput, DashboardUncheckedCreateWithoutWidgetsInput>;
    connectOrCreate?: DashboardCreateOrConnectWithoutWidgetsInput;
    upsert?: DashboardUpsertWithoutWidgetsInput;
    connect?: DashboardWhereUniqueInput;
    update?: XOR<
      XOR<DashboardUpdateToOneWithWhereWithoutWidgetsInput, DashboardUpdateWithoutWidgetsInput>,
      DashboardUncheckedUpdateWithoutWidgetsInput
    >;
  };

  export type MetricDefinitionUpdateOneWithoutWidgetsNestedInput = {
    create?: XOR<
      MetricDefinitionCreateWithoutWidgetsInput,
      MetricDefinitionUncheckedCreateWithoutWidgetsInput
    >;
    connectOrCreate?: MetricDefinitionCreateOrConnectWithoutWidgetsInput;
    upsert?: MetricDefinitionUpsertWithoutWidgetsInput;
    disconnect?: MetricDefinitionWhereInput | boolean;
    delete?: MetricDefinitionWhereInput | boolean;
    connect?: MetricDefinitionWhereUniqueInput;
    update?: XOR<
      XOR<
        MetricDefinitionUpdateToOneWithWhereWithoutWidgetsInput,
        MetricDefinitionUpdateWithoutWidgetsInput
      >,
      MetricDefinitionUncheckedUpdateWithoutWidgetsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">>;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type UserCreateWithoutClinicInput = {
    id?: string;
    email: string;
    name: string;
    role: string;
    lastLogin?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dashboards?: DashboardCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutClinicInput = {
    id?: string;
    email: string;
    name: string;
    role: string;
    lastLogin?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dashboards?: DashboardUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutClinicInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>;
  };

  export type UserCreateManyClinicInputEnvelope = {
    data: UserCreateManyClinicInput | UserCreateManyClinicInput[];
    skipDuplicates?: boolean;
  };

  export type ProviderCreateWithoutClinicInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueCreateNestedManyWithoutProviderInput;
    goals?: GoalCreateNestedManyWithoutProviderInput;
  };

  export type ProviderUncheckedCreateWithoutClinicInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutProviderInput;
    goals?: GoalUncheckedCreateNestedManyWithoutProviderInput;
  };

  export type ProviderCreateOrConnectWithoutClinicInput = {
    where: ProviderWhereUniqueInput;
    create: XOR<ProviderCreateWithoutClinicInput, ProviderUncheckedCreateWithoutClinicInput>;
  };

  export type ProviderCreateManyClinicInputEnvelope = {
    data: ProviderCreateManyClinicInput | ProviderCreateManyClinicInput[];
    skipDuplicates?: boolean;
  };

  export type MetricValueCreateWithoutClinicInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinition: MetricDefinitionCreateNestedOneWithoutMetricsInput;
    provider?: ProviderCreateNestedOneWithoutMetricsInput;
    dataSource?: DataSourceCreateNestedOneWithoutMetricsInput;
  };

  export type MetricValueUncheckedCreateWithoutClinicInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    providerId?: string | null;
    dataSourceId?: string | null;
  };

  export type MetricValueCreateOrConnectWithoutClinicInput = {
    where: MetricValueWhereUniqueInput;
    create: XOR<MetricValueCreateWithoutClinicInput, MetricValueUncheckedCreateWithoutClinicInput>;
  };

  export type MetricValueCreateManyClinicInputEnvelope = {
    data: MetricValueCreateManyClinicInput | MetricValueCreateManyClinicInput[];
    skipDuplicates?: boolean;
  };

  export type GoalCreateWithoutClinicInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinition: MetricDefinitionCreateNestedOneWithoutGoalsInput;
    provider?: ProviderCreateNestedOneWithoutGoalsInput;
  };

  export type GoalUncheckedCreateWithoutClinicInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    providerId?: string | null;
  };

  export type GoalCreateOrConnectWithoutClinicInput = {
    where: GoalWhereUniqueInput;
    create: XOR<GoalCreateWithoutClinicInput, GoalUncheckedCreateWithoutClinicInput>;
  };

  export type GoalCreateManyClinicInputEnvelope = {
    data: GoalCreateManyClinicInput | GoalCreateManyClinicInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithWhereUniqueWithoutClinicInput = {
    where: UserWhereUniqueInput;
    update: XOR<UserUpdateWithoutClinicInput, UserUncheckedUpdateWithoutClinicInput>;
    create: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>;
  };

  export type UserUpdateWithWhereUniqueWithoutClinicInput = {
    where: UserWhereUniqueInput;
    data: XOR<UserUpdateWithoutClinicInput, UserUncheckedUpdateWithoutClinicInput>;
  };

  export type UserUpdateManyWithWhereWithoutClinicInput = {
    where: UserScalarWhereInput;
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutClinicInput>;
  };

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[];
    OR?: UserScalarWhereInput[];
    NOT?: UserScalarWhereInput | UserScalarWhereInput[];
    id?: StringFilter<"User"> | string;
    email?: StringFilter<"User"> | string;
    name?: StringFilter<"User"> | string;
    role?: StringFilter<"User"> | string;
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null;
    createdAt?: DateTimeFilter<"User"> | Date | string;
    updatedAt?: DateTimeFilter<"User"> | Date | string;
    clinicId?: StringFilter<"User"> | string;
  };

  export type ProviderUpsertWithWhereUniqueWithoutClinicInput = {
    where: ProviderWhereUniqueInput;
    update: XOR<ProviderUpdateWithoutClinicInput, ProviderUncheckedUpdateWithoutClinicInput>;
    create: XOR<ProviderCreateWithoutClinicInput, ProviderUncheckedCreateWithoutClinicInput>;
  };

  export type ProviderUpdateWithWhereUniqueWithoutClinicInput = {
    where: ProviderWhereUniqueInput;
    data: XOR<ProviderUpdateWithoutClinicInput, ProviderUncheckedUpdateWithoutClinicInput>;
  };

  export type ProviderUpdateManyWithWhereWithoutClinicInput = {
    where: ProviderScalarWhereInput;
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyWithoutClinicInput>;
  };

  export type ProviderScalarWhereInput = {
    AND?: ProviderScalarWhereInput | ProviderScalarWhereInput[];
    OR?: ProviderScalarWhereInput[];
    NOT?: ProviderScalarWhereInput | ProviderScalarWhereInput[];
    id?: StringFilter<"Provider"> | string;
    name?: StringFilter<"Provider"> | string;
    providerType?: StringFilter<"Provider"> | string;
    status?: StringFilter<"Provider"> | string;
    createdAt?: DateTimeFilter<"Provider"> | Date | string;
    updatedAt?: DateTimeFilter<"Provider"> | Date | string;
    clinicId?: StringFilter<"Provider"> | string;
  };

  export type MetricValueUpsertWithWhereUniqueWithoutClinicInput = {
    where: MetricValueWhereUniqueInput;
    update: XOR<MetricValueUpdateWithoutClinicInput, MetricValueUncheckedUpdateWithoutClinicInput>;
    create: XOR<MetricValueCreateWithoutClinicInput, MetricValueUncheckedCreateWithoutClinicInput>;
  };

  export type MetricValueUpdateWithWhereUniqueWithoutClinicInput = {
    where: MetricValueWhereUniqueInput;
    data: XOR<MetricValueUpdateWithoutClinicInput, MetricValueUncheckedUpdateWithoutClinicInput>;
  };

  export type MetricValueUpdateManyWithWhereWithoutClinicInput = {
    where: MetricValueScalarWhereInput;
    data: XOR<MetricValueUpdateManyMutationInput, MetricValueUncheckedUpdateManyWithoutClinicInput>;
  };

  export type MetricValueScalarWhereInput = {
    AND?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
    OR?: MetricValueScalarWhereInput[];
    NOT?: MetricValueScalarWhereInput | MetricValueScalarWhereInput[];
    id?: StringFilter<"MetricValue"> | string;
    date?: DateTimeFilter<"MetricValue"> | Date | string;
    value?: StringFilter<"MetricValue"> | string;
    sourceType?: StringFilter<"MetricValue"> | string;
    sourceSheet?: StringNullableFilter<"MetricValue"> | string | null;
    externalId?: StringNullableFilter<"MetricValue"> | string | null;
    createdAt?: DateTimeFilter<"MetricValue"> | Date | string;
    updatedAt?: DateTimeFilter<"MetricValue"> | Date | string;
    metricDefinitionId?: StringFilter<"MetricValue"> | string;
    clinicId?: StringNullableFilter<"MetricValue"> | string | null;
    providerId?: StringNullableFilter<"MetricValue"> | string | null;
    dataSourceId?: StringNullableFilter<"MetricValue"> | string | null;
  };

  export type GoalUpsertWithWhereUniqueWithoutClinicInput = {
    where: GoalWhereUniqueInput;
    update: XOR<GoalUpdateWithoutClinicInput, GoalUncheckedUpdateWithoutClinicInput>;
    create: XOR<GoalCreateWithoutClinicInput, GoalUncheckedCreateWithoutClinicInput>;
  };

  export type GoalUpdateWithWhereUniqueWithoutClinicInput = {
    where: GoalWhereUniqueInput;
    data: XOR<GoalUpdateWithoutClinicInput, GoalUncheckedUpdateWithoutClinicInput>;
  };

  export type GoalUpdateManyWithWhereWithoutClinicInput = {
    where: GoalScalarWhereInput;
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutClinicInput>;
  };

  export type GoalScalarWhereInput = {
    AND?: GoalScalarWhereInput | GoalScalarWhereInput[];
    OR?: GoalScalarWhereInput[];
    NOT?: GoalScalarWhereInput | GoalScalarWhereInput[];
    id?: StringFilter<"Goal"> | string;
    timePeriod?: StringFilter<"Goal"> | string;
    startDate?: DateTimeFilter<"Goal"> | Date | string;
    endDate?: DateTimeFilter<"Goal"> | Date | string;
    targetValue?: StringFilter<"Goal"> | string;
    createdAt?: DateTimeFilter<"Goal"> | Date | string;
    updatedAt?: DateTimeFilter<"Goal"> | Date | string;
    metricDefinitionId?: StringFilter<"Goal"> | string;
    clinicId?: StringNullableFilter<"Goal"> | string | null;
    providerId?: StringNullableFilter<"Goal"> | string | null;
  };

  export type ClinicCreateWithoutUsersInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providers?: ProviderCreateNestedManyWithoutClinicInput;
    metrics?: MetricValueCreateNestedManyWithoutClinicInput;
    goals?: GoalCreateNestedManyWithoutClinicInput;
  };

  export type ClinicUncheckedCreateWithoutUsersInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    providers?: ProviderUncheckedCreateNestedManyWithoutClinicInput;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutClinicInput;
    goals?: GoalUncheckedCreateNestedManyWithoutClinicInput;
  };

  export type ClinicCreateOrConnectWithoutUsersInput = {
    where: ClinicWhereUniqueInput;
    create: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>;
  };

  export type DashboardCreateWithoutUserInput = {
    id?: string;
    name: string;
    isDefault?: boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    widgets?: WidgetCreateNestedManyWithoutDashboardInput;
  };

  export type DashboardUncheckedCreateWithoutUserInput = {
    id?: string;
    name: string;
    isDefault?: boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    widgets?: WidgetUncheckedCreateNestedManyWithoutDashboardInput;
  };

  export type DashboardCreateOrConnectWithoutUserInput = {
    where: DashboardWhereUniqueInput;
    create: XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput>;
  };

  export type DashboardCreateManyUserInputEnvelope = {
    data: DashboardCreateManyUserInput | DashboardCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ClinicUpsertWithoutUsersInput = {
    update: XOR<ClinicUpdateWithoutUsersInput, ClinicUncheckedUpdateWithoutUsersInput>;
    create: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>;
    where?: ClinicWhereInput;
  };

  export type ClinicUpdateToOneWithWhereWithoutUsersInput = {
    where?: ClinicWhereInput;
    data: XOR<ClinicUpdateWithoutUsersInput, ClinicUncheckedUpdateWithoutUsersInput>;
  };

  export type ClinicUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providers?: ProviderUpdateManyWithoutClinicNestedInput;
    metrics?: MetricValueUpdateManyWithoutClinicNestedInput;
    goals?: GoalUpdateManyWithoutClinicNestedInput;
  };

  export type ClinicUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    providers?: ProviderUncheckedUpdateManyWithoutClinicNestedInput;
    metrics?: MetricValueUncheckedUpdateManyWithoutClinicNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutClinicNestedInput;
  };

  export type DashboardUpsertWithWhereUniqueWithoutUserInput = {
    where: DashboardWhereUniqueInput;
    update: XOR<DashboardUpdateWithoutUserInput, DashboardUncheckedUpdateWithoutUserInput>;
    create: XOR<DashboardCreateWithoutUserInput, DashboardUncheckedCreateWithoutUserInput>;
  };

  export type DashboardUpdateWithWhereUniqueWithoutUserInput = {
    where: DashboardWhereUniqueInput;
    data: XOR<DashboardUpdateWithoutUserInput, DashboardUncheckedUpdateWithoutUserInput>;
  };

  export type DashboardUpdateManyWithWhereWithoutUserInput = {
    where: DashboardScalarWhereInput;
    data: XOR<DashboardUpdateManyMutationInput, DashboardUncheckedUpdateManyWithoutUserInput>;
  };

  export type DashboardScalarWhereInput = {
    AND?: DashboardScalarWhereInput | DashboardScalarWhereInput[];
    OR?: DashboardScalarWhereInput[];
    NOT?: DashboardScalarWhereInput | DashboardScalarWhereInput[];
    id?: StringFilter<"Dashboard"> | string;
    name?: StringFilter<"Dashboard"> | string;
    isDefault?: BoolFilter<"Dashboard"> | boolean;
    layoutConfig?: JsonNullableFilter<"Dashboard">;
    createdAt?: DateTimeFilter<"Dashboard"> | Date | string;
    updatedAt?: DateTimeFilter<"Dashboard"> | Date | string;
    userId?: StringFilter<"Dashboard"> | string;
  };

  export type ClinicCreateWithoutProvidersInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserCreateNestedManyWithoutClinicInput;
    metrics?: MetricValueCreateNestedManyWithoutClinicInput;
    goals?: GoalCreateNestedManyWithoutClinicInput;
  };

  export type ClinicUncheckedCreateWithoutProvidersInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserUncheckedCreateNestedManyWithoutClinicInput;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutClinicInput;
    goals?: GoalUncheckedCreateNestedManyWithoutClinicInput;
  };

  export type ClinicCreateOrConnectWithoutProvidersInput = {
    where: ClinicWhereUniqueInput;
    create: XOR<ClinicCreateWithoutProvidersInput, ClinicUncheckedCreateWithoutProvidersInput>;
  };

  export type MetricValueCreateWithoutProviderInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinition: MetricDefinitionCreateNestedOneWithoutMetricsInput;
    clinic?: ClinicCreateNestedOneWithoutMetricsInput;
    dataSource?: DataSourceCreateNestedOneWithoutMetricsInput;
  };

  export type MetricValueUncheckedCreateWithoutProviderInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
    dataSourceId?: string | null;
  };

  export type MetricValueCreateOrConnectWithoutProviderInput = {
    where: MetricValueWhereUniqueInput;
    create: XOR<
      MetricValueCreateWithoutProviderInput,
      MetricValueUncheckedCreateWithoutProviderInput
    >;
  };

  export type MetricValueCreateManyProviderInputEnvelope = {
    data: MetricValueCreateManyProviderInput | MetricValueCreateManyProviderInput[];
    skipDuplicates?: boolean;
  };

  export type GoalCreateWithoutProviderInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinition: MetricDefinitionCreateNestedOneWithoutGoalsInput;
    clinic?: ClinicCreateNestedOneWithoutGoalsInput;
  };

  export type GoalUncheckedCreateWithoutProviderInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
  };

  export type GoalCreateOrConnectWithoutProviderInput = {
    where: GoalWhereUniqueInput;
    create: XOR<GoalCreateWithoutProviderInput, GoalUncheckedCreateWithoutProviderInput>;
  };

  export type GoalCreateManyProviderInputEnvelope = {
    data: GoalCreateManyProviderInput | GoalCreateManyProviderInput[];
    skipDuplicates?: boolean;
  };

  export type ClinicUpsertWithoutProvidersInput = {
    update: XOR<ClinicUpdateWithoutProvidersInput, ClinicUncheckedUpdateWithoutProvidersInput>;
    create: XOR<ClinicCreateWithoutProvidersInput, ClinicUncheckedCreateWithoutProvidersInput>;
    where?: ClinicWhereInput;
  };

  export type ClinicUpdateToOneWithWhereWithoutProvidersInput = {
    where?: ClinicWhereInput;
    data: XOR<ClinicUpdateWithoutProvidersInput, ClinicUncheckedUpdateWithoutProvidersInput>;
  };

  export type ClinicUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUpdateManyWithoutClinicNestedInput;
    metrics?: MetricValueUpdateManyWithoutClinicNestedInput;
    goals?: GoalUpdateManyWithoutClinicNestedInput;
  };

  export type ClinicUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput;
    metrics?: MetricValueUncheckedUpdateManyWithoutClinicNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutClinicNestedInput;
  };

  export type MetricValueUpsertWithWhereUniqueWithoutProviderInput = {
    where: MetricValueWhereUniqueInput;
    update: XOR<
      MetricValueUpdateWithoutProviderInput,
      MetricValueUncheckedUpdateWithoutProviderInput
    >;
    create: XOR<
      MetricValueCreateWithoutProviderInput,
      MetricValueUncheckedCreateWithoutProviderInput
    >;
  };

  export type MetricValueUpdateWithWhereUniqueWithoutProviderInput = {
    where: MetricValueWhereUniqueInput;
    data: XOR<
      MetricValueUpdateWithoutProviderInput,
      MetricValueUncheckedUpdateWithoutProviderInput
    >;
  };

  export type MetricValueUpdateManyWithWhereWithoutProviderInput = {
    where: MetricValueScalarWhereInput;
    data: XOR<
      MetricValueUpdateManyMutationInput,
      MetricValueUncheckedUpdateManyWithoutProviderInput
    >;
  };

  export type GoalUpsertWithWhereUniqueWithoutProviderInput = {
    where: GoalWhereUniqueInput;
    update: XOR<GoalUpdateWithoutProviderInput, GoalUncheckedUpdateWithoutProviderInput>;
    create: XOR<GoalCreateWithoutProviderInput, GoalUncheckedCreateWithoutProviderInput>;
  };

  export type GoalUpdateWithWhereUniqueWithoutProviderInput = {
    where: GoalWhereUniqueInput;
    data: XOR<GoalUpdateWithoutProviderInput, GoalUncheckedUpdateWithoutProviderInput>;
  };

  export type GoalUpdateManyWithWhereWithoutProviderInput = {
    where: GoalScalarWhereInput;
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutProviderInput>;
  };

  export type MetricValueCreateWithoutMetricDefinitionInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinic?: ClinicCreateNestedOneWithoutMetricsInput;
    provider?: ProviderCreateNestedOneWithoutMetricsInput;
    dataSource?: DataSourceCreateNestedOneWithoutMetricsInput;
  };

  export type MetricValueUncheckedCreateWithoutMetricDefinitionInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId?: string | null;
    providerId?: string | null;
    dataSourceId?: string | null;
  };

  export type MetricValueCreateOrConnectWithoutMetricDefinitionInput = {
    where: MetricValueWhereUniqueInput;
    create: XOR<
      MetricValueCreateWithoutMetricDefinitionInput,
      MetricValueUncheckedCreateWithoutMetricDefinitionInput
    >;
  };

  export type MetricValueCreateManyMetricDefinitionInputEnvelope = {
    data: MetricValueCreateManyMetricDefinitionInput | MetricValueCreateManyMetricDefinitionInput[];
    skipDuplicates?: boolean;
  };

  export type ColumnMappingCreateWithoutMetricDefinitionInput = {
    id?: string;
    columnName: string;
    transformationRule?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dataSource: DataSourceCreateNestedOneWithoutColumnMappingsInput;
  };

  export type ColumnMappingUncheckedCreateWithoutMetricDefinitionInput = {
    id?: string;
    columnName: string;
    transformationRule?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dataSourceId: string;
  };

  export type ColumnMappingCreateOrConnectWithoutMetricDefinitionInput = {
    where: ColumnMappingWhereUniqueInput;
    create: XOR<
      ColumnMappingCreateWithoutMetricDefinitionInput,
      ColumnMappingUncheckedCreateWithoutMetricDefinitionInput
    >;
  };

  export type ColumnMappingCreateManyMetricDefinitionInputEnvelope = {
    data:
      | ColumnMappingCreateManyMetricDefinitionInput
      | ColumnMappingCreateManyMetricDefinitionInput[];
    skipDuplicates?: boolean;
  };

  export type GoalCreateWithoutMetricDefinitionInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinic?: ClinicCreateNestedOneWithoutGoalsInput;
    provider?: ProviderCreateNestedOneWithoutGoalsInput;
  };

  export type GoalUncheckedCreateWithoutMetricDefinitionInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId?: string | null;
    providerId?: string | null;
  };

  export type GoalCreateOrConnectWithoutMetricDefinitionInput = {
    where: GoalWhereUniqueInput;
    create: XOR<
      GoalCreateWithoutMetricDefinitionInput,
      GoalUncheckedCreateWithoutMetricDefinitionInput
    >;
  };

  export type GoalCreateManyMetricDefinitionInputEnvelope = {
    data: GoalCreateManyMetricDefinitionInput | GoalCreateManyMetricDefinitionInput[];
    skipDuplicates?: boolean;
  };

  export type WidgetCreateWithoutMetricDefinitionInput = {
    id?: string;
    widgetType: string;
    chartType?: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dashboard: DashboardCreateNestedOneWithoutWidgetsInput;
  };

  export type WidgetUncheckedCreateWithoutMetricDefinitionInput = {
    id?: string;
    widgetType: string;
    chartType?: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dashboardId: string;
  };

  export type WidgetCreateOrConnectWithoutMetricDefinitionInput = {
    where: WidgetWhereUniqueInput;
    create: XOR<
      WidgetCreateWithoutMetricDefinitionInput,
      WidgetUncheckedCreateWithoutMetricDefinitionInput
    >;
  };

  export type WidgetCreateManyMetricDefinitionInputEnvelope = {
    data: WidgetCreateManyMetricDefinitionInput | WidgetCreateManyMetricDefinitionInput[];
    skipDuplicates?: boolean;
  };

  export type MetricValueUpsertWithWhereUniqueWithoutMetricDefinitionInput = {
    where: MetricValueWhereUniqueInput;
    update: XOR<
      MetricValueUpdateWithoutMetricDefinitionInput,
      MetricValueUncheckedUpdateWithoutMetricDefinitionInput
    >;
    create: XOR<
      MetricValueCreateWithoutMetricDefinitionInput,
      MetricValueUncheckedCreateWithoutMetricDefinitionInput
    >;
  };

  export type MetricValueUpdateWithWhereUniqueWithoutMetricDefinitionInput = {
    where: MetricValueWhereUniqueInput;
    data: XOR<
      MetricValueUpdateWithoutMetricDefinitionInput,
      MetricValueUncheckedUpdateWithoutMetricDefinitionInput
    >;
  };

  export type MetricValueUpdateManyWithWhereWithoutMetricDefinitionInput = {
    where: MetricValueScalarWhereInput;
    data: XOR<
      MetricValueUpdateManyMutationInput,
      MetricValueUncheckedUpdateManyWithoutMetricDefinitionInput
    >;
  };

  export type ColumnMappingUpsertWithWhereUniqueWithoutMetricDefinitionInput = {
    where: ColumnMappingWhereUniqueInput;
    update: XOR<
      ColumnMappingUpdateWithoutMetricDefinitionInput,
      ColumnMappingUncheckedUpdateWithoutMetricDefinitionInput
    >;
    create: XOR<
      ColumnMappingCreateWithoutMetricDefinitionInput,
      ColumnMappingUncheckedCreateWithoutMetricDefinitionInput
    >;
  };

  export type ColumnMappingUpdateWithWhereUniqueWithoutMetricDefinitionInput = {
    where: ColumnMappingWhereUniqueInput;
    data: XOR<
      ColumnMappingUpdateWithoutMetricDefinitionInput,
      ColumnMappingUncheckedUpdateWithoutMetricDefinitionInput
    >;
  };

  export type ColumnMappingUpdateManyWithWhereWithoutMetricDefinitionInput = {
    where: ColumnMappingScalarWhereInput;
    data: XOR<
      ColumnMappingUpdateManyMutationInput,
      ColumnMappingUncheckedUpdateManyWithoutMetricDefinitionInput
    >;
  };

  export type ColumnMappingScalarWhereInput = {
    AND?: ColumnMappingScalarWhereInput | ColumnMappingScalarWhereInput[];
    OR?: ColumnMappingScalarWhereInput[];
    NOT?: ColumnMappingScalarWhereInput | ColumnMappingScalarWhereInput[];
    id?: StringFilter<"ColumnMapping"> | string;
    columnName?: StringFilter<"ColumnMapping"> | string;
    transformationRule?: StringNullableFilter<"ColumnMapping"> | string | null;
    createdAt?: DateTimeFilter<"ColumnMapping"> | Date | string;
    updatedAt?: DateTimeFilter<"ColumnMapping"> | Date | string;
    dataSourceId?: StringFilter<"ColumnMapping"> | string;
    metricDefinitionId?: StringFilter<"ColumnMapping"> | string;
  };

  export type GoalUpsertWithWhereUniqueWithoutMetricDefinitionInput = {
    where: GoalWhereUniqueInput;
    update: XOR<
      GoalUpdateWithoutMetricDefinitionInput,
      GoalUncheckedUpdateWithoutMetricDefinitionInput
    >;
    create: XOR<
      GoalCreateWithoutMetricDefinitionInput,
      GoalUncheckedCreateWithoutMetricDefinitionInput
    >;
  };

  export type GoalUpdateWithWhereUniqueWithoutMetricDefinitionInput = {
    where: GoalWhereUniqueInput;
    data: XOR<
      GoalUpdateWithoutMetricDefinitionInput,
      GoalUncheckedUpdateWithoutMetricDefinitionInput
    >;
  };

  export type GoalUpdateManyWithWhereWithoutMetricDefinitionInput = {
    where: GoalScalarWhereInput;
    data: XOR<GoalUpdateManyMutationInput, GoalUncheckedUpdateManyWithoutMetricDefinitionInput>;
  };

  export type WidgetUpsertWithWhereUniqueWithoutMetricDefinitionInput = {
    where: WidgetWhereUniqueInput;
    update: XOR<
      WidgetUpdateWithoutMetricDefinitionInput,
      WidgetUncheckedUpdateWithoutMetricDefinitionInput
    >;
    create: XOR<
      WidgetCreateWithoutMetricDefinitionInput,
      WidgetUncheckedCreateWithoutMetricDefinitionInput
    >;
  };

  export type WidgetUpdateWithWhereUniqueWithoutMetricDefinitionInput = {
    where: WidgetWhereUniqueInput;
    data: XOR<
      WidgetUpdateWithoutMetricDefinitionInput,
      WidgetUncheckedUpdateWithoutMetricDefinitionInput
    >;
  };

  export type WidgetUpdateManyWithWhereWithoutMetricDefinitionInput = {
    where: WidgetScalarWhereInput;
    data: XOR<WidgetUpdateManyMutationInput, WidgetUncheckedUpdateManyWithoutMetricDefinitionInput>;
  };

  export type WidgetScalarWhereInput = {
    AND?: WidgetScalarWhereInput | WidgetScalarWhereInput[];
    OR?: WidgetScalarWhereInput[];
    NOT?: WidgetScalarWhereInput | WidgetScalarWhereInput[];
    id?: StringFilter<"Widget"> | string;
    widgetType?: StringFilter<"Widget"> | string;
    chartType?: StringNullableFilter<"Widget"> | string | null;
    positionX?: IntFilter<"Widget"> | number;
    positionY?: IntFilter<"Widget"> | number;
    width?: IntFilter<"Widget"> | number;
    height?: IntFilter<"Widget"> | number;
    config?: JsonNullableFilter<"Widget">;
    createdAt?: DateTimeFilter<"Widget"> | Date | string;
    updatedAt?: DateTimeFilter<"Widget"> | Date | string;
    dashboardId?: StringFilter<"Widget"> | string;
    metricDefinitionId?: StringNullableFilter<"Widget"> | string | null;
  };

  export type ColumnMappingCreateWithoutDataSourceInput = {
    id?: string;
    columnName: string;
    transformationRule?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinition: MetricDefinitionCreateNestedOneWithoutColumnMappingsInput;
  };

  export type ColumnMappingUncheckedCreateWithoutDataSourceInput = {
    id?: string;
    columnName: string;
    transformationRule?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
  };

  export type ColumnMappingCreateOrConnectWithoutDataSourceInput = {
    where: ColumnMappingWhereUniqueInput;
    create: XOR<
      ColumnMappingCreateWithoutDataSourceInput,
      ColumnMappingUncheckedCreateWithoutDataSourceInput
    >;
  };

  export type ColumnMappingCreateManyDataSourceInputEnvelope = {
    data: ColumnMappingCreateManyDataSourceInput | ColumnMappingCreateManyDataSourceInput[];
    skipDuplicates?: boolean;
  };

  export type MetricValueCreateWithoutDataSourceInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinition: MetricDefinitionCreateNestedOneWithoutMetricsInput;
    clinic?: ClinicCreateNestedOneWithoutMetricsInput;
    provider?: ProviderCreateNestedOneWithoutMetricsInput;
  };

  export type MetricValueUncheckedCreateWithoutDataSourceInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
    providerId?: string | null;
  };

  export type MetricValueCreateOrConnectWithoutDataSourceInput = {
    where: MetricValueWhereUniqueInput;
    create: XOR<
      MetricValueCreateWithoutDataSourceInput,
      MetricValueUncheckedCreateWithoutDataSourceInput
    >;
  };

  export type MetricValueCreateManyDataSourceInputEnvelope = {
    data: MetricValueCreateManyDataSourceInput | MetricValueCreateManyDataSourceInput[];
    skipDuplicates?: boolean;
  };

  export type ColumnMappingUpsertWithWhereUniqueWithoutDataSourceInput = {
    where: ColumnMappingWhereUniqueInput;
    update: XOR<
      ColumnMappingUpdateWithoutDataSourceInput,
      ColumnMappingUncheckedUpdateWithoutDataSourceInput
    >;
    create: XOR<
      ColumnMappingCreateWithoutDataSourceInput,
      ColumnMappingUncheckedCreateWithoutDataSourceInput
    >;
  };

  export type ColumnMappingUpdateWithWhereUniqueWithoutDataSourceInput = {
    where: ColumnMappingWhereUniqueInput;
    data: XOR<
      ColumnMappingUpdateWithoutDataSourceInput,
      ColumnMappingUncheckedUpdateWithoutDataSourceInput
    >;
  };

  export type ColumnMappingUpdateManyWithWhereWithoutDataSourceInput = {
    where: ColumnMappingScalarWhereInput;
    data: XOR<
      ColumnMappingUpdateManyMutationInput,
      ColumnMappingUncheckedUpdateManyWithoutDataSourceInput
    >;
  };

  export type MetricValueUpsertWithWhereUniqueWithoutDataSourceInput = {
    where: MetricValueWhereUniqueInput;
    update: XOR<
      MetricValueUpdateWithoutDataSourceInput,
      MetricValueUncheckedUpdateWithoutDataSourceInput
    >;
    create: XOR<
      MetricValueCreateWithoutDataSourceInput,
      MetricValueUncheckedCreateWithoutDataSourceInput
    >;
  };

  export type MetricValueUpdateWithWhereUniqueWithoutDataSourceInput = {
    where: MetricValueWhereUniqueInput;
    data: XOR<
      MetricValueUpdateWithoutDataSourceInput,
      MetricValueUncheckedUpdateWithoutDataSourceInput
    >;
  };

  export type MetricValueUpdateManyWithWhereWithoutDataSourceInput = {
    where: MetricValueScalarWhereInput;
    data: XOR<
      MetricValueUpdateManyMutationInput,
      MetricValueUncheckedUpdateManyWithoutDataSourceInput
    >;
  };

  export type DataSourceCreateWithoutColumnMappingsInput = {
    id?: string;
    name: string;
    spreadsheetId: string;
    sheetName: string;
    lastSyncedAt?: Date | string | null;
    syncFrequency: string;
    connectionStatus: string;
    appScriptId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueCreateNestedManyWithoutDataSourceInput;
  };

  export type DataSourceUncheckedCreateWithoutColumnMappingsInput = {
    id?: string;
    name: string;
    spreadsheetId: string;
    sheetName: string;
    lastSyncedAt?: Date | string | null;
    syncFrequency: string;
    connectionStatus: string;
    appScriptId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutDataSourceInput;
  };

  export type DataSourceCreateOrConnectWithoutColumnMappingsInput = {
    where: DataSourceWhereUniqueInput;
    create: XOR<
      DataSourceCreateWithoutColumnMappingsInput,
      DataSourceUncheckedCreateWithoutColumnMappingsInput
    >;
  };

  export type MetricDefinitionCreateWithoutColumnMappingsInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueCreateNestedManyWithoutMetricDefinitionInput;
    goals?: GoalCreateNestedManyWithoutMetricDefinitionInput;
    widgets?: WidgetCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionUncheckedCreateWithoutColumnMappingsInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    goals?: GoalUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    widgets?: WidgetUncheckedCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionCreateOrConnectWithoutColumnMappingsInput = {
    where: MetricDefinitionWhereUniqueInput;
    create: XOR<
      MetricDefinitionCreateWithoutColumnMappingsInput,
      MetricDefinitionUncheckedCreateWithoutColumnMappingsInput
    >;
  };

  export type DataSourceUpsertWithoutColumnMappingsInput = {
    update: XOR<
      DataSourceUpdateWithoutColumnMappingsInput,
      DataSourceUncheckedUpdateWithoutColumnMappingsInput
    >;
    create: XOR<
      DataSourceCreateWithoutColumnMappingsInput,
      DataSourceUncheckedCreateWithoutColumnMappingsInput
    >;
    where?: DataSourceWhereInput;
  };

  export type DataSourceUpdateToOneWithWhereWithoutColumnMappingsInput = {
    where?: DataSourceWhereInput;
    data: XOR<
      DataSourceUpdateWithoutColumnMappingsInput,
      DataSourceUncheckedUpdateWithoutColumnMappingsInput
    >;
  };

  export type DataSourceUpdateWithoutColumnMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    spreadsheetId?: StringFieldUpdateOperationsInput | string;
    sheetName?: StringFieldUpdateOperationsInput | string;
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    syncFrequency?: StringFieldUpdateOperationsInput | string;
    connectionStatus?: StringFieldUpdateOperationsInput | string;
    appScriptId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUpdateManyWithoutDataSourceNestedInput;
  };

  export type DataSourceUncheckedUpdateWithoutColumnMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    spreadsheetId?: StringFieldUpdateOperationsInput | string;
    sheetName?: StringFieldUpdateOperationsInput | string;
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    syncFrequency?: StringFieldUpdateOperationsInput | string;
    connectionStatus?: StringFieldUpdateOperationsInput | string;
    appScriptId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUncheckedUpdateManyWithoutDataSourceNestedInput;
  };

  export type MetricDefinitionUpsertWithoutColumnMappingsInput = {
    update: XOR<
      MetricDefinitionUpdateWithoutColumnMappingsInput,
      MetricDefinitionUncheckedUpdateWithoutColumnMappingsInput
    >;
    create: XOR<
      MetricDefinitionCreateWithoutColumnMappingsInput,
      MetricDefinitionUncheckedCreateWithoutColumnMappingsInput
    >;
    where?: MetricDefinitionWhereInput;
  };

  export type MetricDefinitionUpdateToOneWithWhereWithoutColumnMappingsInput = {
    where?: MetricDefinitionWhereInput;
    data: XOR<
      MetricDefinitionUpdateWithoutColumnMappingsInput,
      MetricDefinitionUncheckedUpdateWithoutColumnMappingsInput
    >;
  };

  export type MetricDefinitionUpdateWithoutColumnMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUpdateManyWithoutMetricDefinitionNestedInput;
    goals?: GoalUpdateManyWithoutMetricDefinitionNestedInput;
    widgets?: WidgetUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type MetricDefinitionUncheckedUpdateWithoutColumnMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    widgets?: WidgetUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type MetricDefinitionCreateWithoutMetricsInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    columnMappings?: ColumnMappingCreateNestedManyWithoutMetricDefinitionInput;
    goals?: GoalCreateNestedManyWithoutMetricDefinitionInput;
    widgets?: WidgetCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionUncheckedCreateWithoutMetricsInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    columnMappings?: ColumnMappingUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    goals?: GoalUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    widgets?: WidgetUncheckedCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionCreateOrConnectWithoutMetricsInput = {
    where: MetricDefinitionWhereUniqueInput;
    create: XOR<
      MetricDefinitionCreateWithoutMetricsInput,
      MetricDefinitionUncheckedCreateWithoutMetricsInput
    >;
  };

  export type ClinicCreateWithoutMetricsInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserCreateNestedManyWithoutClinicInput;
    providers?: ProviderCreateNestedManyWithoutClinicInput;
    goals?: GoalCreateNestedManyWithoutClinicInput;
  };

  export type ClinicUncheckedCreateWithoutMetricsInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserUncheckedCreateNestedManyWithoutClinicInput;
    providers?: ProviderUncheckedCreateNestedManyWithoutClinicInput;
    goals?: GoalUncheckedCreateNestedManyWithoutClinicInput;
  };

  export type ClinicCreateOrConnectWithoutMetricsInput = {
    where: ClinicWhereUniqueInput;
    create: XOR<ClinicCreateWithoutMetricsInput, ClinicUncheckedCreateWithoutMetricsInput>;
  };

  export type ProviderCreateWithoutMetricsInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinic: ClinicCreateNestedOneWithoutProvidersInput;
    goals?: GoalCreateNestedManyWithoutProviderInput;
  };

  export type ProviderUncheckedCreateWithoutMetricsInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId: string;
    goals?: GoalUncheckedCreateNestedManyWithoutProviderInput;
  };

  export type ProviderCreateOrConnectWithoutMetricsInput = {
    where: ProviderWhereUniqueInput;
    create: XOR<ProviderCreateWithoutMetricsInput, ProviderUncheckedCreateWithoutMetricsInput>;
  };

  export type DataSourceCreateWithoutMetricsInput = {
    id?: string;
    name: string;
    spreadsheetId: string;
    sheetName: string;
    lastSyncedAt?: Date | string | null;
    syncFrequency: string;
    connectionStatus: string;
    appScriptId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    columnMappings?: ColumnMappingCreateNestedManyWithoutDataSourceInput;
  };

  export type DataSourceUncheckedCreateWithoutMetricsInput = {
    id?: string;
    name: string;
    spreadsheetId: string;
    sheetName: string;
    lastSyncedAt?: Date | string | null;
    syncFrequency: string;
    connectionStatus: string;
    appScriptId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    columnMappings?: ColumnMappingUncheckedCreateNestedManyWithoutDataSourceInput;
  };

  export type DataSourceCreateOrConnectWithoutMetricsInput = {
    where: DataSourceWhereUniqueInput;
    create: XOR<DataSourceCreateWithoutMetricsInput, DataSourceUncheckedCreateWithoutMetricsInput>;
  };

  export type MetricDefinitionUpsertWithoutMetricsInput = {
    update: XOR<
      MetricDefinitionUpdateWithoutMetricsInput,
      MetricDefinitionUncheckedUpdateWithoutMetricsInput
    >;
    create: XOR<
      MetricDefinitionCreateWithoutMetricsInput,
      MetricDefinitionUncheckedCreateWithoutMetricsInput
    >;
    where?: MetricDefinitionWhereInput;
  };

  export type MetricDefinitionUpdateToOneWithWhereWithoutMetricsInput = {
    where?: MetricDefinitionWhereInput;
    data: XOR<
      MetricDefinitionUpdateWithoutMetricsInput,
      MetricDefinitionUncheckedUpdateWithoutMetricsInput
    >;
  };

  export type MetricDefinitionUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    columnMappings?: ColumnMappingUpdateManyWithoutMetricDefinitionNestedInput;
    goals?: GoalUpdateManyWithoutMetricDefinitionNestedInput;
    widgets?: WidgetUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type MetricDefinitionUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    columnMappings?: ColumnMappingUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    widgets?: WidgetUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type ClinicUpsertWithoutMetricsInput = {
    update: XOR<ClinicUpdateWithoutMetricsInput, ClinicUncheckedUpdateWithoutMetricsInput>;
    create: XOR<ClinicCreateWithoutMetricsInput, ClinicUncheckedCreateWithoutMetricsInput>;
    where?: ClinicWhereInput;
  };

  export type ClinicUpdateToOneWithWhereWithoutMetricsInput = {
    where?: ClinicWhereInput;
    data: XOR<ClinicUpdateWithoutMetricsInput, ClinicUncheckedUpdateWithoutMetricsInput>;
  };

  export type ClinicUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUpdateManyWithoutClinicNestedInput;
    providers?: ProviderUpdateManyWithoutClinicNestedInput;
    goals?: GoalUpdateManyWithoutClinicNestedInput;
  };

  export type ClinicUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput;
    providers?: ProviderUncheckedUpdateManyWithoutClinicNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutClinicNestedInput;
  };

  export type ProviderUpsertWithoutMetricsInput = {
    update: XOR<ProviderUpdateWithoutMetricsInput, ProviderUncheckedUpdateWithoutMetricsInput>;
    create: XOR<ProviderCreateWithoutMetricsInput, ProviderUncheckedCreateWithoutMetricsInput>;
    where?: ProviderWhereInput;
  };

  export type ProviderUpdateToOneWithWhereWithoutMetricsInput = {
    where?: ProviderWhereInput;
    data: XOR<ProviderUpdateWithoutMetricsInput, ProviderUncheckedUpdateWithoutMetricsInput>;
  };

  export type ProviderUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinic?: ClinicUpdateOneRequiredWithoutProvidersNestedInput;
    goals?: GoalUpdateManyWithoutProviderNestedInput;
  };

  export type ProviderUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: StringFieldUpdateOperationsInput | string;
    goals?: GoalUncheckedUpdateManyWithoutProviderNestedInput;
  };

  export type DataSourceUpsertWithoutMetricsInput = {
    update: XOR<DataSourceUpdateWithoutMetricsInput, DataSourceUncheckedUpdateWithoutMetricsInput>;
    create: XOR<DataSourceCreateWithoutMetricsInput, DataSourceUncheckedCreateWithoutMetricsInput>;
    where?: DataSourceWhereInput;
  };

  export type DataSourceUpdateToOneWithWhereWithoutMetricsInput = {
    where?: DataSourceWhereInput;
    data: XOR<DataSourceUpdateWithoutMetricsInput, DataSourceUncheckedUpdateWithoutMetricsInput>;
  };

  export type DataSourceUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    spreadsheetId?: StringFieldUpdateOperationsInput | string;
    sheetName?: StringFieldUpdateOperationsInput | string;
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    syncFrequency?: StringFieldUpdateOperationsInput | string;
    connectionStatus?: StringFieldUpdateOperationsInput | string;
    appScriptId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    columnMappings?: ColumnMappingUpdateManyWithoutDataSourceNestedInput;
  };

  export type DataSourceUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    spreadsheetId?: StringFieldUpdateOperationsInput | string;
    sheetName?: StringFieldUpdateOperationsInput | string;
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    syncFrequency?: StringFieldUpdateOperationsInput | string;
    connectionStatus?: StringFieldUpdateOperationsInput | string;
    appScriptId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    columnMappings?: ColumnMappingUncheckedUpdateManyWithoutDataSourceNestedInput;
  };

  export type MetricDefinitionCreateWithoutGoalsInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueCreateNestedManyWithoutMetricDefinitionInput;
    columnMappings?: ColumnMappingCreateNestedManyWithoutMetricDefinitionInput;
    widgets?: WidgetCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionUncheckedCreateWithoutGoalsInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    columnMappings?: ColumnMappingUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    widgets?: WidgetUncheckedCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionCreateOrConnectWithoutGoalsInput = {
    where: MetricDefinitionWhereUniqueInput;
    create: XOR<
      MetricDefinitionCreateWithoutGoalsInput,
      MetricDefinitionUncheckedCreateWithoutGoalsInput
    >;
  };

  export type ClinicCreateWithoutGoalsInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserCreateNestedManyWithoutClinicInput;
    providers?: ProviderCreateNestedManyWithoutClinicInput;
    metrics?: MetricValueCreateNestedManyWithoutClinicInput;
  };

  export type ClinicUncheckedCreateWithoutGoalsInput = {
    id?: string;
    name: string;
    location: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserUncheckedCreateNestedManyWithoutClinicInput;
    providers?: ProviderUncheckedCreateNestedManyWithoutClinicInput;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutClinicInput;
  };

  export type ClinicCreateOrConnectWithoutGoalsInput = {
    where: ClinicWhereUniqueInput;
    create: XOR<ClinicCreateWithoutGoalsInput, ClinicUncheckedCreateWithoutGoalsInput>;
  };

  export type ProviderCreateWithoutGoalsInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinic: ClinicCreateNestedOneWithoutProvidersInput;
    metrics?: MetricValueCreateNestedManyWithoutProviderInput;
  };

  export type ProviderUncheckedCreateWithoutGoalsInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId: string;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutProviderInput;
  };

  export type ProviderCreateOrConnectWithoutGoalsInput = {
    where: ProviderWhereUniqueInput;
    create: XOR<ProviderCreateWithoutGoalsInput, ProviderUncheckedCreateWithoutGoalsInput>;
  };

  export type MetricDefinitionUpsertWithoutGoalsInput = {
    update: XOR<
      MetricDefinitionUpdateWithoutGoalsInput,
      MetricDefinitionUncheckedUpdateWithoutGoalsInput
    >;
    create: XOR<
      MetricDefinitionCreateWithoutGoalsInput,
      MetricDefinitionUncheckedCreateWithoutGoalsInput
    >;
    where?: MetricDefinitionWhereInput;
  };

  export type MetricDefinitionUpdateToOneWithWhereWithoutGoalsInput = {
    where?: MetricDefinitionWhereInput;
    data: XOR<
      MetricDefinitionUpdateWithoutGoalsInput,
      MetricDefinitionUncheckedUpdateWithoutGoalsInput
    >;
  };

  export type MetricDefinitionUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUpdateManyWithoutMetricDefinitionNestedInput;
    columnMappings?: ColumnMappingUpdateManyWithoutMetricDefinitionNestedInput;
    widgets?: WidgetUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type MetricDefinitionUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    columnMappings?: ColumnMappingUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    widgets?: WidgetUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type ClinicUpsertWithoutGoalsInput = {
    update: XOR<ClinicUpdateWithoutGoalsInput, ClinicUncheckedUpdateWithoutGoalsInput>;
    create: XOR<ClinicCreateWithoutGoalsInput, ClinicUncheckedCreateWithoutGoalsInput>;
    where?: ClinicWhereInput;
  };

  export type ClinicUpdateToOneWithWhereWithoutGoalsInput = {
    where?: ClinicWhereInput;
    data: XOR<ClinicUpdateWithoutGoalsInput, ClinicUncheckedUpdateWithoutGoalsInput>;
  };

  export type ClinicUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUpdateManyWithoutClinicNestedInput;
    providers?: ProviderUpdateManyWithoutClinicNestedInput;
    metrics?: MetricValueUpdateManyWithoutClinicNestedInput;
  };

  export type ClinicUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    location?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput;
    providers?: ProviderUncheckedUpdateManyWithoutClinicNestedInput;
    metrics?: MetricValueUncheckedUpdateManyWithoutClinicNestedInput;
  };

  export type ProviderUpsertWithoutGoalsInput = {
    update: XOR<ProviderUpdateWithoutGoalsInput, ProviderUncheckedUpdateWithoutGoalsInput>;
    create: XOR<ProviderCreateWithoutGoalsInput, ProviderUncheckedCreateWithoutGoalsInput>;
    where?: ProviderWhereInput;
  };

  export type ProviderUpdateToOneWithWhereWithoutGoalsInput = {
    where?: ProviderWhereInput;
    data: XOR<ProviderUpdateWithoutGoalsInput, ProviderUncheckedUpdateWithoutGoalsInput>;
  };

  export type ProviderUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinic?: ClinicUpdateOneRequiredWithoutProvidersNestedInput;
    metrics?: MetricValueUpdateManyWithoutProviderNestedInput;
  };

  export type ProviderUncheckedUpdateWithoutGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: StringFieldUpdateOperationsInput | string;
    metrics?: MetricValueUncheckedUpdateManyWithoutProviderNestedInput;
  };

  export type UserCreateWithoutDashboardsInput = {
    id?: string;
    email: string;
    name: string;
    role: string;
    lastLogin?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinic: ClinicCreateNestedOneWithoutUsersInput;
  };

  export type UserUncheckedCreateWithoutDashboardsInput = {
    id?: string;
    email: string;
    name: string;
    role: string;
    lastLogin?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId: string;
  };

  export type UserCreateOrConnectWithoutDashboardsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>;
  };

  export type WidgetCreateWithoutDashboardInput = {
    id?: string;
    widgetType: string;
    chartType?: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinition?: MetricDefinitionCreateNestedOneWithoutWidgetsInput;
  };

  export type WidgetUncheckedCreateWithoutDashboardInput = {
    id?: string;
    widgetType: string;
    chartType?: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId?: string | null;
  };

  export type WidgetCreateOrConnectWithoutDashboardInput = {
    where: WidgetWhereUniqueInput;
    create: XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput>;
  };

  export type WidgetCreateManyDashboardInputEnvelope = {
    data: WidgetCreateManyDashboardInput | WidgetCreateManyDashboardInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutDashboardsInput = {
    update: XOR<UserUpdateWithoutDashboardsInput, UserUncheckedUpdateWithoutDashboardsInput>;
    create: XOR<UserCreateWithoutDashboardsInput, UserUncheckedCreateWithoutDashboardsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutDashboardsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutDashboardsInput, UserUncheckedUpdateWithoutDashboardsInput>;
  };

  export type UserUpdateWithoutDashboardsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinic?: ClinicUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type UserUncheckedUpdateWithoutDashboardsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: StringFieldUpdateOperationsInput | string;
  };

  export type WidgetUpsertWithWhereUniqueWithoutDashboardInput = {
    where: WidgetWhereUniqueInput;
    update: XOR<WidgetUpdateWithoutDashboardInput, WidgetUncheckedUpdateWithoutDashboardInput>;
    create: XOR<WidgetCreateWithoutDashboardInput, WidgetUncheckedCreateWithoutDashboardInput>;
  };

  export type WidgetUpdateWithWhereUniqueWithoutDashboardInput = {
    where: WidgetWhereUniqueInput;
    data: XOR<WidgetUpdateWithoutDashboardInput, WidgetUncheckedUpdateWithoutDashboardInput>;
  };

  export type WidgetUpdateManyWithWhereWithoutDashboardInput = {
    where: WidgetScalarWhereInput;
    data: XOR<WidgetUpdateManyMutationInput, WidgetUncheckedUpdateManyWithoutDashboardInput>;
  };

  export type DashboardCreateWithoutWidgetsInput = {
    id?: string;
    name: string;
    isDefault?: boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutDashboardsInput;
  };

  export type DashboardUncheckedCreateWithoutWidgetsInput = {
    id?: string;
    name: string;
    isDefault?: boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    userId: string;
  };

  export type DashboardCreateOrConnectWithoutWidgetsInput = {
    where: DashboardWhereUniqueInput;
    create: XOR<DashboardCreateWithoutWidgetsInput, DashboardUncheckedCreateWithoutWidgetsInput>;
  };

  export type MetricDefinitionCreateWithoutWidgetsInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueCreateNestedManyWithoutMetricDefinitionInput;
    columnMappings?: ColumnMappingCreateNestedManyWithoutMetricDefinitionInput;
    goals?: GoalCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionUncheckedCreateWithoutWidgetsInput = {
    id?: string;
    name: string;
    description: string;
    dataType: string;
    calculationFormula?: string | null;
    category: string;
    isComposite: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metrics?: MetricValueUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    columnMappings?: ColumnMappingUncheckedCreateNestedManyWithoutMetricDefinitionInput;
    goals?: GoalUncheckedCreateNestedManyWithoutMetricDefinitionInput;
  };

  export type MetricDefinitionCreateOrConnectWithoutWidgetsInput = {
    where: MetricDefinitionWhereUniqueInput;
    create: XOR<
      MetricDefinitionCreateWithoutWidgetsInput,
      MetricDefinitionUncheckedCreateWithoutWidgetsInput
    >;
  };

  export type DashboardUpsertWithoutWidgetsInput = {
    update: XOR<DashboardUpdateWithoutWidgetsInput, DashboardUncheckedUpdateWithoutWidgetsInput>;
    create: XOR<DashboardCreateWithoutWidgetsInput, DashboardUncheckedCreateWithoutWidgetsInput>;
    where?: DashboardWhereInput;
  };

  export type DashboardUpdateToOneWithWhereWithoutWidgetsInput = {
    where?: DashboardWhereInput;
    data: XOR<DashboardUpdateWithoutWidgetsInput, DashboardUncheckedUpdateWithoutWidgetsInput>;
  };

  export type DashboardUpdateWithoutWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutDashboardsNestedInput;
  };

  export type DashboardUncheckedUpdateWithoutWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type MetricDefinitionUpsertWithoutWidgetsInput = {
    update: XOR<
      MetricDefinitionUpdateWithoutWidgetsInput,
      MetricDefinitionUncheckedUpdateWithoutWidgetsInput
    >;
    create: XOR<
      MetricDefinitionCreateWithoutWidgetsInput,
      MetricDefinitionUncheckedCreateWithoutWidgetsInput
    >;
    where?: MetricDefinitionWhereInput;
  };

  export type MetricDefinitionUpdateToOneWithWhereWithoutWidgetsInput = {
    where?: MetricDefinitionWhereInput;
    data: XOR<
      MetricDefinitionUpdateWithoutWidgetsInput,
      MetricDefinitionUncheckedUpdateWithoutWidgetsInput
    >;
  };

  export type MetricDefinitionUpdateWithoutWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUpdateManyWithoutMetricDefinitionNestedInput;
    columnMappings?: ColumnMappingUpdateManyWithoutMetricDefinitionNestedInput;
    goals?: GoalUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type MetricDefinitionUncheckedUpdateWithoutWidgetsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    dataType?: StringFieldUpdateOperationsInput | string;
    calculationFormula?: NullableStringFieldUpdateOperationsInput | string | null;
    category?: StringFieldUpdateOperationsInput | string;
    isComposite?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    columnMappings?: ColumnMappingUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutMetricDefinitionNestedInput;
  };

  export type UserCreateManyClinicInput = {
    id?: string;
    email: string;
    name: string;
    role: string;
    lastLogin?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProviderCreateManyClinicInput = {
    id?: string;
    name: string;
    providerType: string;
    status: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MetricValueCreateManyClinicInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    providerId?: string | null;
    dataSourceId?: string | null;
  };

  export type GoalCreateManyClinicInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    providerId?: string | null;
  };

  export type UserUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dashboards?: DashboardUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dashboards?: DashboardUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    role?: StringFieldUpdateOperationsInput | string;
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProviderUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUpdateManyWithoutProviderNestedInput;
    goals?: GoalUpdateManyWithoutProviderNestedInput;
  };

  export type ProviderUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metrics?: MetricValueUncheckedUpdateManyWithoutProviderNestedInput;
    goals?: GoalUncheckedUpdateManyWithoutProviderNestedInput;
  };

  export type ProviderUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    providerType?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MetricValueUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinition?: MetricDefinitionUpdateOneRequiredWithoutMetricsNestedInput;
    provider?: ProviderUpdateOneWithoutMetricsNestedInput;
    dataSource?: DataSourceUpdateOneWithoutMetricsNestedInput;
  };

  export type MetricValueUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
    dataSourceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type MetricValueUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
    dataSourceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type GoalUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinition?: MetricDefinitionUpdateOneRequiredWithoutGoalsNestedInput;
    provider?: ProviderUpdateOneWithoutGoalsNestedInput;
  };

  export type GoalUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type GoalUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DashboardCreateManyUserInput = {
    id?: string;
    name: string;
    isDefault?: boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DashboardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    widgets?: WidgetUpdateManyWithoutDashboardNestedInput;
  };

  export type DashboardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    widgets?: WidgetUncheckedUpdateManyWithoutDashboardNestedInput;
  };

  export type DashboardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    layoutConfig?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MetricValueCreateManyProviderInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
    dataSourceId?: string | null;
  };

  export type GoalCreateManyProviderInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
  };

  export type MetricValueUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinition?: MetricDefinitionUpdateOneRequiredWithoutMetricsNestedInput;
    clinic?: ClinicUpdateOneWithoutMetricsNestedInput;
    dataSource?: DataSourceUpdateOneWithoutMetricsNestedInput;
  };

  export type MetricValueUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    dataSourceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type MetricValueUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    dataSourceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type GoalUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinition?: MetricDefinitionUpdateOneRequiredWithoutGoalsNestedInput;
    clinic?: ClinicUpdateOneWithoutGoalsNestedInput;
  };

  export type GoalUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type GoalUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type MetricValueCreateManyMetricDefinitionInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId?: string | null;
    providerId?: string | null;
    dataSourceId?: string | null;
  };

  export type ColumnMappingCreateManyMetricDefinitionInput = {
    id?: string;
    columnName: string;
    transformationRule?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dataSourceId: string;
  };

  export type GoalCreateManyMetricDefinitionInput = {
    id?: string;
    timePeriod: string;
    startDate: Date | string;
    endDate: Date | string;
    targetValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    clinicId?: string | null;
    providerId?: string | null;
  };

  export type WidgetCreateManyMetricDefinitionInput = {
    id?: string;
    widgetType: string;
    chartType?: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    dashboardId: string;
  };

  export type MetricValueUpdateWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinic?: ClinicUpdateOneWithoutMetricsNestedInput;
    provider?: ProviderUpdateOneWithoutMetricsNestedInput;
    dataSource?: DataSourceUpdateOneWithoutMetricsNestedInput;
  };

  export type MetricValueUncheckedUpdateWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
    dataSourceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type MetricValueUncheckedUpdateManyWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
    dataSourceId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ColumnMappingUpdateWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dataSource?: DataSourceUpdateOneRequiredWithoutColumnMappingsNestedInput;
  };

  export type ColumnMappingUncheckedUpdateWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dataSourceId?: StringFieldUpdateOperationsInput | string;
  };

  export type ColumnMappingUncheckedUpdateManyWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dataSourceId?: StringFieldUpdateOperationsInput | string;
  };

  export type GoalUpdateWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinic?: ClinicUpdateOneWithoutGoalsNestedInput;
    provider?: ProviderUpdateOneWithoutGoalsNestedInput;
  };

  export type GoalUncheckedUpdateWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type GoalUncheckedUpdateManyWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    timePeriod?: StringFieldUpdateOperationsInput | string;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WidgetUpdateWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dashboard?: DashboardUpdateOneRequiredWithoutWidgetsNestedInput;
  };

  export type WidgetUncheckedUpdateWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dashboardId?: StringFieldUpdateOperationsInput | string;
  };

  export type WidgetUncheckedUpdateManyWithoutMetricDefinitionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    dashboardId?: StringFieldUpdateOperationsInput | string;
  };

  export type ColumnMappingCreateManyDataSourceInput = {
    id?: string;
    columnName: string;
    transformationRule?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
  };

  export type MetricValueCreateManyDataSourceInput = {
    id?: string;
    date: Date | string;
    value: string;
    sourceType: string;
    sourceSheet?: string | null;
    externalId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId: string;
    clinicId?: string | null;
    providerId?: string | null;
  };

  export type ColumnMappingUpdateWithoutDataSourceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinition?: MetricDefinitionUpdateOneRequiredWithoutColumnMappingsNestedInput;
  };

  export type ColumnMappingUncheckedUpdateWithoutDataSourceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
  };

  export type ColumnMappingUncheckedUpdateManyWithoutDataSourceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    columnName?: StringFieldUpdateOperationsInput | string;
    transformationRule?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
  };

  export type MetricValueUpdateWithoutDataSourceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinition?: MetricDefinitionUpdateOneRequiredWithoutMetricsNestedInput;
    clinic?: ClinicUpdateOneWithoutMetricsNestedInput;
    provider?: ProviderUpdateOneWithoutMetricsNestedInput;
  };

  export type MetricValueUncheckedUpdateWithoutDataSourceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type MetricValueUncheckedUpdateManyWithoutDataSourceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    value?: StringFieldUpdateOperationsInput | string;
    sourceType?: StringFieldUpdateOperationsInput | string;
    sourceSheet?: NullableStringFieldUpdateOperationsInput | string | null;
    externalId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: StringFieldUpdateOperationsInput | string;
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null;
    providerId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WidgetCreateManyDashboardInput = {
    id?: string;
    widgetType: string;
    chartType?: string | null;
    positionX: number;
    positionY: number;
    width: number;
    height: number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    metricDefinitionId?: string | null;
  };

  export type WidgetUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinition?: MetricDefinitionUpdateOneWithoutWidgetsNestedInput;
  };

  export type WidgetUncheckedUpdateWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WidgetUncheckedUpdateManyWithoutDashboardInput = {
    id?: StringFieldUpdateOperationsInput | string;
    widgetType?: StringFieldUpdateOperationsInput | string;
    chartType?: NullableStringFieldUpdateOperationsInput | string | null;
    positionX?: IntFieldUpdateOperationsInput | number;
    positionY?: IntFieldUpdateOperationsInput | number;
    width?: IntFieldUpdateOperationsInput | number;
    height?: IntFieldUpdateOperationsInput | number;
    config?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    metricDefinitionId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
</file>

</files>
