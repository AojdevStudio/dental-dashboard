This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
database-schema-design.md
database-schema-metrics.md
dental_dashboard_architecture.svg
feature-spec.md
file-system.md
mvp.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="database-schema-design.md">
#### Detailed Implementation Guide

**Database Schema Design**:
```sql
-- Google Sheets Integration Tables
CREATE TABLE google_credentials (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  access_token text NOT NULL, -- Encrypted
  refresh_token text NOT NULL, -- Encrypted
  expires_at timestamptz NOT NULL,
  scope text[] NOT NULL,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE spreadsheet_connections (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  credential_id uuid REFERENCES google_credentials(id) ON DELETE CASCADE,
  spreadsheet_id text NOT NULL,
  spreadsheet_name text NOT NULL,
  sheet_names text[] NOT NULL,
  last_sync_at timestamptz,
  sync_status text CHECK (sync_status IN ('active', 'paused', 'error')) DEFAULT 'active',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(clinic_id, spreadsheet_id)
);

CREATE TABLE column_mappings (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  connection_id uuid REFERENCES spreadsheet_connections(id) ON DELETE CASCADE,
  sheet_name text NOT NULL,
  mapping_config jsonb NOT NULL, -- Column mappings and transformations
  template_name text,
  version integer DEFAULT 1,
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX idx_google_credentials_clinic_id ON google_credentials(clinic_id);
CREATE INDEX idx_spreadsheet_connections_clinic_id ON spreadsheet_connections(clinic_id);
CREATE INDEX idx_column_mappings_connection_id ON column_mappings(connection_id);
```

**Authentication Flow Implementation**:
1. Frontend initiates OAuth flow by redirecting to `/api/auth/google/connect`
2. API route generates state parameter and redirects to Google OAuth consent screen
3. Google redirects back to `/api/auth/google/callback` with authorization code
4. Callback handler exchanges code for access/refresh tokens using server-side flow
5. Tokens are encrypted using Supabase encryption functions and stored in database
6. Frontend receives success confirmation and updates connection status
7. Implement automatic token refresh 5 minutes before expiration using Edge Functions

**Data Extraction Pipeline**:
1. **Discovery Phase**: Query Google Sheets API for accessible spreadsheets, cache results
2. **Selection Phase**: User selects target spreadsheets through frontend interface
3. **Mapping Phase**: Analyze sheet structure, suggest mappings, allow customization
4. **Validation Phase**: Test mappings against sample data, validate data types
5. **Extraction Phase**: Extract data in batches, apply transformations, validate results
6. **Storage Phase**: Insert transformed data into metrics tables with conflict resolution

**Error Handling Strategy**:
- Implement exponential backoff for API rate limits (initial delay: 1s, max: 60s)
- Categorize errors: Authentication, Authorization, API Limits, Data Validation, Network
- For authentication errors: Attempt token refresh, prompt re-authorization if needed
- For API limit errors: Queue requests with intelligent retry scheduling
- For data validation errors: Log details, skip invalid rows, continue processing
- Maintain error logs with Winston structured logging for debugging and monitoring

**Security Considerations**:
- Encrypt all Google API credentials using Supabase built-in encryption
- Implement Row Level Security policies to isolate clinic data
- Validate all user inputs using Zod schemas before processing
- Use HTTPS for all external API communications
- Implement request signing for sensitive operations
- Regular credential rotation with 90-day expiration warnings

### Essential KPI Dashboard

**Feature Goal**: Provide role-based, responsive dashboard interfaces displaying core dental practice metrics with real-time updates, customizable filtering, and optimized performance for up to 50 concurrent users.

**API Relationships**:
- Metrics API endpoints for data retrieval
- Supabase RLS for role-based data filtering
- TanStack Query for caching and real-time updates
- Recharts library for visualization components
- Export API for PDF/CSV generation

#### Detailed Feature Requirements

**Dashboard Layout & Navigation**:
- Implement three distinct dashboard layouts based on user roles:
  - **Office Manager**: Complete financial overview, patient metrics, provider performance, goal tracking
  - **Dentist**: Personal production metrics, patient case acceptance, treatment planning progress
  - **Front Desk**: Appointment analytics, call tracking, daily schedules, patient check-ins
- Responsive design supporting desktop (1920x1080), tablet (768x1024), and mobile (375x812) viewports
- Persistent sidebar navigation with collapsible menu and active state indicators
- Breadcrumb navigation for deep dashboard sections with back button functionality

**Financial Metrics Dashboard**:
- **Production Tracking**: Daily, weekly, monthly production totals with year-over-year comparison
- **Collection Analytics**: Collection percentages, aging reports, payment method breakdown
- **Insurance vs Patient Payments**: Visual breakdown of payment sources with trending
- **Provider Production Comparison**: Side-by-side provider performance with production goals
- **Profit Margin Analysis**: Revenue vs expenses with profitability indicators
- Real-time updates every 15 minutes during business hours, hourly after hours

**Patient Metrics Display**:
- **Active Patient Count**: Total active patients with growth/decline indicators
- **New Patient Acquisition**: Monthly new patient counts with source tracking
- **Recare Rate Tracking**: Hygiene reactivation success rates and overdue patient counts
- **Patient Retention Analytics**: Churn rates, average patient lifetime value
- **Demographics Breakdown**: Age groups, insurance types, geographic distribution
- **Treatment Acceptance Rates**: Case acceptance by treatment type and provider

**Appointment Analytics Interface**:
- **Schedule Efficiency**: Appointment slot utilization with optimal scheduling recommendations
- **Cancellation & No-Show Tracking**: Rates by day of week, time of day, and patient demographics
- **Provider Schedule Analysis**: Productivity by provider with available appointment slots
- **Treatment Type Distribution**: Breakdown of appointment types with revenue per appointment
- **Same-Day Scheduling**: Emergency appointment handling and last-minute availability

**Call Tracking Performance**:
- **Unscheduled Treatment Follow-up**: Success rates for treatment plan follow-up calls
- **Hygiene Reactivation**: Recall appointment booking success rates
- **New Patient Conversion**: Phone inquiry to scheduled appointment conversion rates
- **Call Volume Analytics**: Peak calling times, average call duration, call outcomes
- **Script Performance**: Conversion rates by call script and team member
</file>

<file path="database-schema-metrics.md">
#### Detailed Implementation Guide

**Database Schema for Metrics**:
```sql
-- Core Metrics Tables
CREATE TABLE financial_metrics (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  provider_id uuid REFERENCES providers(id),
  metric_date date NOT NULL,
  production_amount decimal(10,2) DEFAULT 0,
  collection_amount decimal(10,2) DEFAULT 0,
  insurance_payments decimal(10,2) DEFAULT 0,
  patient_payments decimal(10,2) DEFAULT 0,
  adjustments decimal(10,2) DEFAULT 0,
  net_production decimal(10,2) DEFAULT 0,
  writeoffs decimal(10,2) DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  UNIQUE(clinic_id, provider_id, metric_date)
);

CREATE TABLE patient_metrics (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  metric_date date NOT NULL,
  active_patients integer DEFAULT 0,
  new_patients integer DEFAULT 0,
  recare_due integer DEFAULT 0,
  recare_scheduled integer DEFAULT 0,
  treatment_acceptance_rate decimal(5,2) DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  UNIQUE(clinic_id, metric_date)
);

CREATE TABLE appointment_metrics (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  provider_id uuid REFERENCES providers(id),
  metric_date date NOT NULL,
  adult_prophy integer DEFAULT 0,
  child_prophy integer DEFAULT 0,
  perio_maintenance integer DEFAULT 0,
  total_srp_appointments integer DEFAULT 0,
  sealants integer DEFAULT 0,
  fluoride_given integer DEFAULT 0,
  toothbrush integer DEFAULT 0,
  full_mouth_scaling integer DEFAULT 0,
  total_whitening integer DEFAULT 0,
  laser integer DEFAULT 0,
  arestin integer DEFAULT 0,
  gingival_irrigation integer DEFAULT 0,
  oral_cancer_screening integer DEFAULT 0,
  fluoride_trays integer DEFAULT 0,
  comprehensive_perio integer DEFAULT 0,
  limited_oral_evaluation integer DEFAULT 0,
  periodic_oral_evaluation integer DEFAULT 0,
  comprehensive_exams integer DEFAULT 0,
  consultation integer DEFAULT 0,
  invisalign_consult integer DEFAULT 0,
  total_invisalign integer DEFAULT 0,
  total_extractions integer DEFAULT 0,
  total_bone_grafts integer DEFAULT 0,
  total_crowns_prepped integer DEFAULT 0,
  total_crowns_seated integer DEFAULT 0,
  total_root_canals integer DEFAULT 0,
  total_fillings integer DEFAULT 0,
  total_dentures integer DEFAULT 0,
  total_implants integer DEFAULT 0,
  total_fmr integer DEFAULT 0,
  total_appointments integer DEFAULT 0,
  cancelled_or_missed_appointments integer DEFAULT 0,
  kept_appointments integer DEFAULT 0,
  recalls integer DEFAULT 0,
  perio integer DEFAULT 0,
  fluoride_eligible_appts integer DEFAULT 0,
  total_hygiene_appointments integer DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  UNIQUE(clinic_id, provider_id, metric_date)
);

CREATE TABLE call_metrics (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  metric_date date NOT NULL,
  unscheduled_calls integer DEFAULT 0,
  unscheduled_success integer DEFAULT 0,
  recare_calls integer DEFAULT 0,
  recare_success integer DEFAULT 0,
  new_patient_calls integer DEFAULT 0,
  new_patient_scheduled integer DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  UNIQUE(clinic_id, metric_date)
);
```

**Component Architecture**:
- **MetricCard Component**: Reusable card displaying single KPI with trend indicators, sparkline charts, and comparison values
- **KPIChart Component**: Configurable chart component supporting line, bar, doughnut, and area charts with responsive design
- **FilterPanel Component**: Unified filtering interface with date ranges, provider selection, and metric type toggles
- **DashboardGrid Component**: Responsive grid layout with drag-and-drop capability for dashboard customization
- **ExportControls Component**: Export functionality with format selection (PDF, CSV, Excel) and custom date ranges

**Real-time Data Strategy**:
- Implement TanStack Query with 5-minute cache invalidation for financial metrics
- Use Supabase real-time subscriptions for critical metrics requiring immediate updates
- Implement optimistic updates for user interactions with rollback on API errors
- Cache frequently accessed data in browser localStorage with 1-hour expiration
- Implement background data prefetching for adjacent time periods

**Performance Optimization**:
- Implement virtual scrolling for large data tables with 50-row viewports
- Use React.memo for expensive metric calculation components
- Implement lazy loading for chart components with skeleton loading states
- Optimize database queries with proper indexing and query result caching
- Use Supabase Edge Functions for complex metric aggregations to reduce client processing

**Role-Based Access Control**:
```sql
-- RLS Policies for Metrics
CREATE POLICY "Users can view clinic metrics" ON financial_metrics
  FOR SELECT USING (
    clinic_id IN (
      SELECT clinic_id FROM user_clinic_roles 
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Providers can view own metrics" ON financial_metrics
  FOR SELECT USING (
    provider_id IN (
      SELECT id FROM providers 
      WHERE user_id = auth.uid()
    ) OR 
    clinic_id IN (
      SELECT clinic_id FROM user_clinic_roles 
      WHERE user_id = auth.uid() 
      AND role IN ('office_manager', 'admin')
    )
  );
```

**Export Functionality Implementation**:
- **PDF Generation**: Use Puppeteer to render dashboard views as PDFs with clinic branding
- **CSV Export**: Implement server-side CSV generation with custom column selection
- **Excel Export**: Generate Excel files with multiple sheets for different metric categories
- **Scheduled Reports**: Allow users to configure automated email reports with custom schedules
- Store exported files in Supabase Storage with 30-day retention and secure access links

### Multi-Tenant User Management

**Feature Goal**: Implement comprehensive role-based access control system supporting multiple dental practices with complete data isolation, secure user lifecycle management, and provider-specific performance tracking.

**API Relationships**:
- Supabase Auth for authentication and session management
- Supabase RLS for data isolation between clinics
- Prisma ORM for user and clinic relationship management
- Winston logging for audit trail and security monitoring
- Email service integration for user invitations and notifications

#### Detailed Feature Requirements

**Clinic-Based Multi-Tenancy**:
- Complete data isolation between clinics using Row Level Security policies
- Support for unlimited clinics with individual subscription management
- Clinic-specific branding customization (logo, colors, practice name)
- Independent user management and role assignment per clinic
- Cross-clinic user access for management companies with proper role hierarchy

**User Role System**:
- **Admin Role**: Full system access, clinic management, user administration, billing oversight
- **Office Manager Role**: Financial reporting, user management, goal setting, all clinic metrics access
- **Dentist Role**: Personal production metrics, patient treatment tracking, appointment management
- **Front Desk Role**: Basic call tracking, daily reports, clinic metrics access, position based metrics access (future feature)
- **Custom Roles**: Configurable role creation with granular permission assignment

**User Lifecycle Management**:
- Secure user invitation system with encrypted invitation tokens and 7-day expiration
- Self-registration workflow with email verification and admin approval process
- User profile management with role changes, contact information updates, and password reset
- Account deactivation and reactivation with data preservation and access logging

**Provider Association & Tracking**:
- Link dental providers to user accounts with professional license validation (incorporates alert system for license expiration - future feature)
- Track provider-specific metrics including production, patient satisfaction, and treatment outcomes
- Support multiple providers per user account for associate dentists and specialists
- Provider schedule management with availability tracking and appointment assignment (future feature)
- Performance benchmarking between providers within clinic and across industry standards

#### Detailed Implementation Guide

**Core Database Schema**:
```sql
-- Multi-Tenant Foundation
CREATE TABLE clinics (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  address text,
  phone text,
  email text,
  logo_url text,
  brand_colors jsonb DEFAULT '{"primary": "#3B82F6", "secondary": "#6B7280"}',
  subscription_status text CHECK (subscription_status IN ('active', 'suspended', 'cancelled')) DEFAULT 'active',
  subscription_tier text CHECK (subscription_tier IN ('basic', 'professional', 'enterprise')) DEFAULT 'basic',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE user_clinic_roles (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  role text CHECK (role IN ('admin', 'office_manager', 'dentist', 'front_desk', 'custom')) NOT NULL,
  permissions jsonb DEFAULT '{}',
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(user_id, clinic_id)
);

CREATE TABLE providers (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  user_id uuid REFERENCES auth.users(id),
  provider_name text NOT NULL,
  license_number text,
  specialties text[],
  hire_date date,
  employment_status text CHECK (employment_status IN ('active', 'inactive', 'terminated')) DEFAULT 'active',
  commission_rate decimal(5,2),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE user_invitations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  email text NOT NULL,
  role text NOT NULL,
  invitation_token text NOT NULL UNIQUE,
  invited_by uuid REFERENCES auth.users(id),
  expires_at timestamptz NOT NULL,
  accepted_at timestamptz,
  created_at timestamptz DEFAULT now()
);

CREATE TABLE user_sessions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  clinic_id uuid REFERENCES clinics(id),
  session_token text NOT NULL,
  ip_address inet,
  user_agent text,
  expires_at timestamptz NOT NULL,
  created_at timestamptz DEFAULT now()
);
```

**Row Level Security Implementation**:
```sql
-- Enable RLS on all multi-tenant tables
ALTER TABLE clinics ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_clinic_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE providers ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_invitations ENABLE ROW LEVEL SECURITY;

-- Clinic access policy
CREATE POLICY "Users can access their clinics" ON clinics
  FOR ALL USING (
    id IN (
      SELECT clinic_id FROM user_clinic_roles 
      WHERE user_id = auth.uid() AND is_active = true
    )
  );

-- User role management policy
CREATE POLICY "Office managers can manage clinic users" ON user_clinic_roles
  FOR ALL USING (
    clinic_id IN (
      SELECT clinic_id FROM user_clinic_roles 
      WHERE user_id = auth.uid() 
      AND role IN ('admin', 'office_manager') 
      AND is_active = true
    )
  );

-- Provider access policy
CREATE POLICY "Users can view clinic providers" ON providers
  FOR SELECT USING (
    clinic_id IN (
      SELECT clinic_id FROM user_clinic_roles 
      WHERE user_id = auth.uid() AND is_active = true
    )
  );

```sql
-- Providers can update their own information
CREATE POLICY "Providers can update own profile" ON providers
  FOR UPDATE USING (user_id = auth.uid());
```

**Authentication & Authorization Flow**:
1. **User Registration**: New users register with email/password, receive verification email
2. **Invitation Processing**: Invited users click secure token link, complete registration with pre-assigned role
3. **Login Authentication**: Supabase Auth validates credentials, creates secure session
4. **Clinic Selection**: Multi-clinic users select active clinic context for session
5. **Role Validation**: Middleware validates user role and permissions for requested resources
6. **Session Management**: Implement sliding session expiration with 8-hour active, 30-day idle timeout

**User Invitation System Implementation**:
```typescript
// Invitation creation flow
export async function createUserInvitation(
  clinicId: string,
  email: string,
  role: UserRole,
  invitedBy: string
) {
  // Generate secure invitation token
  const invitationToken = crypto.randomBytes(32).toString('hex');
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
  
  // Store invitation in database
  const invitation = await prisma.userInvitation.create({
    data: {
      clinicId,
      email,
      role,
      invitationToken,
      invitedBy,
      expiresAt
    }
  });
  
  // Send invitation email with secure link
  await sendInvitationEmail(email, invitationToken, clinicId);
  
  // Log invitation creation for audit
  logger.info('User invitation created', {
    clinicId,
    email,
    role,
    invitedBy,
    invitationId: invitation.id
  });
  
  return invitation;
}
```

**Role-Based Permission System**:
```typescript
// Permission definitions
export const PERMISSIONS = {
  // Financial permissions
  VIEW_FINANCIAL_REPORTS: 'view_financial_reports',
  EXPORT_FINANCIAL_DATA: 'export_financial_data',
  MANAGE_BILLING: 'manage_billing',
  
  // User management permissions
  INVITE_USERS: 'invite_users',
  MANAGE_USER_ROLES: 'manage_user_roles',
  DEACTIVATE_USERS: 'deactivate_users',
  
  // Provider permissions
  VIEW_ALL_PROVIDERS: 'view_all_providers',
  MANAGE_PROVIDERS: 'manage_providers',
  VIEW_PROVIDER_PERFORMANCE: 'view_provider_performance',
  
  // Goal management
  CREATE_CLINIC_GOALS: 'create_clinic_goals',
  MANAGE_PROVIDER_GOALS: 'manage_provider_goals',
  
  // Integration management
  MANAGE_INTEGRATIONS: 'manage_integrations',
  CONFIGURE_SYNC: 'configure_sync'
} as const;

// Role permission mapping
export const ROLE_PERMISSIONS = {
  admin: [
    PERMISSIONS.VIEW_FINANCIAL_REPORTS,
    PERMISSIONS.EXPORT_FINANCIAL_DATA,
    PERMISSIONS.MANAGE_BILLING,
    PERMISSIONS.INVITE_USERS,
    PERMISSIONS.MANAGE_USER_ROLES,
    PERMISSIONS.DEACTIVATE_USERS,
    PERMISSIONS.VIEW_ALL_PROVIDERS,
    PERMISSIONS.MANAGE_PROVIDERS,
    PERMISSIONS.VIEW_PROVIDER_PERFORMANCE,
    PERMISSIONS.CREATE_CLINIC_GOALS,
    PERMISSIONS.MANAGE_PROVIDER_GOALS,
    PERMISSIONS.MANAGE_INTEGRATIONS,
    PERMISSIONS.CONFIGURE_SYNC
  ],
  office_manager: [
    PERMISSIONS.VIEW_FINANCIAL_REPORTS,
    PERMISSIONS.EXPORT_FINANCIAL_DATA,
    PERMISSIONS.INVITE_USERS,
    PERMISSIONS.MANAGE_USER_ROLES,
    PERMISSIONS.VIEW_ALL_PROVIDERS,
    PERMISSIONS.VIEW_PROVIDER_PERFORMANCE,
    PERMISSIONS.CREATE_CLINIC_GOALS,
    PERMISSIONS.MANAGE_PROVIDER_GOALS,
    PERMISSIONS.CONFIGURE_SYNC
  ],
  dentist: [
    PERMISSIONS.VIEW_PROVIDER_PERFORMANCE,
    PERMISSIONS.EXPORT_FINANCIAL_DATA
  ],
  front_desk: [
    PERMISSIONS.VIEW_ALL_PROVIDERS
  ]
};
```

**Audit Logging Implementation**:
```typescript
// Comprehensive audit logging for security and compliance
export async function logUserAction(
  userId: string,
  clinicId: string,
  action: string,
  resourceType: string,
  resourceId?: string,
  metadata?: Record<string, any>
) {
  const auditLog = {
    userId,
    clinicId,
    action,
    resourceType,
    resourceId,
    metadata,
    timestamp: new Date(),
    ipAddress: getClientIP(),
    userAgent: getUserAgent()
  };
  
  // Log to Winston for immediate monitoring
  logger.info('User action logged', auditLog);
  
  // Store in database for compliance
  await prisma.auditLog.create({
    data: auditLog
  });
  
  // Send to monitoring service for real-time alerts
  if (SECURITY_CRITICAL_ACTIONS.includes(action)) {
    await sendSecurityAlert(auditLog);
  }
}
```

**Provider Performance Tracking**:
```typescript
// Provider performance metrics calculation
export async function calculateProviderMetrics(
  providerId: string,
  startDate: Date,
  endDate: Date
) {
  const metrics = await prisma.$queryRaw`
    SELECT 
      p.id as provider_id,
      p.provider_name,
      SUM(fm.production_amount) as total_production,
      AVG(fm.production_amount) as avg_daily_production,
      COUNT(am.kept_appointments) as total_appointments,
      ROUND(
        COUNT(am.kept_appointments)::decimal / 
        NULLIF(COUNT(am.total_appointments), 0) * 100, 2
      ) as appointment_keep_rate,
      COUNT(DISTINCT DATE(fm.metric_date)) as working_days
    FROM providers p
    LEFT JOIN financial_metrics fm ON p.id = fm.provider_id
    LEFT JOIN appointment_metrics am ON p.id = am.provider_id
    WHERE p.id = ${providerId}
    AND fm.metric_date BETWEEN ${startDate} AND ${endDate}
    GROUP BY p.id, p.provider_name
  `;
  
  return metrics[0];
}
```

**Security Considerations**:
- Implement password complexity requirements with minimum 12 characters, mixed case, numbers, symbols
- Enable two-factor authentication for admin and office manager roles
- Session management with secure HTTP-only cookies and CSRF protection
- Regular security audits with automated vulnerability scanning
- Implement account lockout after 5 failed login attempts with exponential backoff
- Data encryption at rest using Supabase built-in encryption
- Regular access reviews with automatic role expiration for temporary access

### Data Synchronization & Processing

**Feature Goal**: Establish robust, scalable background processing system for automated Google Sheets data synchronization, real-time metric calculations, and comprehensive error handling with full audit trails.

**API Relationships**:
- Supabase Edge Functions for serverless processing
- Supabase cron jobs for scheduled operations
- Google Sheets API for data retrieval
- Prisma ORM for efficient batch database operations
- Winston logging for monitoring and debugging

#### Detailed Feature Requirements

**Scheduled Synchronization System**:
- Configurable sync schedules per spreadsheet (hourly, daily, weekly, custom cron expressions)
- Priority-based processing queue with high-priority manual syncs and lower-priority automated syncs
- Intelligent sync frequency adjustment based on data change detection and business hours
- Sync window management to avoid processing during high-traffic periods
- Backup sync scheduling with automatic retry during primary sync failures

**Real-Time Data Transformation Pipeline**:
- Stream processing architecture for immediate data validation and transformation
- Multi-stage pipeline: Extract → Validate → Transform → Aggregate → Store
- Parallel processing for multiple spreadsheets with resource management
- Data lineage tracking for complete audit trails from source to metrics
- Rollback capabilities for failed transformations with data integrity protection

**Historical Data Management**:
- Bulk import support for existing spreadsheet data up to 10,000 rows per operation
- Intelligent data deduplication using configurable composite keys
- Historical data backfill with gap detection and automatic repair
- Data archival policies with configurable retention periods
- Point-in-time recovery capabilities for data corruption scenarios

**Error Recovery & Monitoring**:
- Comprehensive error categorization: API limits, authentication, data validation, system errors
- Automatic retry logic with exponential backoff and circuit breaker patterns
- Dead letter queue for failed operations requiring manual intervention
- Real-time monitoring dashboards with alert thresholds and notification channels
- Performance metrics tracking with processing time optimization

#### Detailed Implementation Guide

**Database Schema for Sync Management**:
```sql
-- Synchronization tracking and management
CREATE TABLE sync_jobs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  connection_id uuid REFERENCES spreadsheet_connections(id) ON DELETE CASCADE,
  job_type text CHECK (job_type IN ('manual', 'scheduled', 'backfill')) NOT NULL,
  status text CHECK (status IN ('pending', 'running', 'completed', 'failed', 'cancelled')) DEFAULT 'pending',
  priority integer DEFAULT 5 CHECK (priority BETWEEN 1 AND 10),
  scheduled_at timestamptz NOT NULL,
  started_at timestamptz,
  completed_at timestamptz,
  error_message text,
  retry_count integer DEFAULT 0,
  max_retries integer DEFAULT 3,
  processing_stats jsonb DEFAULT '{}',
  created_at timestamptz DEFAULT now()
);

CREATE TABLE sync_operations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  job_id uuid REFERENCES sync_jobs(id) ON DELETE CASCADE,
  operation_type text CHECK (operation_type IN ('extract', 'validate', 'transform', 'aggregate', 'store')) NOT NULL,
  sheet_name text NOT NULL,
  status text CHECK (status IN ('pending', 'running', 'completed', 'failed')) DEFAULT 'pending',
  started_at timestamptz,
  completed_at timestamptz,
  records_processed integer DEFAULT 0,
  records_succeeded integer DEFAULT 0,
  records_failed integer DEFAULT 0,
  error_details jsonb DEFAULT '[]',
  created_at timestamptz DEFAULT now()
);

CREATE TABLE data_lineage (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  source_type text NOT NULL, -- 'google_sheets'
  source_id text NOT NULL, -- spreadsheet_id:sheet_name:row_number
  target_table text NOT NULL,
  target_id uuid NOT NULL,
  transformation_applied text,
  sync_job_id uuid REFERENCES sync_jobs(id),
  created_at timestamptz DEFAULT now()
);

CREATE TABLE processing_errors (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  sync_job_id uuid REFERENCES sync_jobs(id),
  error_type text NOT NULL,
  error_code text,
  error_message text NOT NULL,
  stack_trace text,
  context_data jsonb DEFAULT '{}',
  resolved_at timestamptz,
  resolution_notes text,
  created_at timestamptz DEFAULT now()
);

-- Indexes for performance
CREATE INDEX idx_sync_jobs_status_scheduled ON sync_jobs(status, scheduled_at);
CREATE INDEX idx_sync_operations_job_id ON sync_operations(job_id);
CREATE INDEX idx_data_lineage_target ON data_lineage(target_table, target_id);
CREATE INDEX idx_processing_errors_sync_job ON processing_errors(sync_job_id);
```

**Edge Function Architecture**:
```typescript
// Main sync orchestrator function
export async function handleScheduledSync() {
  const logger = createLogger('sync-orchestrator');
  
  try {
    // Get pending sync jobs ordered by priority and schedule
    const pendingJobs = await prisma.syncJob.findMany({
      where: {
        status: 'pending',
        scheduledAt: { lte: new Date() }
      },
      include: {
        connection: {
          include: {
            credential: true,
            mappings: { where: { isActive: true } }
          }
        }
      },
      orderBy: [
        { priority: 'desc' },
        { scheduledAt: 'asc' }
      ],
      take: 10 // Process max 10 jobs concurrently
    });
    
    logger.info(`Processing ${pendingJobs.length} sync jobs`);
    
    // Process jobs in parallel with concurrency control
    const jobPromises = pendingJobs.map(job => 
      processSyncJob(job).catch(error => {
        logger.error('Job processing failed', { 
          jobId: job.id, 
          error: error.message 
        });
        return { jobId: job.id, success: false, error };
      })
    );
    
    const results = await Promise.allSettled(jobPromises);
    
    // Log overall processing results
    const successful = results.filter(r => r.status === 'fulfilled').length;
    const failed = results.filter(r => r.status === 'rejected').length;
    
    logger.info('Sync batch completed', {
      total: pendingJobs.length,
      successful,
      failed
    });
    
  } catch (error) {
    logger.error('Sync orchestrator failed', { error: error.message });
    throw error;
  }
}

// Individual job processing
async function processSyncJob(job: SyncJobWithConnection) {
  const logger = createLogger('sync-processor', { jobId: job.id });
  
  // Update job status to running
  await prisma.syncJob.update({
    where: { id: job.id },
    data: { 
      status: 'running', 
      startedAt: new Date() 
    }
  });
  
  try {
    // Initialize Google Sheets client with stored credentials
    const sheetsClient = await createSheetsClient(job.connection.credential);
    
    // Process each mapped sheet
    for (const mapping of job.connection.mappings) {
      await processSingleSheet(job.id, sheetsClient, job.connection, mapping);
    }
    
    // Mark job as completed
    await prisma.syncJob.update({
      where: { id: job.id },
      data: { 
        status: 'completed', 
        completedAt: new Date() 
      }
    });
    
    logger.info('Sync job completed successfully');
    
  } catch (error) {
    // Handle job failure with retry logic
    const retryCount = job.retryCount + 1;
    
    if (retryCount <= job.maxRetries) {
      // Schedule retry with exponential backoff
      const retryDelay = Math.pow(2, retryCount) * 60000; // Minutes
      const nextAttempt = new Date(Date.now() + retryDelay);
      
      await prisma.syncJob.update({
        where: { id: job.id },
        data: {
          status: 'pending',
          retryCount,
          scheduledAt: nextAttempt,
          errorMessage: error.message
        }
      });
      
      logger.warn('Sync job failed, scheduling retry', {
        retryCount,
        nextAttempt,
        error: error.message
      });
      
    } else {
      // Max retries exceeded, mark as failed
      await prisma.syncJob.update({
        where: { id: job.id },
        data: {
          status: 'failed',
          completedAt: new Date(),
          errorMessage: error.message
        }
      });
      
      // Create error record for manual intervention
      await createProcessingError(job.id, 'SYNC_FAILURE', error);
      
      logger.error('Sync job failed permanently', {
        error: error.message,
        retryCount
      });
    }
    
    throw error;
  }
}
```

**Data Extraction & Validation Pipeline**:
```typescript
// Single sheet processing with comprehensive error handling
async function processSingleSheet(
  jobId: string,
  sheetsClient: GoogleSheetsClient,
  connection: SpreadsheetConnection,
  mapping: ColumnMapping
) {
  const logger = createLogger('sheet-processor', { 
    jobId, 
    sheetName: mapping.sheetName 
  });
  
  // Create operation record
  const operation = await prisma.syncOperation.create({
    data: {
      jobId,
      operationType: 'extract',
      sheetName: mapping.sheetName,
      status: 'running',
      startedAt: new Date()
    }
  });
  
  try {
    // Extract data from Google Sheets
    logger.info('Starting data extraction');
    const rawData = await extractSheetData(
      sheetsClient, 
      connection.spreadsheetId, 
      mapping.sheetName
    );
    
    // Update operation for validation phase
    await prisma.syncOperation.update({
      where: { id: operation.id },
      data: { 
        operationType: 'validate',
        recordsProcessed: rawData.length 
      }
    });
    
    // Validate extracted data
    logger.info(`Validating ${rawData.length} records`);
    const validationResults = await validateSheetData(rawData, mapping.mappingConfig);
    
    // Update operation for transformation phase
    await prisma.syncOperation.update({
      where: { id: operation.id },
      data: { 
        operationType: 'transform',
        recordsSucceeded: validationResults.valid.length,
        recordsFailed: validationResults.invalid.length,
        errorDetails: validationResults.errors
      }
    });
    
    // Transform valid data
    logger.info(`Transforming ${validationResults.valid.length} valid records`);
    const transformedData = await transformSheetData(
      validationResults.valid, 
      mapping.mappingConfig
    );
    
    // Update operation for storage phase
    await prisma.syncOperation.update({
      where: { id: operation.id },
      data: { operationType: 'store' }
    });
    
    // Store transformed data with upsert logic
    logger.info(`Storing ${transformedData.length} transformed records`);
    const storageResults = await storeTransformedData(
      transformedData, 
      connection.clinicId,
      jobId
    );
    
    // Complete operation
    await prisma.syncOperation.update({
      where: { id: operation.id },
      data: {
        status: 'completed',
        completedAt: new Date(),
        recordsSucceeded: storageResults.inserted + storageResults.updated
      }
    });
    
    logger.info('Sheet processing completed', {
      extracted: rawData.length,
      valid: validationResults.valid.length,
      stored: storageResults.inserted + storageResults.updated
    });
    
  } catch (error) {
    // Mark operation as failed
    await prisma.syncOperation.update({
      where: { id: operation.id },
      data: {
        status: 'failed',
        completedAt: new Date(),
        errorDetails: [{ 
          message: error.message, 
          stack: error.stack 
        }]
      }
    });
    
    // Create detailed error record
    await createProcessingError(jobId, 'SHEET_PROCESSING_ERROR', error, {
      sheetName: mapping.sheetName,
      operationId: operation.id
    });
    
    throw error;
  }
}
```

**Data Transformation Engine**:
```typescript
// Configurable data transformation with type coercion
async function transformSheetData(
  validData: any[],
  mappingConfig: ColumnMappingConfig
) {
  const transformedRecords = [];
  
  for (const record of validData) {
    try {
      const transformed = {};
      
      // Apply column mappings
      for (const [targetField, sourceConfig] of Object.entries(mappingConfig.fieldMappings)) {
        const sourceValue = record[sourceConfig.sourceColumn];
        
        // Apply transformation rules
        transformed[targetField] = await applyTransformationRules(
          sourceValue,
          sourceConfig.transformations
        );
      }
      
      // Add metadata
      transformed.sourceRowNumber = record._rowNumber;
      transformed.sourceSpreadsheetId = mappingConfig.spreadsheetId;
      transformed.sourceSheetName = mappingConfig.sheetName;
      transformed.transformedAt = new Date();
      
      transformedRecords.push(transformed);
      
    } catch (error) {
      // Log transformation error but continue processing
      logger.warn('Record transformation failed', {
        record,
        error: error.message
      });
    }
  }
  
  return transformedRecords;
}

// Transformation rule engine
async function applyTransformationRules(value: any, rules: TransformationRule[]) {
  let transformedValue = value;
  
  for (const rule of rules) {
    switch (rule.type) {
      case 'DATE_FORMAT':
        transformedValue = parseDate(transformedValue, rule.options.format);
        break;
        
      case 'CURRENCY_PARSE':
        transformedValue = parseCurrency(transformedValue);
        break;
        
      case 'STRING_TRIM':
        transformedValue = String(transformedValue).trim();
        break;
        
      case 'CONDITIONAL_MAP':
        transformedValue = applyConditionalMapping(transformedValue, rule.options.mappings);
        break;
        
      case 'CALCULATE':
        transformedValue = evaluateCalculation(transformedValue, rule.options.expression);
        break;
        
      default:
        logger.warn('Unknown transformation rule', { rule });
    }
  }
  
  return transformedValue;
}
```

**Cron Job Configuration**:
```typescript
// Supabase Edge Function for cron job management
export async function handleCronTrigger(request: Request) {
  const cronType = new URL(request.url).searchParams.get('type');
  
  switch (cronType) {
    case 'hourly-sync':
      return await scheduleHourlySyncs();
    case 'daily-aggregation':
      return await performDailyAggregation();
    case 'cleanup':
      return await performDataCleanup();
    default:
      return new Response('Invalid cron type', { status: 400 });
  }
}

// Schedule sync jobs based on clinic preferences
async function scheduleHourlySyncs() {
  const activeConnections = await prisma.spreadsheetConnection.findMany({
    where: {
      syncStatus: 'active',
      // Only sync during business hours (8 AM - 6 PM)
      AND: [
        { 
          clinic: { 
            preferences: { 
              path: ['businessHours', 'start'], 
              lte: new Date().getHours() 
            } 
          } 
        },
        { 
          clinic: { 
            preferences: { 
              path: ['businessHours', 'end'], 
              gte: new Date().getHours() 
            } 
          } 
        }
      ]
    },
    include: { clinic: true }
  });
  
  // Create sync jobs for eligible connections
  const jobs = activeConnections.map(connection => ({
    connectionId: connection.id,
    jobType: 'scheduled',
    priority: 5,
    scheduledAt: new Date(),
    maxRetries: 3
  }));
  
  await prisma.syncJob.createMany({ data: jobs });
  
  return new Response(`Scheduled ${jobs.length} sync jobs`, { status: 200 });
}
```

**Performance Monitoring & Optimization**:
- Implement query optimization with database query analysis and index recommendations
- Monitor Edge Function execution times with automatic scaling based on load
- Track API rate limit usage with intelligent request throttling
- Implement connection pooling for database operations with optimal pool sizing
- Monitor memory usage and implement garbage collection optimization for large datasets

### Goal Tracking & Reporting

**Feature Goal**: Provide comprehensive goal setting, progress tracking, and performance reporting system with variance analysis, automated alerts, and comparative benchmarking across providers and time periods.

**API Relationships**:
- Prisma ORM for goal data management and complex queries
- Recharts for interactive goal visualization and progress charts
- Supabase Edge Functions for goal calculations and variance analysis
- TanStack Query for real-time goal progress updates and caching
- Export API integration for goal performance reports

#### Detailed Feature Requirements

**Goal Definition & Configuration**:
- Multi-level goal hierarchy supporting clinic-wide, provider-specific, and department goals
- Time-based goal periods: monthly, quarterly, semi-annual, and annual cycles
- Goal types: production targets, collection goals, new patient acquisition, recare rates
- SMART goal framework integration with specific, measurable, achievable, relevant, time-bound criteria
- Goal template library with industry benchmarks and best practice recommendations
- Goal dependency tracking for cascading objectives and milestone management

**Progress Tracking & Analytics**:
- Real-time progress calculation with automatic updates from synchronized data
- Visual progress indicators including progress bars, trend lines, and milestone markers
- Variance analysis with statistical significance testing and confidence intervals
- Performance trajectory forecasting using historical data and trend analysis
- Comparative analysis between current performance, historical averages, and peer benchmarks
- Achievement probability scoring based on current trajectory and historical performance

**Alert & Notification System**:
- Configurable alert thresholds for goal achievement, variance warnings, and milestone alerts
- Multi-channel notifications: in-app notifications, email alerts, and SMS for critical goals
- Escalation workflows for missed milestones with automatic manager notifications
- Achievement celebrations with team recognition and performance highlights
- Early warning system for goals at risk of missing targets

**Reporting & Export Capabilities**:
- Comprehensive goal performance dashboards with drill-down capabilities
- Executive summary reports with key performance indicators and trend analysis
- Provider performance scorecards with individual and comparative metrics
- Goal achievement history with success rate analysis and improvement recommendations
- Custom report builder with flexible filtering, grouping, and visualization options

#### Detailed Implementation Guide

**Database Schema for Goal Management**:
```sql
-- Goal tracking and management system
CREATE TABLE goal_templates (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  description text,
  category text CHECK (category IN ('financial', 'patient', 'operational', 'quality')) NOT NULL,
  default_target_type text CHECK (default_target_type IN ('absolute', 'percentage', 'ratio')) NOT NULL,
  benchmark_value decimal(12,2),
  benchmark_source text,
  industry_percentile decimal(5,2),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE goals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  clinic_id uuid REFERENCES clinics(id) ON DELETE CASCADE,
  template_id uuid REFERENCES goal_templates(id),
  goal_name text NOT NULL,
  description text,
  goal_type text CHECK (goal_type IN ('clinic', 'provider', 'department')) NOT NULL,
  target_entity_id uuid, -- provider_id or department_id
  target_value decimal(12,2) NOT NULL,
  target_type text CHECK (target_type IN ('absolute', 'percentage', 'ratio')) NOT NULL,
  measurement_frequency text CHECK (measurement_frequency IN ('daily', 'weekly', 'monthly')) DEFAULT 'monthly',
  start_date date NOT NULL,
  end_date date NOT NULL,
  status text CHECK (status IN ('active', 'paused', 'completed', 'cancelled')) DEFAULT 'active',
  priority text CHECK (priority IN ('low', 'medium', 'high', 'critical')) DEFAULT 'medium',
  created_by uuid REFERENCES auth.users(id),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE goal_milestones (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  goal_id uuid REFERENCES goals(id) ON DELETE CASCADE,
  milestone_name text NOT NULL,
  target_date date NOT NULL,
  target_value decimal(12,2) NOT NULL,
  achieved_value decimal(12,2),
  achieved_date date,
  status text CHECK (status IN ('pending', 'achieved', 'missed', 'delayed')) DEFAULT 'pending',
  created_at timestamptz DEFAULT now()
);

CREATE TABLE goal_progress (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  goal_id uuid REFERENCES goals(id) ON DELETE CASCADE,
  measurement_date date NOT NULL,
  actual_value decimal(12,2) NOT NULL,
  target_value decimal(12,2) NOT NULL,
  variance_amount decimal(12,2) GENERATED ALWAYS AS (actual_value - target_value) STORED,
  variance_percentage decimal(5,2) GENERATED ALWAYS AS (
    CASE 
      WHEN target_value != 0 THEN ((actual_value - target_value) / target_value) * 100
      ELSE 0 
    END
  ) STORED,
  data_source text DEFAULT 'automated',
  confidence_score decimal(3,2) DEFAULT 1.0,
  created_at timestamptz DEFAULT now(),
  UNIQUE(goal_id, measurement_date)
);

CREATE TABLE goal_alerts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  goal_id uuid REFERENCES goals(id) ON DELETE CASCADE,
  alert_type text CHECK (alert_type IN ('achievement', 'variance', 'milestone', 'risk')) NOT NULL,
  severity text CHECK (severity IN ('info', 'warning', 'critical')) NOT NULL,
  message text NOT NULL,
  threshold_value decimal(12,2),
  actual_value decimal(12,2),
  triggered_at timestamptz DEFAULT now(),
  acknowledged_at timestamptz,
  acknowledged_by uuid REFERENCES auth.users(id),
  resolution_notes text
);

CREATE TABLE goal_dependencies (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  parent_goal_id uuid REFERENCES goals(id) ON DELETE CASCADE,
  dependent_goal_id uuid REFERENCES goals(id) ON DELETE CASCADE,
  dependency_type text CHECK (dependency_type IN ('prerequisite', 'contributing', 'blocking')) NOT NULL,
  weight decimal(3,2) DEFAULT 1.0,
  created_at timestamptz DEFAULT now(),
  UNIQUE(parent_goal_id, dependent_goal_id)
);

-- Indexes for performance
CREATE INDEX idx_goals_clinic_status ON goals(clinic_id, status);
CREATE INDEX idx_goals_target_entity ON goals(target_entity_id, goal_type);
CREATE INDEX idx_goal_progress_goal_date ON goal_progress(goal_id, measurement_date);
CREATE INDEX idx_goal_alerts_goal_triggered ON goal_alerts(goal_id, triggered_at);
```

**Goal Progress Calculation Engine**:
```typescript
// Comprehensive goal progress calculation with forecasting
export async function calculateGoalProgress(goalId: string, asOfDate: Date = new Date()) {
  const goal = await prisma.goal.findUnique({
    where: { id: goalId },
    include: {
      milestones: true,
      progress: {
        where: { measurementDate: { lte: asOfDate } },
        orderBy: { measurementDate: 'desc' }
      },
      dependencies: {
        include: { dependentGoal: true }
      }
    }
  });
  
  if (!goal) throw new Error('Goal not found');
  
  // Calculate current progress
  const currentProgress = await getCurrentProgressValue(goal, asOfDate);
  const progressPercentage = (currentProgress / goal.targetValue) * 100;
  
  // Calculate time progress
  const totalDuration = differenceInDays(goal.endDate, goal.startDate);
  const elapsedDuration = differenceInDays(asOfDate, goal.startDate);
  const timeProgressPercentage = (elapsedDuration / totalDuration) * 100;
  
  // Variance analysis
  const expectedProgress = (timeProgressPercentage / 100) * goal.targetValue;
  const variance = currentProgress - expectedProgress;
  const variancePercentage = expectedProgress !== 0 ? (variance / expectedProgress) * 100 : 0;
  ```
  
```typescript
  // Trajectory forecasting
  const forecast = await calculateTrajectoryForecast(goal, currentProgress, asOfDate);
  
  // Achievement probability based on current trajectory
  const achievementProbability = calculateAchievementProbability(
    goal,
    currentProgress,
    timeProgressPercentage,
    forecast
  );
  
  // Milestone progress
  const milestoneProgress = goal.milestones.map(milestone => ({
    ...milestone,
    isAchieved: milestone.achievedDate !== null,
    isOverdue: milestone.targetDate < asOfDate && !milestone.achievedDate,
    daysRemaining: differenceInDays(milestone.targetDate, asOfDate)
  }));
  
  // Risk assessment
  const riskLevel = assessGoalRisk(
    progressPercentage,
    timeProgressPercentage,
    achievementProbability,
    goal.priority
  );
  
  return {
    goalId: goal.id,
    currentValue: currentProgress,
    targetValue: goal.targetValue,
    progressPercentage,
    timeProgressPercentage,
    variance,
    variancePercentage,
    forecast: {
      projectedFinalValue: forecast.projectedValue,
      confidenceInterval: forecast.confidenceInterval,
      achievementProbability
    },
    milestones: milestoneProgress,
    riskLevel,
    recommendations: generateGoalRecommendations(goal, progressPercentage, riskLevel)
  };
}

// Advanced trajectory forecasting using linear regression and seasonal adjustment
async function calculateTrajectoryForecast(
  goal: Goal,
  currentProgress: number,
  asOfDate: Date
) {
  const historicalData = await prisma.goalProgress.findMany({
    where: { goalId: goal.id },
    orderBy: { measurementDate: 'asc' }
  });
  
  if (historicalData.length < 3) {
    // Insufficient data for complex forecasting, use linear projection
    const remainingDays = differenceInDays(goal.endDate, asOfDate);
    const totalDays = differenceInDays(goal.endDate, goal.startDate);
    const dailyRate = currentProgress / (totalDays - remainingDays);
    
    return {
      projectedValue: currentProgress + (dailyRate * remainingDays),
      confidenceInterval: { lower: 0.8, upper: 1.2 },
      method: 'linear'
    };
  }
  
  // Prepare data for regression analysis
  const dataPoints = historicalData.map((point, index) => ({
    x: index, // Time index
    y: point.actualValue
  }));
  
  // Calculate linear regression
  const regression = calculateLinearRegression(dataPoints);
  const remainingPeriods = Math.ceil(
    differenceInDays(goal.endDate, asOfDate) / 
    (goal.measurementFrequency === 'daily' ? 1 : goal.measurementFrequency === 'weekly' ? 7 : 30)
  );
  
  // Project future value
  const projectedValue = regression.slope * (dataPoints.length + remainingPeriods) + regression.intercept;
  
  // Calculate confidence interval based on historical variance
  const residuals = dataPoints.map(point => 
    Math.abs(point.y - (regression.slope * point.x + regression.intercept))
  );
  const averageError = residuals.reduce((sum, error) => sum + error, 0) / residuals.length;
  
  return {
    projectedValue: Math.max(0, projectedValue),
    confidenceInterval: {
      lower: Math.max(0, projectedValue - averageError * 1.96),
      upper: projectedValue + averageError * 1.96
    },
    rSquared: regression.rSquared,
    method: 'regression'
  };
}
```

**Goal Alert System Implementation**:
```typescript
// Intelligent alert generation with configurable thresholds
export async function processGoalAlerts() {
  const logger = createLogger('goal-alerts');
  
  // Get all active goals that need alert processing
  const activeGoals = await prisma.goal.findMany({
    where: { status: 'active' },
    include: {
      progress: {
        orderBy: { measurementDate: 'desc' },
        take: 1
      },
      alerts: {
        where: { acknowledgedAt: null },
        orderBy: { triggeredAt: 'desc' }
      }
    }
  });
  
  for (const goal of activeGoals) {
    try {
      await processGoalAlertsForGoal(goal);
    } catch (error) {
      logger.error('Failed to process alerts for goal', {
        goalId: goal.id,
        error: error.message
      });
    }
  }
}

async function processGoalAlertsForGoal(goal: GoalWithProgress) {
  const progress = await calculateGoalProgress(goal.id);
  const alertsToCreate = [];
  
  // Achievement alert
  if (progress.progressPercentage >= 100 && !hasRecentAlert(goal.alerts, 'achievement')) {
    alertsToCreate.push({
      goalId: goal.id,
      alertType: 'achievement',
      severity: 'info',
      message: `🎉 Goal "${goal.goalName}" has been achieved! Target: ${goal.targetValue}, Actual: ${progress.currentValue}`,
      actualValue: progress.currentValue
    });
  }
  
  // Variance alerts based on configurable thresholds
  const varianceThresholds = {
    warning: 15, // 15% variance warning
    critical: 30  // 30% variance critical
  };
  
  if (Math.abs(progress.variancePercentage) >= varianceThresholds.critical && 
      !hasRecentAlert(goal.alerts, 'variance', 'critical')) {
    alertsToCreate.push({
      goalId: goal.id,
      alertType: 'variance',
      severity: 'critical',
      message: `⚠️ Critical variance detected for goal "${goal.goalName}". Variance: ${progress.variancePercentage.toFixed(1)}%`,
      thresholdValue: varianceThresholds.critical,
      actualValue: progress.variancePercentage
    });
  } else if (Math.abs(progress.variancePercentage) >= varianceThresholds.warning && 
             !hasRecentAlert(goal.alerts, 'variance', 'warning')) {
    alertsToCreate.push({
      goalId: goal.id,
      alertType: 'variance',
      severity: 'warning',
      message: `📊 Variance warning for goal "${goal.goalName}". Variance: ${progress.variancePercentage.toFixed(1)}%`,
      thresholdValue: varianceThresholds.warning,
      actualValue: progress.variancePercentage
    });
  }
  
  // Risk-based alerts
  if (progress.riskLevel === 'high' && !hasRecentAlert(goal.alerts, 'risk')) {
    alertsToCreate.push({
      goalId: goal.id,
      alertType: 'risk',
      severity: 'warning',
      message: `🔍 Goal "${goal.goalName}" is at high risk of not being achieved. Achievement probability: ${(progress.forecast.achievementProbability * 100).toFixed(1)}%`,
      actualValue: progress.forecast.achievementProbability
    });
  }
  
  // Milestone alerts
  for (const milestone of progress.milestones) {
    if (milestone.isOverdue && !hasRecentAlert(goal.alerts, 'milestone')) {
      alertsToCreate.push({
        goalId: goal.id,
        alertType: 'milestone',
        severity: 'warning',
        message: `📅 Milestone "${milestone.milestoneName}" is overdue by ${Math.abs(milestone.daysRemaining)} days`,
        actualValue: milestone.daysRemaining
      });
    }
  }
  
  // Create alerts in batch
  if (alertsToCreate.length > 0) {
    await prisma.goalAlert.createMany({
      data: alertsToCreate
    });
    
    // Send notifications for critical alerts
    const criticalAlerts = alertsToCreate.filter(alert => alert.severity === 'critical');
    for (const alert of criticalAlerts) {
      await sendGoalNotification(goal, alert);
    }
  }
}
```

**Comparative Analysis & Benchmarking**:
```typescript
// Advanced comparative analysis with statistical significance testing
export async function generateComparativeAnalysis(
  clinicId: string,
  comparisonType: 'provider' | 'time_period' | 'benchmark',
  filters: AnalysisFilters
) {
  const analysis = {
    type: comparisonType,
    filters,
    results: [],
    insights: [],
    recommendations: []
  };
  
  switch (comparisonType) {
    case 'provider':
      analysis.results = await compareProviderPerformance(clinicId, filters);
      break;
    case 'time_period':
      analysis.results = await compareTimePeriods(clinicId, filters);
      break;
    case 'benchmark':
      analysis.results = await compareToBenchmarks(clinicId, filters);
      break;
  }
  
  // Generate insights using statistical analysis
  analysis.insights = generateStatisticalInsights(analysis.results);
  
  // Generate actionable recommendations
  analysis.recommendations = generateRecommendations(analysis.results, analysis.insights);
  
  return analysis;
}

async function compareProviderPerformance(clinicId: string, filters: AnalysisFilters) {
  const providers = await prisma.provider.findMany({
    where: { clinicId, employmentStatus: 'active' }
  });
  
  const comparisons = [];
  
  for (const provider of providers) {
    const goals = await prisma.goal.findMany({
      where: {
        clinicId,
        targetEntityId: provider.id,
        goalType: 'provider',
        startDate: { gte: filters.startDate },
        endDate: { lte: filters.endDate }
      }
    });
    
    const providerMetrics = {
      providerId: provider.id,
      providerName: provider.providerName,
      totalGoals: goals.length,
      achievedGoals: 0,
      averageAchievementRate: 0,
      totalVariance: 0,
      performanceScore: 0
    };
    
    for (const goal of goals) {
      const progress = await calculateGoalProgress(goal.id);
      
      if (progress.progressPercentage >= 100) {
        providerMetrics.achievedGoals++;
      }
      
      providerMetrics.totalVariance += Math.abs(progress.variancePercentage);
    }
    
    providerMetrics.averageAchievementRate = goals.length > 0 ? 
      (providerMetrics.achievedGoals / goals.length) * 100 : 0;
    
    providerMetrics.performanceScore = calculatePerformanceScore(
      providerMetrics.averageAchievementRate,
      providerMetrics.totalVariance / goals.length
    );
    
    comparisons.push(providerMetrics);
  }
  
  // Rank providers by performance score
  comparisons.sort((a, b) => b.performanceScore - a.performanceScore);
  
  // Add rankings and percentiles
  comparisons.forEach((provider, index) => {
    provider.rank = index + 1;
    provider.percentile = ((comparisons.length - index) / comparisons.length) * 100;
  });
  
  return comparisons;
}
```

**Goal Template System**:
```typescript
// Industry-standard goal templates with benchmarks
export const GOAL_TEMPLATES = {
  financial: [
    {
      name: 'Monthly Production Target',
      description: 'Total production goal for the practice per month',
      defaultTargetType: 'absolute',
      benchmarkValue: 150000, // Industry benchmark
      category: 'financial',
      kpiMapping: 'total_production',
      calculationMethod: 'sum_monthly'
    },
    {
      name: 'Collection Rate',
      description: 'Percentage of production successfully collected',
      defaultTargetType: 'percentage',
      benchmarkValue: 98,
      category: 'financial',
      kpiMapping: 'collection_rate',
      calculationMethod: 'percentage_monthly'
    }
  ],
  patient: [
    {
      name: 'New Patient Acquisition',
      description: 'Number of new patients acquired per month',
      defaultTargetType: 'absolute',
      benchmarkValue: 25,
      category: 'patient',
      kpiMapping: 'new_patients',
      calculationMethod: 'count_monthly'
    },
    {
      name: 'Recare Rate',
      description: 'Percentage of patients returning for hygiene appointments',
      defaultTargetType: 'percentage',
      benchmarkValue: 85,
      category: 'patient',
      kpiMapping: 'recare_rate',
      calculationMethod: 'percentage_quarterly'
    }
  ],
  operational: [
    {
      name: 'Appointment Efficiency',
      description: 'Percentage of scheduled appointments that are kept',
      defaultTargetType: 'percentage',
      benchmarkValue: 92,
      category: 'operational',
      kpiMapping: 'appointment_keep_rate',
      calculationMethod: 'percentage_monthly'
    }
  ]
};

// Template-based goal creation
export async function createGoalFromTemplate(
  templateId: string,
  clinicId: string,
  customizations: GoalCustomizations
) {
  const template = await prisma.goalTemplate.findUnique({
    where: { id: templateId }
  });
  
  if (!template) throw new Error('Template not found');
  
  // Create goal with template defaults and customizations
  const goal = await prisma.goal.create({
    data: {
      clinicId,
      templateId,
      goalName: customizations.name || template.name,
      description: customizations.description || template.description,
      goalType: customizations.goalType,
      targetEntityId: customizations.targetEntityId,
      targetValue: customizations.targetValue || template.benchmarkValue,
      targetType: template.defaultTargetType,
      startDate: customizations.startDate,
      endDate: customizations.endDate,
      priority: customizations.priority || 'medium',
      createdBy: customizations.createdBy
    }
  });
  
  // Create automatic milestones based on goal duration
  const milestones = generateMilestones(goal);
  if (milestones.length > 0) {
    await prisma.goalMilestone.createMany({
      data: milestones.map(milestone => ({
        goalId: goal.id,
        ...milestone
      }))
    });
  }
  
  return goal;
}
```

**Export & Reporting System**:
```typescript
// Comprehensive goal reporting with multiple export formats
export async function generateGoalReport(
  clinicId: string,
  reportType: 'summary' | 'detailed' | 'comparative',
  filters: ReportFilters,
  format: 'pdf' | 'csv' | 'excel'
) {
  const reportData = await compileReportData(clinicId, reportType, filters);
  
  switch (format) {
    case 'pdf':
      return await generatePDFReport(reportData, reportType);
    case 'csv':
      return await generateCSVReport(reportData);
    case 'excel':
      return await generateExcelReport(reportData, reportType);
    default:
      throw new Error('Unsupported format');
  }
}

async function compileReportData(
  clinicId: string,
  reportType: string,
  filters: ReportFilters
) {
  const goals = await prisma.goal.findMany({
    where: {
      clinicId,
      startDate: { gte: filters.startDate },
      endDate: { lte: filters.endDate },
      ...(filters.goalType && { goalType: filters.goalType }),
      ...(filters.status && { status: filters.status })
    },
    include: {
      progress: true,
      milestones: true,
      alerts: { where: { severity: 'critical' } }
    }
  });
  
  const reportData = {
    summary: {
      totalGoals: goals.length,
      achievedGoals: 0,
      atRiskGoals: 0,
      averageProgress: 0
    },
    goals: [],
    insights: [],
    recommendations: []
  };
  
  // Process each goal for detailed metrics
  for (const goal of goals) {
    const progress = await calculateGoalProgress(goal.id);
    
    reportData.goals.push({
      id: goal.id,
      name: goal.goalName,
      type: goal.goalType,
      targetValue: goal.targetValue,
      currentValue: progress.currentValue,
      progressPercentage: progress.progressPercentage,
      variance: progress.variance,
      riskLevel: progress.riskLevel,
      achievementProbability: progress.forecast.achievementProbability
    });
    
    // Update summary statistics
    if (progress.progressPercentage >= 100) {
      reportData.summary.achievedGoals++;
    }
    if (progress.riskLevel === 'high') {
      reportData.summary.atRiskGoals++;
    }
  }
  
  reportData.summary.averageProgress = 
    reportData.goals.reduce((sum, goal) => sum + goal.progressPercentage, 0) / 
    reportData.goals.length;
  
  // Generate insights and recommendations
  reportData.insights = generateReportInsights(reportData.goals);
  reportData.recommendations = generateReportRecommendations(reportData.goals);
  
  return reportData;
}
```

This comprehensive specification covers all aspects of the Goal Tracking & Reporting feature, including sophisticated progress calculations, intelligent alerting, comparative analysis, template-based goal creation, and robust reporting capabilities. The implementation provides a foundation for data-driven goal management that can scale with the dental practice's growth and evolving needs.
</file>

<file path="dental_dashboard_architecture.svg">
<svg viewBox="0 0 1200 800" xmlns="http://www.w3.org/2000/svg">
  <!-- Background -->
  <rect width="1200" height="800" fill="#f8fafc"/>
  
  <!-- Title -->
  <text x="600" y="30" text-anchor="middle" font-family="Arial, sans-serif" font-size="20" font-weight="bold" fill="#1e293b">Dental Practice Analytics Dashboard - MVP Architecture</text>
  
  <!-- External Services Layer -->
  <rect x="50" y="60" width="300" height="120" rx="10" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
  <text x="200" y="85" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="#92400e">External Services</text>
  
  <!-- Google Sheets API -->
  <rect x="70" y="100" width="120" height="60" rx="8" fill="#ffffff" stroke="#4285f4" stroke-width="2"/>
  <text x="130" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#1a73e8">Google Sheets</text>
  <text x="130" y="135" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#1a73e8">API v4</text>
  <text x="130" y="150" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#5f6368">(OAuth 2.0)</text>
  
  <!-- Google OAuth -->
  <rect x="210" y="100" width="120" height="60" rx="8" fill="#ffffff" stroke="#4285f4" stroke-width="2"/>
  <text x="270" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#1a73e8">Google OAuth</text>
  <text x="270" y="135" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#1a73e8">2.0 Service</text>
  
  <!-- Frontend Layer -->
  <rect x="400" y="60" width="350" height="300" rx="10" fill="#dbeafe" stroke="#3b82f6" stroke-width="2"/>
  <text x="575" y="85" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="#1e40af">Frontend Layer (Next.js App Router)</text>
  
  <!-- Dashboard Components -->
  <rect x="420" y="100" width="140" height="80" rx="8" fill="#ffffff" stroke="#3b82f6" stroke-width="1"/>
  <text x="490" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#1e40af">Dashboard UI</text>
  <text x="490" y="135" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• ShadCN Components</text>
  <text x="490" y="150" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• Recharts</text>
  <text x="490" y="165" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• TailwindCSS</text>
  
  <!-- Auth Components -->
  <rect x="580" y="100" width="140" height="80" rx="8" fill="#ffffff" stroke="#3b82f6" stroke-width="1"/>
  <text x="650" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#1e40af">Auth & Navigation</text>
  <text x="650" y="135" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• Role-based Routes</text>
  <text x="650" y="150" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• Session Management</text>
  <text x="650" y="165" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• RLS Protection</text>
  
  <!-- State Management -->
  <rect x="420" y="200" width="140" height="70" rx="8" fill="#ffffff" stroke="#3b82f6" stroke-width="1"/>
  <text x="490" y="220" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#1e40af">State Management</text>
  <text x="490" y="235" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• TanStack Query</text>
  <text x="490" y="250" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• Server State Cache</text>
  <text x="490" y="265" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• Optimistic Updates</text>
  
  <!-- Google Integration -->
  <rect x="580" y="200" width="140" height="70" rx="8" fill="#ffffff" stroke="#3b82f6" stroke-width="1"/>
  <text x="650" y="220" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#1e40af">Google Integration</text>
  <text x="650" y="235" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• Sheet Selection UI</text>
  <text x="650" y="250" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• Column Mapping</text>
  <text x="650" y="265" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• Sync Status</text>
  
  <!-- Data Export -->
  <rect x="500" y="290" width="140" height="50" rx="8" fill="#ffffff" stroke="#3b82f6" stroke-width="1"/>
  <text x="570" y="310" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#1e40af">Export & Reports</text>
  <text x="570" y="325" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#3730a3">• PDF/CSV Export</text>
  
  <!-- API Layer -->
  <rect x="800" y="60" width="350" height="300" rx="10" fill="#dcfce7" stroke="#16a34a" stroke-width="2"/>
  <text x="975" y="85" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="#15803d">API Layer (Next.js API Routes)</text>
  
  <!-- API Routes -->
  <rect x="820" y="100" width="100" height="70" rx="8" fill="#ffffff" stroke="#16a34a" stroke-width="1"/>
  <text x="870" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" font-weight="bold" fill="#15803d">Auth API</text>
  <text x="870" y="135" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">/api/auth/*</text>
  <text x="870" y="150" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">Session mgmt</text>
  <text x="870" y="165" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">Role validation</text>
  
  <rect x="940" y="100" width="100" height="70" rx="8" fill="#ffffff" stroke="#16a34a" stroke-width="1"/>
  <text x="990" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" font-weight="bold" fill="#15803d">Google API</text>
  <text x="990" y="135" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">/api/google/*</text>
  <text x="990" y="150" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">Sheets integration</text>
  <text x="990" y="165" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">Data extraction</text>
  
  <rect x="1060" y="100" width="100" height="70" rx="8" fill="#ffffff" stroke="#16a34a" stroke-width="1"/>
  <text x="1110" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" font-weight="bold" fill="#15803d">Metrics API</text>
  <text x="1110" y="135" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">/api/metrics/*</text>
  <text x="1110" y="150" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">KPI calculations</text>
  <text x="1110" y="165" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">Aggregations</text>
  
  <!-- Business Logic -->
  <rect x="820" y="190" width="150" height="80" rx="8" fill="#ffffff" stroke="#16a34a" stroke-width="1"/>
  <text x="895" y="210" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#15803d">Business Logic Services</text>
  <text x="895" y="225" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">• Data Transformation</text>
  <text x="895" y="240" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">• KPI Calculations</text>
  <text x="895" y="255" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">• Validation Rules</text>
  
  <!-- Middleware -->
  <rect x="990" y="190" width="150" height="80" rx="8" fill="#ffffff" stroke="#16a34a" stroke-width="1"/>
  <text x="1065" y="210" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#15803d">Middleware</text>
  <text x="1065" y="225" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">• Rate Limiting</text>
  <text x="1065" y="240" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">• Error Handling</text>
  <text x="1065" y="255" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#166534">• Request Validation</text>
  
  <!-- Caching -->
  <rect x="880" y="290" width="120" height="50" rx="8" fill="#ffffff" stroke="#16a34a" stroke-width="1"/>
  <text x="940" y="310" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#15803d">Caching Layer</text>
  <text x="940" y="325" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#166534">TanStack Query Cache</text>
  
  <!-- Database Layer -->
  <rect x="400" y="400" width="750" height="200" rx="10" fill="#fef7ff" stroke="#9333ea" stroke-width="2"/>
  <text x="775" y="425" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="#7c3aed">Database Layer (Supabase)</text>
  
  <!-- Supabase Auth -->
  <rect x="420" y="450" width="120" height="80" rx="8" fill="#ffffff" stroke="#9333ea" stroke-width="1"/>
  <text x="480" y="470" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#7c3aed">Supabase Auth</text>
  <text x="480" y="485" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• OAuth 2.0</text>
  <text x="480" y="500" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Session Management</text>
  <text x="480" y="515" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Role-based Access</text>
  
  <!-- PostgreSQL -->
  <rect x="560" y="450" width="140" height="80" rx="8" fill="#ffffff" stroke="#9333ea" stroke-width="1"/>
  <text x="630" y="470" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#7c3aed">PostgreSQL Database</text>
  <text x="630" y="485" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Multi-tenant Schema</text>
  <text x="630" y="500" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• HIPAA Compliance</text>
  <text x="630" y="515" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Row Level Security</text>
  
  <!-- Prisma ORM -->
  <rect x="720" y="450" width="120" height="80" rx="8" fill="#ffffff" stroke="#9333ea" stroke-width="1"/>
  <text x="780" y="470" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#7c3aed">Prisma ORM</text>
  <text x="780" y="485" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Type-safe Queries</text>
  <text x="780" y="500" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Schema Migrations</text>
  <text x="780" y="515" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Connection Pooling</text>
  
  <!-- Supabase Storage -->
  <rect x="860" y="450" width="120" height="80" rx="8" fill="#ffffff" stroke="#9333ea" stroke-width="1"/>
  <text x="920" y="470" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#7c3aed">Supabase Storage</text>
  <text x="920" y="485" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• File Storage</text>
  <text x="920" y="500" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Export Files</text>
  <text x="920" y="515" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Asset Management</text>
  
  <!-- Edge Functions -->
  <rect x="1000" y="450" width="120" height="80" rx="8" fill="#ffffff" stroke="#9333ea" stroke-width="1"/>
  <text x="1060" y="470" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#7c3aed">Edge Functions</text>
  <text x="1060" y="485" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Data Processing</text>
  <text x="1060" y="500" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Background Jobs</text>
  <text x="1060" y="515" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">• Scheduled Sync</text>
  
  <!-- Row Level Security -->
  <rect x="590" y="550" width="200" height="40" rx="8" fill="#ffffff" stroke="#9333ea" stroke-width="1"/>
  <text x="690" y="570" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#7c3aed">Row Level Security (RLS)</text>
  <text x="690" y="585" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#6b21a8">Clinic-based Data Isolation</text>
  
  <!-- Infrastructure -->
  <rect x="50" y="650" width="1100" height="120" rx="10" fill="#f1f5f9" stroke="#64748b" stroke-width="2"/>
  <text x="600" y="675" text-anchor="middle" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="#334155">Infrastructure & DevOps</text>
  
  <!-- Vercel -->
  <rect x="100" y="690" width="150" height="60" rx="8" fill="#ffffff" stroke="#000000" stroke-width="1"/>
  <text x="175" y="710" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#000000">Vercel Deployment</text>
  <text x="175" y="725" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#374151">• Auto-scaling</text>
  <text x="175" y="740" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#374151">• Edge Functions</text>
  
  <!-- Monitoring -->
  <rect x="270" y="690" width="150" height="60" rx="8" fill="#ffffff" stroke="#64748b" stroke-width="1"/>
  <text x="345" y="710" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#334155">Monitoring</text>
  <text x="345" y="725" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• Error Tracking</text>
  <text x="345" y="740" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• Performance Metrics</text>
  
  <!-- Testing -->
  <rect x="440" y="690" width="150" height="60" rx="8" fill="#ffffff" stroke="#64748b" stroke-width="1"/>
  <text x="515" y="710" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#334155">Testing (Vitest)</text>
  <text x="515" y="725" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• Unit Tests</text>
  <text x="515" y="740" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• Integration Tests</text>
  
  <!-- CI/CD -->
  <rect x="610" y="690" width="150" height="60" rx="8" fill="#ffffff" stroke="#64748b" stroke-width="1"/>
  <text x="685" y="710" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#334155">CI/CD Pipeline</text>
  <text x="685" y="725" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• GitHub Actions</text>
  <text x="685" y="740" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• Automated Deploy</text>
  
  <!-- Analytics -->
  <rect x="780" y="690" width="150" height="60" rx="8" fill="#ffffff" stroke="#64748b" stroke-width="1"/>
  <text x="855" y="710" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#334155">Analytics</text>
  <text x="855" y="725" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• Usage Tracking</text>
  <text x="855" y="740" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• Performance Data</text>
  
  <!-- Security -->
  <rect x="950" y="690" width="150" height="60" rx="8" fill="#ffffff" stroke="#64748b" stroke-width="1"/>
  <text x="1025" y="710" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#334155">Security</text>
  <text x="1025" y="725" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• HIPAA Compliance</text>
  <text x="1025" y="740" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#475569">• Data Encryption</text>
  
  <!-- Data Flow Arrows -->
  <!-- External to Frontend -->
  <path d="M 350 130 L 400 130" stroke="#64748b" stroke-width="2" marker-end="url(#arrowhead)" fill="none"/>
  
  <!-- Frontend to API -->
  <path d="M 750 180 L 800 180" stroke="#64748b" stroke-width="2" marker-end="url(#arrowhead)" fill="none"/>
  
  <!-- API to Database -->
  <path d="M 975 360 L 775 400" stroke="#64748b" stroke-width="2" marker-end="url(#arrowhead)" fill="none"/>
  
  <!-- Define arrow marker -->
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
      <polygon points="0 0, 10 3.5, 0 7" fill="#64748b"/>
    </marker>
  </defs>
  
  <!-- Legend -->
  <text x="50" y="790" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#334155">Data Flow: External Services → Frontend → API → Database</text>
</svg>
</file>

<file path="feature-spec.md">
## Feature Specifications

### Google Sheets Integration Core

**Feature Goal**: Establish secure, reliable connection to Google Sheets API with automated data extraction and standardized metric mapping for essential dental practice KPIs, supporting multiple spreadsheets per clinic with comprehensive error handling and retry mechanisms.

**API Relationships**:
- Google Sheets API v4 for spreadsheet operations
- Supabase Auth API for credential storage
- Next.js API routes for frontend integration
- Supabase Edge Functions for background processing
- Prisma ORM for data source configuration management

#### Detailed Feature Requirements

**Authentication & Authorization**:
- Implement OAuth 2.0 flow with Google Sheets API using server-side authorization code flow
- Store encrypted Google API credentials in Supabase with automatic token refresh
- Support multiple Google accounts per clinic with account switching capability
- Implement scope validation to ensure minimum required permissions (spreadsheets.readonly)
- Handle OAuth errors including expired tokens, revoked access, and insufficient permissions

**Spreadsheet Discovery & Selection**:
- Retrieve and display all accessible spreadsheets from connected Google accounts
- Implement spreadsheet filtering by name, last modified date, and ownership
- Support folder-based organization display matching Google Drive structure
- Cache spreadsheet metadata with 1-hour TTL to reduce API calls
- Handle large spreadsheet lists with pagination (100 spreadsheets per page)

**Column Mapping & Templates**:
- Provide pre-defined mapping templates for common dental practice formats:
  - Production tracking (Date, Provider, Procedure Code, Amount, Patient)
  - Collection reports (Date, Payment Type, Amount, Insurance vs Patient Portion)
  - Appointment logs (Date, Time, Provider, Patient, Status, Type)
  - Patient demographics (Name, Phone, Email, Insurance, Last Visit)
- Support custom column mapping with drag-and-drop interface
- Validate column data types against expected KPI requirements
- Save mapping configurations per spreadsheet with versioning support
- Detect and suggest mapping changes when spreadsheet structure changes

**Data Extraction & Transformation**:
- Extract data using batch operations with 1000-row chunks to respect API limits
- Implement real-time data validation using Zod schemas during extraction
- Transform extracted data to standardized internal format with type coercion
- Handle missing data with configurable default values or skip rules
- Support date format standardization across different spreadsheet formats
- Implement data deduplication based on configurable key combinations

**Synchronization Management**:
- Support both manual and scheduled synchronization with cron-based scheduling
- Implement incremental sync using last-modified timestamps when available
- Provide detailed sync status tracking with progress indicators
- Store sync history with timestamp, record counts, and error details
- Support sync rollback for failed operations with data integrity protection
</file>

<file path="file-system.md">
## File System

### Frontend Repository Structure
```
dental-analytics-dashboard/
├── app/
│   ├── (auth)/
│   │   ├── login/
│   │   │   └── page.tsx
│   │   ├── register/
│   │   │   └── page.tsx
│   │   └── layout.tsx
│   ├── (dashboard)/
│   │   ├── dashboard/
│   │   │   ├── page.tsx
│   │   │   ├── loading.tsx
│   │   │   └── error.tsx
│   │   ├── integrations/
│   │   │   ├── google-sheets/
│   │   │   │   ├── page.tsx
│   │   │   │   ├── connect/
│   │   │   │   │   └── page.tsx
│   │   │   │   └── mapping/
│   │   │   │       └── page.tsx
│   │   │   └── page.tsx
│   │   ├── goals/
│   │   │   ├── page.tsx
│   │   │   ├── create/
│   │   │   │   └── page.tsx
│   │   │   └── [goalId]/
│   │   │       └── page.tsx
│   │   ├── reports/
│   │   │   ├── page.tsx
│   │   │   └── export/
│   │   │       └── page.tsx
│   │   ├── settings/
│   │   │   ├── page.tsx
│   │   │   ├── clinic/
│   │   │   │   └── page.tsx
│   │   │   ├── users/
│   │   │   │   ├── page.tsx
│   │   │   │   └── [userId]/
│   │   │   │       └── page.tsx
│   │   │   └── providers/
│   │   │       ├── page.tsx
│   │   │       └── [providerId]/
│   │   │           └── page.tsx
│   │   └── layout.tsx
│   ├── api/
│   │   ├── auth/
│   │   │   ├── google/
│   │   │   │   ├── connect/
│   │   │   │   │   └── route.ts
│   │   │   │   └── callback/
│   │   │   │       └── route.ts
│   │   │   └── session/
│   │   │       └── route.ts
│   │   ├── google-sheets/
│   │   │   ├── discover/
│   │   │   │   └── route.ts
│   │   │   ├── sync/
│   │   │   │   └── route.ts
│   │   │   ├── mapping/
│   │   │   │   └── route.ts
│   │   │   └── validate/
│   │   │       └── route.ts
│   │   ├── metrics/
│   │   │   ├── financial/
│   │   │   │   └── route.ts
│   │   │   ├── patients/
│   │   │   │   └── route.ts
│   │   │   ├── appointments/
│   │   │   │   └── route.ts
│   │   │   ├── providers/
│   │   │   │   └── route.ts
│   │   │   └── calls/
│   │   │       └── route.ts
│   │   ├── goals/
│   │   │   ├── route.ts
│   │   │   └── [goalId]/
│   │   │       └── route.ts
│   │   ├── users/
│   │   │   ├── route.ts
│   │   │   ├── invite/
│   │   │   │   └── route.ts
│   │   │   └── [userId]/
│   │   │       └── route.ts
│   │   ├── clinics/
│   │   │   ├── route.ts
│   │   │   └── [clinicId]/
│   │   │       ├── route.ts
│   │   │       └── providers/
│   │   │           └── route.ts
│   │   └── export/
│   │       ├── pdf/
│   │       │   └── route.ts
│   │       └── csv/
│   │           └── route.ts
│   ├── globals.css
│   ├── layout.tsx
│   └── page.tsx
├── components/
│   ├── ui/
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   ├── select.tsx
│   │   ├── card.tsx
│   │   ├── table.tsx
│   │   ├── badge.tsx
│   │   ├── progress.tsx
│   │   ├── dialog.tsx
│   │   ├── form.tsx
│   │   ├── toast.tsx
│   │   └── loading-spinner.tsx
│   ├── dashboard/
│   │   ├── metric-card.tsx
│   │   ├── kpi-chart.tsx
│   │   ├── provider-performance.tsx
│   │   ├── financial-overview.tsx
│   │   ├── patient-metrics.tsx
│   │   ├── appointment-analytics.tsx
│   │   ├── call-tracking.tsx
│   │   └── dashboard-layout.tsx
│   ├── google-sheets/
│   │   ├── connection-status.tsx
│   │   ├── spreadsheet-selector.tsx
│   │   ├── column-mapper.tsx
│   │   ├── sync-status.tsx
│   │   └── mapping-preview.tsx
│   ├── goals/
│   │   ├── goal-card.tsx
│   │   ├── goal-progress.tsx
│   │   ├── goal-form.tsx
│   │   └── variance-indicator.tsx
│   ├── users/
│   │   ├── user-table.tsx
│   │   ├── role-selector.tsx
│   │   ├── invite-form.tsx
│   │   └── provider-assignment.tsx
│   ├── auth/
│   │   ├── login-form.tsx
│   │   ├── register-form.tsx
│   │   └── auth-guard.tsx
│   └── common/
│       ├── navigation.tsx
│       ├── sidebar.tsx
│       ├── header.tsx
│       ├── filters.tsx
│       ├── date-picker.tsx
│       └── export-button.tsx
├── lib/
│   ├── auth/
│   │   ├── config.ts
│   │   ├── session.ts
│   │   └── middleware.ts
│   ├── database/
│   │   ├── prisma.ts
│   │   ├── queries/
│   │   │   ├── metrics.ts
│   │   │   ├── users.ts
│   │   │   ├── clinics.ts
│   │   │   ├── goals.ts
│   │   │   └── google-sheets.ts
│   │   └── schemas/
│   │       ├── user.ts
│   │       ├── clinic.ts
│   │       ├── metric.ts
│   │       ├── goal.ts
│   │       └── google-sheet.ts
│   ├── google-sheets/
│   │   ├── client.ts
│   │   ├── auth.ts
│   │   ├── sync.ts
│   │   ├── mapping.ts
│   │   └── validation.ts
│   ├── metrics/
│   │   ├── calculations.ts
│   │   ├── transformations.ts
│   │   ├── aggregations.ts
│   │   └── types.ts
│   ├── utils/
│   │   ├── validation.ts
│   │   ├── formatting.ts
│   │   ├── date-helpers.ts
│   │   ├── export.ts
│   │   └── logger.ts
│   └── types/
│       ├── auth.ts
│       ├── dashboard.ts
│       ├── metrics.ts
│       ├── goals.ts
│       └── api.ts
├── hooks/
│   ├── use-auth.ts
│   ├── use-metrics.ts
│   ├── use-google-sheets.ts
│   ├── use-goals.ts
│   ├── use-users.ts
│   └── use-filters.ts
├── middleware.ts
├── next.config.js
├── tailwind.config.js
├── package.json
└── prisma/
    ├── schema.prisma
    ├── migrations/
    └── seed.ts
```

### Backend Repository Structure (Supabase Functions)
```
supabase/
├── functions/
│   ├── google-sheets-sync/
│   │   ├── index.ts
│   │   ├── handlers/
│   │   │   ├── discovery.ts
│   │   │   ├── extraction.ts
│   │   │   ├── transformation.ts
│   │   │   └── validation.ts
│   │   └── types.ts
│   ├── metrics-calculation/
│   │   ├── index.ts
│   │   ├── calculators/
│   │   │   ├── financial.ts
│   │   │   ├── patients.ts
│   │   │   ├── appointments.ts
│   │   │   ├── providers.ts
│   │   │   └── calls.ts
│   │   └── aggregators/
│   │       ├── daily.ts
│   │       ├── weekly.ts
│   │       ├── monthly.ts
│   │       └── quarterly.ts
│   ├── goal-tracking/
│   │   ├── index.ts
│   │   ├── progress-calculator.ts
│   │   ├── variance-analyzer.ts
│   │   └── alert-generator.ts
│   ├── data-export/
│   │   ├── index.ts
│   │   ├── pdf-generator.ts
│   │   ├── csv-generator.ts
│   │   └── formatters.ts
│   ├── scheduled-sync/
│   │   ├── index.ts
│   │   ├── cron-handler.ts
│   │   └── retry-logic.ts
│   └── audit-logging/
│       ├── index.ts
│       ├── user-actions.ts
│       └── data-access.ts
├── migrations/
│   ├── 20240101000000_initial_schema.sql
│   ├── 20240101000001_user_management.sql
│   ├── 20240101000002_google_sheets_integration.sql
│   ├── 20240101000003_metrics_tables.sql
│   └── 20240101000004_goals_tracking.sql
└── config.toml
```
</file>

<file path="mvp.md">
## Launch Features (MVP)

### Google Sheets Integration Core
**Secure OAuth connection to Google Sheets with basic data extraction and standardized metric mapping for essential dental practice KPIs.**

* OAuth 2.0 authentication flow with Google Sheets API (free tier limits)
* Spreadsheet discovery and selection interface
* Pre-defined column mapping templates for common dental practice spreadsheet formats
* Automated data extraction with basic transformation rules via Supabase Edge Functions
* Manual data sync with simple status indicators and Winston logging for error tracking

#### Tech Involved
* Google Sheets API v4 with OAuth 2.0 (default rate limits)
* Supabase Auth for session management
* Next.js API routes for Google integration
* Supabase Edge Functions for data processing
* Prisma for data source configuration storage
* Winston for structured logging

#### Main Requirements
* Secure credential storage in Supabase
* Error handling with Winston logging for API failures and connection issues
* Data validation using Zod schemas for extracted spreadsheet data
* Support for multiple spreadsheets per clinic
* Retry logic with exponential backoff for API rate limits

### Essential KPI Dashboard
**Fixed dashboard layouts displaying core dental practice metrics with basic filtering and time period selection, optimized for up to 50 concurrent users.**

* Pre-built dashboard templates for each user role (Office Manager, Dentist, Front Desk)
* Core financial metrics (production, collections, payments)
* Patient metrics (active patients, new patients, recare rates)
* Appointment analytics (total kept, cancellation rates, hygiene breakdown)
* Provider performance basics (production by provider, treatment planning)
* Call tracking performance (unscheduled treatment, hygiene reactivation)
* Time period filtering (daily, weekly, monthly, quarterly)
* Clinic and provider-level filtering

#### Tech Involved
* Recharts for visualization components
* TanStack Query for data fetching and caching (sufficient for 50 users)
* ShadCN UI for dashboard layout components
* Prisma for metrics data queries with connection pooling
* Supabase Edge Functions for complex metric calculations

#### Main Requirements
* Responsive design for mobile and desktop access
* Role-based dashboard content filtering via Supabase RLS
* Efficient data aggregation queries optimized for small user base
* Export capabilities (PDF/CSV) via Supabase Storage
* Real-time data updates through Supabase Edge Functions

### Multi-Tenant User Management
**Role-based access control system supporting multiple dental practices with provider-specific data isolation, designed for small practice teams.**

* Clinic-based user organization and data isolation via Supabase RLS
* Role definitions (Office Manager, Dentist, Front Desk, Admin)
* Provider association and performance tracking
* Basic user profile management and invitation system
* Session management with secure JWT handling

#### Tech Involved
* Supabase Auth with Row Level Security (RLS)
* Prisma schema with multi-tenant relationships
* Next.js middleware for route protection
* Server actions for user management
* Winston logging for audit trails

#### Main Requirements
* HIPAA-compliant data isolation between clinics using RLS policies
* Secure session management via Supabase Auth
* Provider performance data association and tracking
* Audit logging with Winston for user actions and data access
* Input validation using Zod schemas for all user data

### Data Synchronization & Processing
**Automated background processing for Google Sheets data transformation and metric calculations using Supabase Edge Functions.**

* Scheduled data synchronization using Supabase cron jobs
* Real-time data transformation pipeline via Edge Functions
* Historical data import for existing spreadsheet data (< 1000 rows)
* Data validation and error handling with comprehensive logging
* Metric calculation engine for complex KPI computations

#### Tech Involved
* Supabase Edge Functions for all background processing
* Supabase cron jobs for scheduled synchronization
* Prisma for efficient batch operations
* Winston for structured logging and error tracking
* Zod for runtime data validation

#### Main Requirements
* Reliable data transformation with error recovery
* Efficient processing of small datasets (< 1000 rows)
* Comprehensive error logging and monitoring
* Data consistency validation between Google Sheets and database
* Simple retry mechanisms for failed operations

### Goal Tracking & Reporting
**Basic goal setting and performance tracking against established targets with simple variance reporting.**

* Goal definition by clinic and provider
* Time-based goal tracking (monthly, quarterly, annual)
* Variance reporting and trend analysis
* Performance indicators with visual goal progress
* Basic comparative analysis between providers and time periods

#### Tech Involved
* Prisma for goal data management
* Recharts for goal visualization components
* Supabase Edge Functions for goal calculations
* TanStack Query for real-time goal progress updates

#### Main Requirements
* Simple goal configuration interface
* Visual progress indicators on dashboards
* Historical goal performance tracking
* Basic alerting for goal achievement/variance
* Export capabilities for goal reports

#### System Diagram

![System Diagram](dental_dashboard_architecture.svg)
</file>

</files>
